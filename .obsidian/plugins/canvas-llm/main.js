/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key3, value) => key3 in obj ? __defProp(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key3 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key3) && key3 !== except)
        __defProp(to, key3, { get: () => from[key3], enumerable: !(desc = __getOwnPropDesc(from, key3)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key3, value) => __defNormalProp(obj, typeof key3 !== "symbol" ? key3 + "" : key3, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// src/app/main.js
var main_exports = {};
__export(main_exports, {
  default: () => main_default
});
module.exports = __toCommonJS(main_exports);

// src/obsidian/CanvasPlugin.js
var import_obsidian4 = require("obsidian");

// src/obsidian/CanvasView.js
var import_obsidian3 = require("obsidian");

// node_modules/esm-env/dev-fallback.js
var _a, _b;
var node_env = (_b = (_a = globalThis.process) == null ? void 0 : _a.env) == null ? void 0 : _b.NODE_ENV;
var dev_fallback_default = node_env && !node_env.toLowerCase().startsWith("prod");

// node_modules/svelte/src/internal/shared/utils.js
var is_array = Array.isArray;
var index_of = Array.prototype.indexOf;
var array_from = Array.from;
var object_keys = Object.keys;
var define_property = Object.defineProperty;
var get_descriptor = Object.getOwnPropertyDescriptor;
var get_descriptors = Object.getOwnPropertyDescriptors;
var object_prototype = Object.prototype;
var array_prototype = Array.prototype;
var get_prototype_of = Object.getPrototypeOf;
var is_extensible = Object.isExtensible;
function is_function(thing) {
  return typeof thing === "function";
}
var noop = () => {
};
function run(fn) {
  return fn();
}
function run_all(arr) {
  for (var i = 0; i < arr.length; i++) {
    arr[i]();
  }
}
function deferred() {
  var resolve;
  var reject;
  var promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
}
function fallback(value, fallback2, lazy = false) {
  return value === void 0 ? lazy ? (
    /** @type {() => V} */
    fallback2()
  ) : (
    /** @type {V} */
    fallback2
  ) : value;
}
function to_array(value, n) {
  if (Array.isArray(value)) {
    return value;
  }
  if (n === void 0 || !(Symbol.iterator in value)) {
    return Array.from(value);
  }
  const array2 = [];
  for (const element2 of value) {
    array2.push(element2);
    if (array2.length === n) break;
  }
  return array2;
}

// node_modules/svelte/src/internal/client/constants.js
var DERIVED = 1 << 1;
var EFFECT = 1 << 2;
var RENDER_EFFECT = 1 << 3;
var BLOCK_EFFECT = 1 << 4;
var BRANCH_EFFECT = 1 << 5;
var ROOT_EFFECT = 1 << 6;
var BOUNDARY_EFFECT = 1 << 7;
var UNOWNED = 1 << 8;
var DISCONNECTED = 1 << 9;
var CLEAN = 1 << 10;
var DIRTY = 1 << 11;
var MAYBE_DIRTY = 1 << 12;
var INERT = 1 << 13;
var DESTROYED = 1 << 14;
var EFFECT_RAN = 1 << 15;
var EFFECT_TRANSPARENT = 1 << 16;
var INSPECT_EFFECT = 1 << 17;
var HEAD_EFFECT = 1 << 18;
var EFFECT_PRESERVED = 1 << 19;
var USER_EFFECT = 1 << 20;
var REACTION_IS_UPDATING = 1 << 21;
var ASYNC = 1 << 22;
var ERROR_VALUE = 1 << 23;
var STATE_SYMBOL = Symbol("$state");
var LEGACY_PROPS = Symbol("legacy props");
var LOADING_ATTR_SYMBOL = Symbol("");
var PROXY_PATH_SYMBOL = Symbol("proxy path");
var STALE_REACTION = new class StaleReactionError extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "StaleReactionError");
    __publicField(this, "message", "The reaction that called `getAbortSignal()` was re-run or destroyed");
  }
}();
var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;

// node_modules/svelte/src/internal/shared/errors.js
function lifecycle_outside_component(name) {
  if (dev_fallback_default) {
    const error = new Error(`lifecycle_outside_component
\`${name}(...)\` can only be used during component initialisation
https://svelte.dev/e/lifecycle_outside_component`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/lifecycle_outside_component`);
  }
}

// node_modules/svelte/src/internal/client/errors.js
function async_derived_orphan() {
  if (dev_fallback_default) {
    const error = new Error(`async_derived_orphan
Cannot create a \`$derived(...)\` with an \`await\` expression outside of an effect tree
https://svelte.dev/e/async_derived_orphan`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/async_derived_orphan`);
  }
}
function bind_invalid_checkbox_value() {
  if (dev_fallback_default) {
    const error = new Error(`bind_invalid_checkbox_value
Using \`bind:value\` together with a checkbox input is not allowed. Use \`bind:checked\` instead
https://svelte.dev/e/bind_invalid_checkbox_value`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/bind_invalid_checkbox_value`);
  }
}
function derived_references_self() {
  if (dev_fallback_default) {
    const error = new Error(`derived_references_self
A derived value cannot reference itself recursively
https://svelte.dev/e/derived_references_self`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/derived_references_self`);
  }
}
function effect_in_teardown(rune) {
  if (dev_fallback_default) {
    const error = new Error(`effect_in_teardown
\`${rune}\` cannot be used inside an effect cleanup function
https://svelte.dev/e/effect_in_teardown`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_in_teardown`);
  }
}
function effect_in_unowned_derived() {
  if (dev_fallback_default) {
    const error = new Error(`effect_in_unowned_derived
Effect cannot be created inside a \`$derived\` value that was not itself created inside an effect
https://svelte.dev/e/effect_in_unowned_derived`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_in_unowned_derived`);
  }
}
function effect_orphan(rune) {
  if (dev_fallback_default) {
    const error = new Error(`effect_orphan
\`${rune}\` can only be used inside an effect (e.g. during component initialisation)
https://svelte.dev/e/effect_orphan`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_orphan`);
  }
}
function effect_update_depth_exceeded() {
  if (dev_fallback_default) {
    const error = new Error(`effect_update_depth_exceeded
Maximum update depth exceeded. This typically indicates that an effect reads and writes the same piece of state
https://svelte.dev/e/effect_update_depth_exceeded`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
  }
}
function flush_sync_in_effect() {
  if (dev_fallback_default) {
    const error = new Error(`flush_sync_in_effect
Cannot use \`flushSync\` inside an effect
https://svelte.dev/e/flush_sync_in_effect`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/flush_sync_in_effect`);
  }
}
function hydration_failed() {
  if (dev_fallback_default) {
    const error = new Error(`hydration_failed
Failed to hydrate the application
https://svelte.dev/e/hydration_failed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/hydration_failed`);
  }
}
function invalid_snippet() {
  if (dev_fallback_default) {
    const error = new Error(`invalid_snippet
Could not \`{@render}\` snippet due to the expression being \`null\` or \`undefined\`. Consider using optional chaining \`{@render snippet?.()}\`
https://svelte.dev/e/invalid_snippet`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/invalid_snippet`);
  }
}
function props_invalid_value(key3) {
  if (dev_fallback_default) {
    const error = new Error(`props_invalid_value
Cannot do \`bind:${key3}={undefined}\` when \`${key3}\` has a fallback value
https://svelte.dev/e/props_invalid_value`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/props_invalid_value`);
  }
}
function props_rest_readonly(property) {
  if (dev_fallback_default) {
    const error = new Error(`props_rest_readonly
Rest element properties of \`$props()\` such as \`${property}\` are readonly
https://svelte.dev/e/props_rest_readonly`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/props_rest_readonly`);
  }
}
function rune_outside_svelte(rune) {
  if (dev_fallback_default) {
    const error = new Error(`rune_outside_svelte
The \`${rune}\` rune is only available inside \`.svelte\` and \`.svelte.js/ts\` files
https://svelte.dev/e/rune_outside_svelte`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/rune_outside_svelte`);
  }
}
function set_context_after_init() {
  if (dev_fallback_default) {
    const error = new Error(`set_context_after_init
\`setContext\` must be called when a component first initializes, not in a subsequent effect or after an \`await\` expression
https://svelte.dev/e/set_context_after_init`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/set_context_after_init`);
  }
}
function state_descriptors_fixed() {
  if (dev_fallback_default) {
    const error = new Error(`state_descriptors_fixed
Property descriptors defined on \`$state\` objects must contain \`value\` and always be \`enumerable\`, \`configurable\` and \`writable\`.
https://svelte.dev/e/state_descriptors_fixed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_descriptors_fixed`);
  }
}
function state_prototype_fixed() {
  if (dev_fallback_default) {
    const error = new Error(`state_prototype_fixed
Cannot set prototype of \`$state\` object
https://svelte.dev/e/state_prototype_fixed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_prototype_fixed`);
  }
}
function state_unsafe_mutation() {
  if (dev_fallback_default) {
    const error = new Error(`state_unsafe_mutation
Updating state inside \`$derived(...)\`, \`$inspect(...)\` or a template expression is forbidden. If the value should not be reactive, declare it without \`$state\`
https://svelte.dev/e/state_unsafe_mutation`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
  }
}
function svelte_boundary_reset_onerror() {
  if (dev_fallback_default) {
    const error = new Error(`svelte_boundary_reset_onerror
A \`<svelte:boundary>\` \`reset\` function cannot be called while an error is still being handled
https://svelte.dev/e/svelte_boundary_reset_onerror`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/svelte_boundary_reset_onerror`);
  }
}

// node_modules/svelte/src/constants.js
var EACH_ITEM_REACTIVE = 1;
var EACH_INDEX_REACTIVE = 1 << 1;
var EACH_IS_CONTROLLED = 1 << 2;
var EACH_IS_ANIMATED = 1 << 3;
var EACH_ITEM_IMMUTABLE = 1 << 4;
var PROPS_IS_IMMUTABLE = 1;
var PROPS_IS_RUNES = 1 << 1;
var PROPS_IS_UPDATED = 1 << 2;
var PROPS_IS_BINDABLE = 1 << 3;
var PROPS_IS_LAZY_INITIAL = 1 << 4;
var TRANSITION_OUT = 1 << 1;
var TRANSITION_GLOBAL = 1 << 2;
var TEMPLATE_FRAGMENT = 1;
var TEMPLATE_USE_IMPORT_NODE = 1 << 1;
var TEMPLATE_USE_SVG = 1 << 2;
var TEMPLATE_USE_MATHML = 1 << 3;
var HYDRATION_START = "[";
var HYDRATION_START_ELSE = "[!";
var HYDRATION_END = "]";
var HYDRATION_ERROR = {};
var ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;
var ELEMENT_IS_INPUT = 1 << 2;
var UNINITIALIZED = Symbol();
var FILENAME = Symbol("filename");
var HMR = Symbol("hmr");
var NAMESPACE_HTML = "http://www.w3.org/1999/xhtml";
var NAMESPACE_SVG = "http://www.w3.org/2000/svg";
var ATTACHMENT_KEY = "@attach";

// node_modules/svelte/src/internal/client/warnings.js
var bold = "font-weight: bold";
var normal = "font-weight: normal";
function await_reactivity_loss(name) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] await_reactivity_loss
%cDetected reactivity loss when reading \`${name}\`. This happens when state is read in an async function after an earlier \`await\`
https://svelte.dev/e/await_reactivity_loss`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/await_reactivity_loss`);
  }
}
function await_waterfall(name, location) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] await_waterfall
%cAn async derived, \`${name}\` (${location}) was not read immediately after it resolved. This often indicates an unnecessary waterfall, which can slow down your app
https://svelte.dev/e/await_waterfall`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/await_waterfall`);
  }
}
function hydration_attribute_changed(attribute, html2, value) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] hydration_attribute_changed
%cThe \`${attribute}\` attribute on \`${html2}\` changed its value between server and client renders. The client value, \`${value}\`, will be ignored in favour of the server value
https://svelte.dev/e/hydration_attribute_changed`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/hydration_attribute_changed`);
  }
}
function hydration_mismatch(location) {
  if (dev_fallback_default) {
    console.warn(
      `%c[svelte] hydration_mismatch
%c${location ? `Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near ${location}` : "Hydration failed because the initial UI does not match what was rendered on the server"}
https://svelte.dev/e/hydration_mismatch`,
      bold,
      normal
    );
  } else {
    console.warn(`https://svelte.dev/e/hydration_mismatch`);
  }
}
function lifecycle_double_unmount() {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] lifecycle_double_unmount
%cTried to unmount a component that was not mounted
https://svelte.dev/e/lifecycle_double_unmount`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/lifecycle_double_unmount`);
  }
}
function select_multiple_invalid_value() {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] select_multiple_invalid_value
%cThe \`value\` property of a \`<select multiple>\` element should be an array, but it received a non-array value. The selection will be kept as is.
https://svelte.dev/e/select_multiple_invalid_value`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/select_multiple_invalid_value`);
  }
}
function state_proxy_equality_mismatch(operator) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] state_proxy_equality_mismatch
%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${operator}\` will produce unexpected results
https://svelte.dev/e/state_proxy_equality_mismatch`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/state_proxy_equality_mismatch`);
  }
}
function state_proxy_unmount() {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] state_proxy_unmount
%cTried to unmount a state proxy, rather than a component
https://svelte.dev/e/state_proxy_unmount`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/state_proxy_unmount`);
  }
}
function svelte_boundary_reset_noop() {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] svelte_boundary_reset_noop
%cA \`<svelte:boundary>\` \`reset\` function only resets the boundary the first time it is called
https://svelte.dev/e/svelte_boundary_reset_noop`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/svelte_boundary_reset_noop`);
  }
}

// node_modules/svelte/src/internal/client/dom/hydration.js
var hydrating = false;
function set_hydrating(value) {
  hydrating = value;
}
var hydrate_node;
function set_hydrate_node(node) {
  if (node === null) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  return hydrate_node = node;
}
function hydrate_next() {
  return set_hydrate_node(
    /** @type {TemplateNode} */
    get_next_sibling(hydrate_node)
  );
}
function reset(node) {
  if (!hydrating) return;
  if (get_next_sibling(hydrate_node) !== null) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  hydrate_node = node;
}
function next(count = 1) {
  if (hydrating) {
    var i = count;
    var node = hydrate_node;
    while (i--) {
      node = /** @type {TemplateNode} */
      get_next_sibling(node);
    }
    hydrate_node = node;
  }
}
function skip_nodes(remove2 = true) {
  var depth = 0;
  var node = hydrate_node;
  while (true) {
    if (node.nodeType === COMMENT_NODE) {
      var data = (
        /** @type {Comment} */
        node.data
      );
      if (data === HYDRATION_END) {
        if (depth === 0) return node;
        depth -= 1;
      } else if (data === HYDRATION_START || data === HYDRATION_START_ELSE) {
        depth += 1;
      }
    }
    var next2 = (
      /** @type {TemplateNode} */
      get_next_sibling(node)
    );
    if (remove2) node.remove();
    node = next2;
  }
}
function read_hydration_instruction(node) {
  if (!node || node.nodeType !== COMMENT_NODE) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  return (
    /** @type {Comment} */
    node.data
  );
}

// node_modules/svelte/src/internal/client/reactivity/equality.js
function equals(value) {
  return value === this.v;
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a !== null && typeof a === "object" || typeof a === "function";
}
function safe_equals(value) {
  return !safe_not_equal(value, this.v);
}

// node_modules/svelte/src/internal/flags/index.js
var async_mode_flag = false;
var legacy_mode_flag = false;
var tracing_mode_flag = false;
function enable_legacy_mode_flag() {
  legacy_mode_flag = true;
}

// node_modules/svelte/src/internal/shared/warnings.js
var bold2 = "font-weight: bold";
var normal2 = "font-weight: normal";
function state_snapshot_uncloneable(properties) {
  if (dev_fallback_default) {
    console.warn(
      `%c[svelte] state_snapshot_uncloneable
%c${properties ? `The following properties cannot be cloned with \`$state.snapshot\` \u2014 the return value contains the originals:

${properties}` : "Value cannot be cloned with `$state.snapshot` \u2014 the original value was returned"}
https://svelte.dev/e/state_snapshot_uncloneable`,
      bold2,
      normal2
    );
  } else {
    console.warn(`https://svelte.dev/e/state_snapshot_uncloneable`);
  }
}

// node_modules/svelte/src/internal/shared/clone.js
var empty = [];
function snapshot(value, skip_warning = false, no_tojson = false) {
  if (dev_fallback_default && !skip_warning) {
    const paths = [];
    const copy = clone(value, /* @__PURE__ */ new Map(), "", paths, null, no_tojson);
    if (paths.length === 1 && paths[0] === "") {
      state_snapshot_uncloneable();
    } else if (paths.length > 0) {
      const slice = paths.length > 10 ? paths.slice(0, 7) : paths.slice(0, 10);
      const excess = paths.length - slice.length;
      let uncloned = slice.map((path) => `- <value>${path}`).join("\n");
      if (excess > 0) uncloned += `
- ...and ${excess} more`;
      state_snapshot_uncloneable(uncloned);
    }
    return copy;
  }
  return clone(value, /* @__PURE__ */ new Map(), "", empty, null, no_tojson);
}
function clone(value, cloned, path, paths, original = null, no_tojson = false) {
  if (typeof value === "object" && value !== null) {
    var unwrapped = cloned.get(value);
    if (unwrapped !== void 0) return unwrapped;
    if (value instanceof Map) return (
      /** @type {Snapshot<T>} */
      new Map(value)
    );
    if (value instanceof Set) return (
      /** @type {Snapshot<T>} */
      new Set(value)
    );
    if (is_array(value)) {
      var copy = (
        /** @type {Snapshot<any>} */
        Array(value.length)
      );
      cloned.set(value, copy);
      if (original !== null) {
        cloned.set(original, copy);
      }
      for (var i = 0; i < value.length; i += 1) {
        var element2 = value[i];
        if (i in value) {
          copy[i] = clone(element2, cloned, dev_fallback_default ? `${path}[${i}]` : path, paths, null, no_tojson);
        }
      }
      return copy;
    }
    if (get_prototype_of(value) === object_prototype) {
      copy = {};
      cloned.set(value, copy);
      if (original !== null) {
        cloned.set(original, copy);
      }
      for (var key3 in value) {
        copy[key3] = clone(
          // @ts-expect-error
          value[key3],
          cloned,
          dev_fallback_default ? `${path}.${key3}` : path,
          paths,
          null,
          no_tojson
        );
      }
      return copy;
    }
    if (value instanceof Date) {
      return (
        /** @type {Snapshot<T>} */
        structuredClone(value)
      );
    }
    if (typeof /** @type {T & { toJSON?: any } } */
    value.toJSON === "function" && !no_tojson) {
      return clone(
        /** @type {T & { toJSON(): any } } */
        value.toJSON(),
        cloned,
        dev_fallback_default ? `${path}.toJSON()` : path,
        paths,
        // Associate the instance with the toJSON clone
        value
      );
    }
  }
  if (value instanceof EventTarget) {
    return (
      /** @type {Snapshot<T>} */
      value
    );
  }
  try {
    return (
      /** @type {Snapshot<T>} */
      structuredClone(value)
    );
  } catch (e) {
    if (dev_fallback_default) {
      paths.push(path);
    }
    return (
      /** @type {Snapshot<T>} */
      value
    );
  }
}

// node_modules/svelte/src/internal/client/dev/tracing.js
var tracing_expressions = null;
function get_stack(label2) {
  let error = Error();
  const stack2 = error.stack;
  if (!stack2) return null;
  const lines = stack2.split("\n");
  const new_lines = ["\n"];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (line === "Error") {
      continue;
    }
    if (line.includes("validate_each_keys")) {
      return null;
    }
    if (line.includes("svelte/src/internal")) {
      continue;
    }
    new_lines.push(line);
  }
  if (new_lines.length === 1) {
    return null;
  }
  define_property(error, "stack", {
    value: new_lines.join("\n")
  });
  define_property(error, "name", {
    // 'Error' suffix is required for stack traces to be rendered properly
    value: `${label2}Error`
  });
  return (
    /** @type {Error & { stack: string }} */
    error
  );
}
function tag(source2, label2) {
  source2.label = label2;
  tag_proxy(source2.v, label2);
  return source2;
}
function tag_proxy(value, label2) {
  var _a3;
  (_a3 = value == null ? void 0 : value[PROXY_PATH_SYMBOL]) == null ? void 0 : _a3.call(value, label2);
  return value;
}

// node_modules/svelte/src/internal/client/context.js
var component_context = null;
function set_component_context(context) {
  component_context = context;
}
var dev_stack = null;
function set_dev_stack(stack2) {
  dev_stack = stack2;
}
var dev_current_component_function = null;
function set_dev_current_component_function(fn) {
  dev_current_component_function = fn;
}
function getContext(key3) {
  const context_map = get_or_init_context_map("getContext");
  const result = (
    /** @type {T} */
    context_map.get(key3)
  );
  return result;
}
function setContext(key3, context) {
  const context_map = get_or_init_context_map("setContext");
  if (async_mode_flag) {
    var flags2 = (
      /** @type {Effect} */
      active_effect.f
    );
    var valid = !active_reaction && (flags2 & BRANCH_EFFECT) !== 0 && (flags2 & EFFECT_RAN) === 0;
    if (!valid) {
      set_context_after_init();
    }
  }
  context_map.set(key3, context);
  return context;
}
function push(props, runes = false, fn) {
  component_context = {
    p: component_context,
    c: null,
    e: null,
    s: props,
    x: null,
    l: legacy_mode_flag && !runes ? { s: null, u: null, $: [] } : null
  };
  if (dev_fallback_default) {
    component_context.function = fn;
    dev_current_component_function = fn;
  }
}
function pop(component2) {
  var _a3;
  var context = (
    /** @type {ComponentContext} */
    component_context
  );
  var effects = context.e;
  if (effects !== null) {
    context.e = null;
    for (var fn of effects) {
      create_user_effect(fn);
    }
  }
  if (component2 !== void 0) {
    context.x = component2;
  }
  component_context = context.p;
  if (dev_fallback_default) {
    dev_current_component_function = (_a3 = component_context == null ? void 0 : component_context.function) != null ? _a3 : null;
  }
  return component2 != null ? component2 : (
    /** @type {T} */
    {}
  );
}
function is_runes() {
  return !legacy_mode_flag || component_context !== null && component_context.l === null;
}
function get_or_init_context_map(name) {
  var _a3;
  if (component_context === null) {
    lifecycle_outside_component(name);
  }
  return (_a3 = component_context.c) != null ? _a3 : component_context.c = new Map(get_parent_context(component_context) || void 0);
}
function get_parent_context(component_context2) {
  let parent = component_context2.p;
  while (parent !== null) {
    const context_map = parent.c;
    if (context_map !== null) {
      return context_map;
    }
    parent = parent.p;
  }
  return null;
}

// node_modules/svelte/src/internal/client/dom/task.js
var micro_tasks = [];
function run_micro_tasks() {
  var tasks = micro_tasks;
  micro_tasks = [];
  run_all(tasks);
}
function queue_micro_task(fn) {
  if (micro_tasks.length === 0 && !is_flushing_sync) {
    var tasks = micro_tasks;
    queueMicrotask(() => {
      if (tasks === micro_tasks) run_micro_tasks();
    });
  }
  micro_tasks.push(fn);
}
function flush_tasks() {
  while (micro_tasks.length > 0) {
    run_micro_tasks();
  }
}

// node_modules/svelte/src/internal/client/error-handling.js
var adjustments = /* @__PURE__ */ new WeakMap();
function handle_error(error) {
  var effect2 = active_effect;
  if (effect2 === null) {
    active_reaction.f |= ERROR_VALUE;
    return error;
  }
  if (dev_fallback_default && error instanceof Error && !adjustments.has(error)) {
    adjustments.set(error, get_adjustments(error, effect2));
  }
  if ((effect2.f & EFFECT_RAN) === 0) {
    if ((effect2.f & BOUNDARY_EFFECT) === 0) {
      if (!effect2.parent && error instanceof Error) {
        apply_adjustments(error);
      }
      throw error;
    }
    effect2.b.error(error);
  } else {
    invoke_error_boundary(error, effect2);
  }
}
function invoke_error_boundary(error, effect2) {
  while (effect2 !== null) {
    if ((effect2.f & BOUNDARY_EFFECT) !== 0) {
      try {
        effect2.b.error(error);
        return;
      } catch (e) {
        error = e;
      }
    }
    effect2 = effect2.parent;
  }
  if (error instanceof Error) {
    apply_adjustments(error);
  }
  throw error;
}
function get_adjustments(error, effect2) {
  var _a3, _b3, _c2;
  const message_descriptor = get_descriptor(error, "message");
  if (message_descriptor && !message_descriptor.configurable) return;
  var indent = is_firefox ? "  " : "	";
  var component_stack = `
${indent}in ${((_a3 = effect2.fn) == null ? void 0 : _a3.name) || "<unknown>"}`;
  var context = effect2.ctx;
  while (context !== null) {
    component_stack += `
${indent}in ${(_b3 = context.function) == null ? void 0 : _b3[FILENAME].split("/").pop()}`;
    context = context.p;
  }
  return {
    message: error.message + `
${component_stack}
`,
    stack: (_c2 = error.stack) == null ? void 0 : _c2.split("\n").filter((line) => !line.includes("svelte/src/internal")).join("\n")
  };
}
function apply_adjustments(error) {
  const adjusted = adjustments.get(error);
  if (adjusted) {
    define_property(error, "message", {
      value: adjusted.message
    });
    define_property(error, "stack", {
      value: adjusted.stack
    });
  }
}

// node_modules/svelte/src/internal/client/reactivity/batch.js
var batches = /* @__PURE__ */ new Set();
var current_batch = null;
var previous_batch = null;
var batch_values = null;
var effect_pending_updates = /* @__PURE__ */ new Set();
var queued_root_effects = [];
var last_scheduled_effect = null;
var is_flushing = false;
var is_flushing_sync = false;
var _previous, _callbacks, _pending, _deferred, _boundary_async_effects, _render_effects, _effects, _block_effects, _dirty_effects, _maybe_dirty_effects, _Batch_instances, traverse_effect_tree_fn, defer_effects_fn, commit_fn;
var _Batch = class _Batch {
  constructor() {
    __privateAdd(this, _Batch_instances);
    /**
     * The current values of any sources that are updated in this batch
     * They keys of this map are identical to `this.#previous`
     * @type {Map<Source, any>}
     */
    __publicField(this, "current", /* @__PURE__ */ new Map());
    /**
     * The values of any sources that are updated in this batch _before_ those updates took place.
     * They keys of this map are identical to `this.#current`
     * @type {Map<Source, any>}
     */
    __privateAdd(this, _previous, /* @__PURE__ */ new Map());
    /**
     * When the batch is committed (and the DOM is updated), we need to remove old branches
     * and append new ones by calling the functions added inside (if/each/key/etc) blocks
     * @type {Set<() => void>}
     */
    __privateAdd(this, _callbacks, /* @__PURE__ */ new Set());
    /**
     * The number of async effects that are currently in flight
     */
    __privateAdd(this, _pending, 0);
    /**
     * A deferred that resolves when the batch is committed, used with `settled()`
     * TODO replace with Promise.withResolvers once supported widely enough
     * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
     */
    __privateAdd(this, _deferred, null);
    /**
     * Async effects inside a newly-created `<svelte:boundary>`
     * — these do not prevent the batch from committing
     * @type {Effect[]}
     */
    __privateAdd(this, _boundary_async_effects, []);
    /**
     * Template effects and `$effect.pre` effects, which run when
     * a batch is committed
     * @type {Effect[]}
     */
    __privateAdd(this, _render_effects, []);
    /**
     * The same as `#render_effects`, but for `$effect` (which runs after)
     * @type {Effect[]}
     */
    __privateAdd(this, _effects, []);
    /**
     * Block effects, which may need to re-run on subsequent flushes
     * in order to update internal sources (e.g. each block items)
     * @type {Effect[]}
     */
    __privateAdd(this, _block_effects, []);
    /**
     * Deferred effects (which run after async work has completed) that are DIRTY
     * @type {Effect[]}
     */
    __privateAdd(this, _dirty_effects, []);
    /**
     * Deferred effects that are MAYBE_DIRTY
     * @type {Effect[]}
     */
    __privateAdd(this, _maybe_dirty_effects, []);
    /**
     * A set of branches that still exist, but will be destroyed when this batch
     * is committed — we skip over these during `process`
     * @type {Set<Effect>}
     */
    __publicField(this, "skipped_effects", /* @__PURE__ */ new Set());
  }
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(root_effects) {
    var _a3;
    queued_root_effects = [];
    previous_batch = null;
    this.apply();
    for (const root37 of root_effects) {
      __privateMethod(this, _Batch_instances, traverse_effect_tree_fn).call(this, root37);
    }
    if (__privateGet(this, _pending) === 0) {
      var previous_batch_sources = batch_values;
      __privateMethod(this, _Batch_instances, commit_fn).call(this);
      var render_effects = __privateGet(this, _render_effects);
      var effects = __privateGet(this, _effects);
      __privateSet(this, _render_effects, []);
      __privateSet(this, _effects, []);
      __privateSet(this, _block_effects, []);
      previous_batch = this;
      current_batch = null;
      batch_values = previous_batch_sources;
      flush_queued_effects(render_effects);
      flush_queued_effects(effects);
      previous_batch = null;
      (_a3 = __privateGet(this, _deferred)) == null ? void 0 : _a3.resolve();
    } else {
      __privateMethod(this, _Batch_instances, defer_effects_fn).call(this, __privateGet(this, _render_effects));
      __privateMethod(this, _Batch_instances, defer_effects_fn).call(this, __privateGet(this, _effects));
      __privateMethod(this, _Batch_instances, defer_effects_fn).call(this, __privateGet(this, _block_effects));
    }
    batch_values = null;
    for (const effect2 of __privateGet(this, _boundary_async_effects)) {
      update_effect(effect2);
    }
    __privateSet(this, _boundary_async_effects, []);
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(source2, value) {
    if (!__privateGet(this, _previous).has(source2)) {
      __privateGet(this, _previous).set(source2, value);
    }
    this.current.set(source2, source2.v);
    batch_values == null ? void 0 : batch_values.set(source2, source2.v);
  }
  activate() {
    current_batch = this;
  }
  deactivate() {
    current_batch = null;
    batch_values = null;
  }
  flush() {
    if (queued_root_effects.length > 0) {
      this.activate();
      flush_effects();
      if (current_batch !== null && current_batch !== this) {
        return;
      }
    } else if (__privateGet(this, _pending) === 0) {
      __privateMethod(this, _Batch_instances, commit_fn).call(this);
    }
    this.deactivate();
    for (const update2 of effect_pending_updates) {
      effect_pending_updates.delete(update2);
      update2();
      if (current_batch !== null) {
        break;
      }
    }
  }
  increment() {
    __privateSet(this, _pending, __privateGet(this, _pending) + 1);
  }
  decrement() {
    __privateSet(this, _pending, __privateGet(this, _pending) - 1);
    for (const e of __privateGet(this, _dirty_effects)) {
      set_signal_status(e, DIRTY);
      schedule_effect(e);
    }
    for (const e of __privateGet(this, _maybe_dirty_effects)) {
      set_signal_status(e, MAYBE_DIRTY);
      schedule_effect(e);
    }
    this.flush();
  }
  /** @param {() => void} fn */
  add_callback(fn) {
    __privateGet(this, _callbacks).add(fn);
  }
  settled() {
    var _a3;
    return ((_a3 = __privateGet(this, _deferred)) != null ? _a3 : __privateSet(this, _deferred, deferred())).promise;
  }
  static ensure() {
    if (current_batch === null) {
      const batch = current_batch = new _Batch();
      batches.add(current_batch);
      if (!is_flushing_sync) {
        _Batch.enqueue(() => {
          if (current_batch !== batch) {
            return;
          }
          batch.flush();
        });
      }
    }
    return current_batch;
  }
  /** @param {() => void} task */
  static enqueue(task) {
    queue_micro_task(task);
  }
  apply() {
    if (!async_mode_flag || batches.size === 1) return;
    batch_values = new Map(this.current);
    for (const batch of batches) {
      if (batch === this) continue;
      for (const [source2, previous] of __privateGet(batch, _previous)) {
        if (!batch_values.has(source2)) {
          batch_values.set(source2, previous);
        }
      }
    }
  }
};
_previous = new WeakMap();
_callbacks = new WeakMap();
_pending = new WeakMap();
_deferred = new WeakMap();
_boundary_async_effects = new WeakMap();
_render_effects = new WeakMap();
_effects = new WeakMap();
_block_effects = new WeakMap();
_dirty_effects = new WeakMap();
_maybe_dirty_effects = new WeakMap();
_Batch_instances = new WeakSet();
/**
 * Traverse the effect tree, executing effects or stashing
 * them for later execution as appropriate
 * @param {Effect} root
 */
traverse_effect_tree_fn = function(root37) {
  var _a3;
  root37.f ^= CLEAN;
  var effect2 = root37.first;
  while (effect2 !== null) {
    var flags2 = effect2.f;
    var is_branch = (flags2 & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0;
    var is_skippable_branch = is_branch && (flags2 & CLEAN) !== 0;
    var skip = is_skippable_branch || (flags2 & INERT) !== 0 || this.skipped_effects.has(effect2);
    if (!skip && effect2.fn !== null) {
      if (is_branch) {
        effect2.f ^= CLEAN;
      } else if ((flags2 & EFFECT) !== 0) {
        __privateGet(this, _effects).push(effect2);
      } else if (async_mode_flag && (flags2 & RENDER_EFFECT) !== 0) {
        __privateGet(this, _render_effects).push(effect2);
      } else if ((flags2 & CLEAN) === 0) {
        if ((flags2 & ASYNC) !== 0 && ((_a3 = effect2.b) == null ? void 0 : _a3.is_pending())) {
          __privateGet(this, _boundary_async_effects).push(effect2);
        } else if (is_dirty(effect2)) {
          if ((effect2.f & BLOCK_EFFECT) !== 0) __privateGet(this, _block_effects).push(effect2);
          update_effect(effect2);
        }
      }
      var child2 = effect2.first;
      if (child2 !== null) {
        effect2 = child2;
        continue;
      }
    }
    var parent = effect2.parent;
    effect2 = effect2.next;
    while (effect2 === null && parent !== null) {
      effect2 = parent.next;
      parent = parent.parent;
    }
  }
};
/**
 * @param {Effect[]} effects
 */
defer_effects_fn = function(effects) {
  for (const e of effects) {
    const target = (e.f & DIRTY) !== 0 ? __privateGet(this, _dirty_effects) : __privateGet(this, _maybe_dirty_effects);
    target.push(e);
    set_signal_status(e, CLEAN);
  }
  effects.length = 0;
};
/**
 * Append and remove branches to/from the DOM
 */
commit_fn = function() {
  var _a3;
  for (const fn of __privateGet(this, _callbacks)) {
    fn();
  }
  __privateGet(this, _callbacks).clear();
  if (batches.size > 1) {
    __privateGet(this, _previous).clear();
    let is_earlier = true;
    for (const batch of batches) {
      if (batch === this) {
        is_earlier = false;
        continue;
      }
      const sources = [];
      for (const [source2, value] of this.current) {
        if (batch.current.has(source2)) {
          if (is_earlier && value !== batch.current.get(source2)) {
            batch.current.set(source2, value);
          } else {
            continue;
          }
        }
        sources.push(source2);
      }
      if (sources.length === 0) {
        continue;
      }
      const others = [...batch.current.keys()].filter((s) => !this.current.has(s));
      if (others.length > 0) {
        for (const source2 of sources) {
          mark_effects(source2, others);
        }
        if (queued_root_effects.length > 0) {
          current_batch = batch;
          batch.apply();
          for (const root37 of queued_root_effects) {
            __privateMethod(_a3 = batch, _Batch_instances, traverse_effect_tree_fn).call(_a3, root37);
          }
          queued_root_effects = [];
          batch.deactivate();
        }
      }
    }
    current_batch = null;
  }
  batches.delete(this);
};
var Batch = _Batch;
function flushSync(fn) {
  if (async_mode_flag && active_effect !== null) {
    flush_sync_in_effect();
  }
  var was_flushing_sync = is_flushing_sync;
  is_flushing_sync = true;
  try {
    var result;
    if (fn) {
      if (current_batch !== null) {
        flush_effects();
      }
      result = fn();
    }
    while (true) {
      flush_tasks();
      if (queued_root_effects.length === 0) {
        current_batch == null ? void 0 : current_batch.flush();
        if (queued_root_effects.length === 0) {
          last_scheduled_effect = null;
          return (
            /** @type {T} */
            result
          );
        }
      }
      flush_effects();
    }
  } finally {
    is_flushing_sync = was_flushing_sync;
  }
}
function flush_effects() {
  var _a3;
  var was_updating_effect = is_updating_effect;
  is_flushing = true;
  try {
    var flush_count = 0;
    set_is_updating_effect(true);
    while (queued_root_effects.length > 0) {
      var batch = Batch.ensure();
      if (flush_count++ > 1e3) {
        if (dev_fallback_default) {
          var updates = /* @__PURE__ */ new Map();
          for (const source2 of batch.current.keys()) {
            for (const [stack2, update2] of (_a3 = source2.updated) != null ? _a3 : []) {
              var entry = updates.get(stack2);
              if (!entry) {
                entry = { error: update2.error, count: 0 };
                updates.set(stack2, entry);
              }
              entry.count += update2.count;
            }
          }
          for (const update2 of updates.values()) {
            console.error(update2.error);
          }
        }
        infinite_loop_guard();
      }
      batch.process(queued_root_effects);
      old_values.clear();
    }
  } finally {
    is_flushing = false;
    set_is_updating_effect(was_updating_effect);
    last_scheduled_effect = null;
  }
}
function infinite_loop_guard() {
  try {
    effect_update_depth_exceeded();
  } catch (error) {
    if (dev_fallback_default) {
      define_property(error, "stack", { value: "" });
    }
    invoke_error_boundary(error, last_scheduled_effect);
  }
}
var eager_block_effects = null;
function flush_queued_effects(effects) {
  var length = effects.length;
  if (length === 0) return;
  var i = 0;
  while (i < length) {
    var effect2 = effects[i++];
    if ((effect2.f & (DESTROYED | INERT)) === 0 && is_dirty(effect2)) {
      eager_block_effects = [];
      update_effect(effect2);
      if (effect2.deps === null && effect2.first === null && effect2.nodes_start === null) {
        if (effect2.teardown === null && effect2.ac === null) {
          unlink_effect(effect2);
        } else {
          effect2.fn = null;
        }
      }
      if ((eager_block_effects == null ? void 0 : eager_block_effects.length) > 0) {
        old_values.clear();
        for (const e of eager_block_effects) {
          update_effect(e);
        }
        eager_block_effects = [];
      }
    }
  }
  eager_block_effects = null;
}
function mark_effects(value, sources) {
  if (value.reactions !== null) {
    for (const reaction of value.reactions) {
      const flags2 = reaction.f;
      if ((flags2 & DERIVED) !== 0) {
        mark_effects(
          /** @type {Derived} */
          reaction,
          sources
        );
      } else if ((flags2 & (ASYNC | BLOCK_EFFECT)) !== 0 && depends_on(reaction, sources)) {
        set_signal_status(reaction, DIRTY);
        schedule_effect(
          /** @type {Effect} */
          reaction
        );
      }
    }
  }
}
function depends_on(reaction, sources) {
  if (reaction.deps !== null) {
    for (const dep of reaction.deps) {
      if (sources.includes(dep)) {
        return true;
      }
      if ((dep.f & DERIVED) !== 0 && depends_on(
        /** @type {Derived} */
        dep,
        sources
      )) {
        return true;
      }
    }
  }
  return false;
}
function schedule_effect(signal) {
  var effect2 = last_scheduled_effect = signal;
  while (effect2.parent !== null) {
    effect2 = effect2.parent;
    var flags2 = effect2.f;
    if (is_flushing && effect2 === active_effect && (flags2 & BLOCK_EFFECT) !== 0) {
      return;
    }
    if ((flags2 & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
      if ((flags2 & CLEAN) === 0) return;
      effect2.f ^= CLEAN;
    }
  }
  queued_root_effects.push(effect2);
}

// node_modules/svelte/src/reactivity/create-subscriber.js
function createSubscriber(start2) {
  let subscribers = 0;
  let version = source(0);
  let stop;
  if (dev_fallback_default) {
    tag(version, "createSubscriber version");
  }
  return () => {
    if (effect_tracking()) {
      get(version);
      render_effect(() => {
        if (subscribers === 0) {
          stop = untrack(() => start2(() => increment(version)));
        }
        subscribers += 1;
        return () => {
          queue_micro_task(() => {
            subscribers -= 1;
            if (subscribers === 0) {
              stop == null ? void 0 : stop();
              stop = void 0;
              increment(version);
            }
          });
        };
      });
    }
  };
}

// node_modules/svelte/src/internal/client/dom/blocks/boundary.js
var flags = EFFECT_TRANSPARENT | EFFECT_PRESERVED | BOUNDARY_EFFECT;
function boundary(node, props, children2) {
  new Boundary(node, props, children2);
}
var _pending2, _anchor, _hydrate_open, _props, _children, _effect, _main_effect, _pending_effect, _failed_effect, _offscreen_fragment, _local_pending_count, _pending_count, _is_creating_fallback, _effect_pending, _effect_pending_update, _effect_pending_subscriber, _Boundary_instances, hydrate_resolved_content_fn, hydrate_pending_content_fn, run_fn, show_pending_snippet_fn, update_pending_count_fn;
var Boundary = class {
  /**
   * @param {TemplateNode} node
   * @param {BoundaryProps} props
   * @param {((anchor: Node) => void)} children
   */
  constructor(node, props, children2) {
    __privateAdd(this, _Boundary_instances);
    /** @type {Boundary | null} */
    __publicField(this, "parent");
    __privateAdd(this, _pending2, false);
    /** @type {TemplateNode} */
    __privateAdd(this, _anchor);
    /** @type {TemplateNode | null} */
    __privateAdd(this, _hydrate_open, hydrating ? hydrate_node : null);
    /** @type {BoundaryProps} */
    __privateAdd(this, _props);
    /** @type {((anchor: Node) => void)} */
    __privateAdd(this, _children);
    /** @type {Effect} */
    __privateAdd(this, _effect);
    /** @type {Effect | null} */
    __privateAdd(this, _main_effect, null);
    /** @type {Effect | null} */
    __privateAdd(this, _pending_effect, null);
    /** @type {Effect | null} */
    __privateAdd(this, _failed_effect, null);
    /** @type {DocumentFragment | null} */
    __privateAdd(this, _offscreen_fragment, null);
    __privateAdd(this, _local_pending_count, 0);
    __privateAdd(this, _pending_count, 0);
    __privateAdd(this, _is_creating_fallback, false);
    /**
     * A source containing the number of pending async deriveds/expressions.
     * Only created if `$effect.pending()` is used inside the boundary,
     * otherwise updating the source results in needless `Batch.ensure()`
     * calls followed by no-op flushes
     * @type {Source<number> | null}
     */
    __privateAdd(this, _effect_pending, null);
    __privateAdd(this, _effect_pending_update, () => {
      if (__privateGet(this, _effect_pending)) {
        internal_set(__privateGet(this, _effect_pending), __privateGet(this, _local_pending_count));
      }
    });
    __privateAdd(this, _effect_pending_subscriber, createSubscriber(() => {
      __privateSet(this, _effect_pending, source(__privateGet(this, _local_pending_count)));
      if (dev_fallback_default) {
        tag(__privateGet(this, _effect_pending), "$effect.pending()");
      }
      return () => {
        __privateSet(this, _effect_pending, null);
      };
    }));
    __privateSet(this, _anchor, node);
    __privateSet(this, _props, props);
    __privateSet(this, _children, children2);
    this.parent = /** @type {Effect} */
    active_effect.b;
    __privateSet(this, _pending2, !!__privateGet(this, _props).pending);
    __privateSet(this, _effect, block(() => {
      active_effect.b = this;
      if (hydrating) {
        const comment2 = __privateGet(this, _hydrate_open);
        hydrate_next();
        const server_rendered_pending = (
          /** @type {Comment} */
          comment2.nodeType === COMMENT_NODE && /** @type {Comment} */
          comment2.data === HYDRATION_START_ELSE
        );
        if (server_rendered_pending) {
          __privateMethod(this, _Boundary_instances, hydrate_pending_content_fn).call(this);
        } else {
          __privateMethod(this, _Boundary_instances, hydrate_resolved_content_fn).call(this);
        }
      } else {
        try {
          __privateSet(this, _main_effect, branch(() => children2(__privateGet(this, _anchor))));
        } catch (error) {
          this.error(error);
        }
        if (__privateGet(this, _pending_count) > 0) {
          __privateMethod(this, _Boundary_instances, show_pending_snippet_fn).call(this);
        } else {
          __privateSet(this, _pending2, false);
        }
      }
    }, flags));
    if (hydrating) {
      __privateSet(this, _anchor, hydrate_node);
    }
  }
  /**
   * Returns `true` if the effect exists inside a boundary whose pending snippet is shown
   * @returns {boolean}
   */
  is_pending() {
    return __privateGet(this, _pending2) || !!this.parent && this.parent.is_pending();
  }
  has_pending_snippet() {
    return !!__privateGet(this, _props).pending;
  }
  /**
   * Update the source that powers `$effect.pending()` inside this boundary,
   * and controls when the current `pending` snippet (if any) is removed.
   * Do not call from inside the class
   * @param {1 | -1} d
   */
  update_pending_count(d) {
    __privateMethod(this, _Boundary_instances, update_pending_count_fn).call(this, d);
    __privateSet(this, _local_pending_count, __privateGet(this, _local_pending_count) + d);
    effect_pending_updates.add(__privateGet(this, _effect_pending_update));
  }
  get_effect_pending() {
    __privateGet(this, _effect_pending_subscriber).call(this);
    return get(
      /** @type {Source<number>} */
      __privateGet(this, _effect_pending)
    );
  }
  /** @param {unknown} error */
  error(error) {
    var onerror = __privateGet(this, _props).onerror;
    let failed = __privateGet(this, _props).failed;
    if (__privateGet(this, _is_creating_fallback) || !onerror && !failed) {
      throw error;
    }
    if (__privateGet(this, _main_effect)) {
      destroy_effect(__privateGet(this, _main_effect));
      __privateSet(this, _main_effect, null);
    }
    if (__privateGet(this, _pending_effect)) {
      destroy_effect(__privateGet(this, _pending_effect));
      __privateSet(this, _pending_effect, null);
    }
    if (__privateGet(this, _failed_effect)) {
      destroy_effect(__privateGet(this, _failed_effect));
      __privateSet(this, _failed_effect, null);
    }
    if (hydrating) {
      set_hydrate_node(
        /** @type {TemplateNode} */
        __privateGet(this, _hydrate_open)
      );
      next();
      set_hydrate_node(skip_nodes());
    }
    var did_reset = false;
    var calling_on_error = false;
    const reset2 = () => {
      if (did_reset) {
        svelte_boundary_reset_noop();
        return;
      }
      did_reset = true;
      if (calling_on_error) {
        svelte_boundary_reset_onerror();
      }
      Batch.ensure();
      __privateSet(this, _local_pending_count, 0);
      if (__privateGet(this, _failed_effect) !== null) {
        pause_effect(__privateGet(this, _failed_effect), () => {
          __privateSet(this, _failed_effect, null);
        });
      }
      __privateSet(this, _pending2, this.has_pending_snippet());
      __privateSet(this, _main_effect, __privateMethod(this, _Boundary_instances, run_fn).call(this, () => {
        __privateSet(this, _is_creating_fallback, false);
        return branch(() => __privateGet(this, _children).call(this, __privateGet(this, _anchor)));
      }));
      if (__privateGet(this, _pending_count) > 0) {
        __privateMethod(this, _Boundary_instances, show_pending_snippet_fn).call(this);
      } else {
        __privateSet(this, _pending2, false);
      }
    };
    var previous_reaction = active_reaction;
    try {
      set_active_reaction(null);
      calling_on_error = true;
      onerror == null ? void 0 : onerror(error, reset2);
      calling_on_error = false;
    } catch (error2) {
      invoke_error_boundary(error2, __privateGet(this, _effect) && __privateGet(this, _effect).parent);
    } finally {
      set_active_reaction(previous_reaction);
    }
    if (failed) {
      queue_micro_task(() => {
        __privateSet(this, _failed_effect, __privateMethod(this, _Boundary_instances, run_fn).call(this, () => {
          __privateSet(this, _is_creating_fallback, true);
          try {
            return branch(() => {
              failed(
                __privateGet(this, _anchor),
                () => error,
                () => reset2
              );
            });
          } catch (error2) {
            invoke_error_boundary(
              error2,
              /** @type {Effect} */
              __privateGet(this, _effect).parent
            );
            return null;
          } finally {
            __privateSet(this, _is_creating_fallback, false);
          }
        }));
      });
    }
  }
};
_pending2 = new WeakMap();
_anchor = new WeakMap();
_hydrate_open = new WeakMap();
_props = new WeakMap();
_children = new WeakMap();
_effect = new WeakMap();
_main_effect = new WeakMap();
_pending_effect = new WeakMap();
_failed_effect = new WeakMap();
_offscreen_fragment = new WeakMap();
_local_pending_count = new WeakMap();
_pending_count = new WeakMap();
_is_creating_fallback = new WeakMap();
_effect_pending = new WeakMap();
_effect_pending_update = new WeakMap();
_effect_pending_subscriber = new WeakMap();
_Boundary_instances = new WeakSet();
hydrate_resolved_content_fn = function() {
  try {
    __privateSet(this, _main_effect, branch(() => __privateGet(this, _children).call(this, __privateGet(this, _anchor))));
  } catch (error) {
    this.error(error);
  }
  __privateSet(this, _pending2, false);
};
hydrate_pending_content_fn = function() {
  const pending2 = __privateGet(this, _props).pending;
  if (!pending2) {
    return;
  }
  __privateSet(this, _pending_effect, branch(() => pending2(__privateGet(this, _anchor))));
  Batch.enqueue(() => {
    __privateSet(this, _main_effect, __privateMethod(this, _Boundary_instances, run_fn).call(this, () => {
      Batch.ensure();
      return branch(() => __privateGet(this, _children).call(this, __privateGet(this, _anchor)));
    }));
    if (__privateGet(this, _pending_count) > 0) {
      __privateMethod(this, _Boundary_instances, show_pending_snippet_fn).call(this);
    } else {
      pause_effect(
        /** @type {Effect} */
        __privateGet(this, _pending_effect),
        () => {
          __privateSet(this, _pending_effect, null);
        }
      );
      __privateSet(this, _pending2, false);
    }
  });
};
/**
 * @param {() => Effect | null} fn
 */
run_fn = function(fn) {
  var previous_effect = active_effect;
  var previous_reaction = active_reaction;
  var previous_ctx = component_context;
  set_active_effect(__privateGet(this, _effect));
  set_active_reaction(__privateGet(this, _effect));
  set_component_context(__privateGet(this, _effect).ctx);
  try {
    return fn();
  } catch (e) {
    handle_error(e);
    return null;
  } finally {
    set_active_effect(previous_effect);
    set_active_reaction(previous_reaction);
    set_component_context(previous_ctx);
  }
};
show_pending_snippet_fn = function() {
  const pending2 = (
    /** @type {(anchor: Node) => void} */
    __privateGet(this, _props).pending
  );
  if (__privateGet(this, _main_effect) !== null) {
    __privateSet(this, _offscreen_fragment, document.createDocumentFragment());
    move_effect(__privateGet(this, _main_effect), __privateGet(this, _offscreen_fragment));
  }
  if (__privateGet(this, _pending_effect) === null) {
    __privateSet(this, _pending_effect, branch(() => pending2(__privateGet(this, _anchor))));
  }
};
/**
 * Updates the pending count associated with the currently visible pending snippet,
 * if any, such that we can replace the snippet with content once work is done
 * @param {1 | -1} d
 */
update_pending_count_fn = function(d) {
  var _a3;
  if (!this.has_pending_snippet()) {
    if (this.parent) {
      __privateMethod(_a3 = this.parent, _Boundary_instances, update_pending_count_fn).call(_a3, d);
    }
    return;
  }
  __privateSet(this, _pending_count, __privateGet(this, _pending_count) + d);
  if (__privateGet(this, _pending_count) === 0) {
    __privateSet(this, _pending2, false);
    if (__privateGet(this, _pending_effect)) {
      pause_effect(__privateGet(this, _pending_effect), () => {
        __privateSet(this, _pending_effect, null);
      });
    }
    if (__privateGet(this, _offscreen_fragment)) {
      __privateGet(this, _anchor).before(__privateGet(this, _offscreen_fragment));
      __privateSet(this, _offscreen_fragment, null);
    }
    queue_micro_task(() => {
      Batch.ensure().flush();
    });
  }
};
function move_effect(effect2, fragment) {
  var node = effect2.nodes_start;
  var end = effect2.nodes_end;
  while (node !== null) {
    var next2 = node === end ? null : (
      /** @type {TemplateNode} */
      get_next_sibling(node)
    );
    fragment.append(node);
    node = next2;
  }
}

// node_modules/svelte/src/internal/client/reactivity/async.js
function flatten(sync, async2, fn) {
  const d = is_runes() ? derived : derived_safe_equal;
  if (async2.length === 0) {
    fn(sync.map(d));
    return;
  }
  var batch = current_batch;
  var parent = (
    /** @type {Effect} */
    active_effect
  );
  var restore = capture();
  var was_hydrating = hydrating;
  Promise.all(async2.map((expression) => async_derived(expression))).then((result) => {
    restore();
    try {
      fn([...sync.map(d), ...result]);
    } catch (error) {
      if ((parent.f & DESTROYED) === 0) {
        invoke_error_boundary(error, parent);
      }
    }
    if (was_hydrating) {
      set_hydrating(false);
    }
    batch == null ? void 0 : batch.deactivate();
    unset_context();
  }).catch((error) => {
    invoke_error_boundary(error, parent);
  });
}
function capture() {
  var previous_effect = active_effect;
  var previous_reaction = active_reaction;
  var previous_component_context = component_context;
  var previous_batch2 = current_batch;
  var was_hydrating = hydrating;
  if (was_hydrating) {
    var previous_hydrate_node = hydrate_node;
  }
  return function restore() {
    set_active_effect(previous_effect);
    set_active_reaction(previous_reaction);
    set_component_context(previous_component_context);
    previous_batch2 == null ? void 0 : previous_batch2.activate();
    if (was_hydrating) {
      set_hydrating(true);
      set_hydrate_node(previous_hydrate_node);
    }
    if (dev_fallback_default) {
      set_from_async_derived(null);
    }
  };
}
function unset_context() {
  set_active_effect(null);
  set_active_reaction(null);
  set_component_context(null);
  if (dev_fallback_default) set_from_async_derived(null);
}

// node_modules/svelte/src/internal/client/reactivity/deriveds.js
var current_async_effect = null;
function set_from_async_derived(v) {
  current_async_effect = v;
}
var recent_async_deriveds = /* @__PURE__ */ new Set();
// @__NO_SIDE_EFFECTS__
function derived(fn) {
  var flags2 = DERIVED | DIRTY;
  var parent_derived = active_reaction !== null && (active_reaction.f & DERIVED) !== 0 ? (
    /** @type {Derived} */
    active_reaction
  ) : null;
  if (active_effect === null || parent_derived !== null && (parent_derived.f & UNOWNED) !== 0) {
    flags2 |= UNOWNED;
  } else {
    active_effect.f |= EFFECT_PRESERVED;
  }
  const signal = {
    ctx: component_context,
    deps: null,
    effects: null,
    equals,
    f: flags2,
    fn,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      UNINITIALIZED
    ),
    wv: 0,
    parent: parent_derived != null ? parent_derived : active_effect,
    ac: null
  };
  if (dev_fallback_default && tracing_mode_flag) {
    signal.created = get_stack("CreatedAt");
  }
  return signal;
}
// @__NO_SIDE_EFFECTS__
function async_derived(fn, location) {
  let parent = (
    /** @type {Effect | null} */
    active_effect
  );
  if (parent === null) {
    async_derived_orphan();
  }
  var boundary2 = (
    /** @type {Boundary} */
    parent.b
  );
  var promise = (
    /** @type {Promise<V>} */
    /** @type {unknown} */
    void 0
  );
  var signal = source(
    /** @type {V} */
    UNINITIALIZED
  );
  var should_suspend = !active_reaction;
  var deferreds = /* @__PURE__ */ new Map();
  async_effect(() => {
    var _a3;
    if (dev_fallback_default) current_async_effect = active_effect;
    var d = deferred();
    promise = d.promise;
    try {
      Promise.resolve(fn()).then(d.resolve, d.reject).then(unset_context);
    } catch (error) {
      d.reject(error);
      unset_context();
    }
    if (dev_fallback_default) current_async_effect = null;
    var batch = (
      /** @type {Batch} */
      current_batch
    );
    var pending2 = boundary2.is_pending();
    if (should_suspend) {
      boundary2.update_pending_count(1);
      if (!pending2) {
        batch.increment();
        (_a3 = deferreds.get(batch)) == null ? void 0 : _a3.reject(STALE_REACTION);
        deferreds.delete(batch);
        deferreds.set(batch, d);
      }
    }
    const handler = (value, error = void 0) => {
      current_async_effect = null;
      if (!pending2) batch.activate();
      if (error) {
        if (error !== STALE_REACTION) {
          signal.f |= ERROR_VALUE;
          internal_set(signal, error);
        }
      } else {
        if ((signal.f & ERROR_VALUE) !== 0) {
          signal.f ^= ERROR_VALUE;
        }
        internal_set(signal, value);
        for (const [b, d2] of deferreds) {
          deferreds.delete(b);
          if (b === batch) break;
          d2.reject(STALE_REACTION);
        }
        if (dev_fallback_default && location !== void 0) {
          recent_async_deriveds.add(signal);
          setTimeout(() => {
            if (recent_async_deriveds.has(signal)) {
              await_waterfall(
                /** @type {string} */
                signal.label,
                location
              );
              recent_async_deriveds.delete(signal);
            }
          });
        }
      }
      if (should_suspend) {
        boundary2.update_pending_count(-1);
        if (!pending2) batch.decrement();
      }
    };
    d.promise.then(handler, (e) => handler(null, e || "unknown"));
  });
  teardown(() => {
    for (const d of deferreds.values()) {
      d.reject(STALE_REACTION);
    }
  });
  if (dev_fallback_default) {
    signal.f |= ASYNC;
  }
  return new Promise((fulfil) => {
    function next2(p) {
      function go() {
        if (p === promise) {
          fulfil(signal);
        } else {
          next2(promise);
        }
      }
      p.then(go, go);
    }
    next2(promise);
  });
}
// @__NO_SIDE_EFFECTS__
function user_derived(fn) {
  const d = /* @__PURE__ */ derived(fn);
  if (!async_mode_flag) push_reaction_value(d);
  return d;
}
// @__NO_SIDE_EFFECTS__
function derived_safe_equal(fn) {
  const signal = /* @__PURE__ */ derived(fn);
  signal.equals = safe_equals;
  return signal;
}
function destroy_derived_effects(derived2) {
  var effects = derived2.effects;
  if (effects !== null) {
    derived2.effects = null;
    for (var i = 0; i < effects.length; i += 1) {
      destroy_effect(
        /** @type {Effect} */
        effects[i]
      );
    }
  }
}
var stack = [];
function get_derived_parent_effect(derived2) {
  var parent = derived2.parent;
  while (parent !== null) {
    if ((parent.f & DERIVED) === 0) {
      return (
        /** @type {Effect} */
        parent
      );
    }
    parent = parent.parent;
  }
  return null;
}
function execute_derived(derived2) {
  var value;
  var prev_active_effect = active_effect;
  set_active_effect(get_derived_parent_effect(derived2));
  if (dev_fallback_default) {
    let prev_inspect_effects = inspect_effects;
    set_inspect_effects(/* @__PURE__ */ new Set());
    try {
      if (stack.includes(derived2)) {
        derived_references_self();
      }
      stack.push(derived2);
      destroy_derived_effects(derived2);
      value = update_reaction(derived2);
    } finally {
      set_active_effect(prev_active_effect);
      set_inspect_effects(prev_inspect_effects);
      stack.pop();
    }
  } else {
    try {
      destroy_derived_effects(derived2);
      value = update_reaction(derived2);
    } finally {
      set_active_effect(prev_active_effect);
    }
  }
  return value;
}
function update_derived(derived2) {
  var value = execute_derived(derived2);
  if (!derived2.equals(value)) {
    derived2.v = value;
    derived2.wv = increment_write_version();
  }
  if (is_destroying_effect) {
    return;
  }
  if (batch_values !== null) {
    batch_values.set(derived2, derived2.v);
  } else {
    var status = (skip_reaction || (derived2.f & UNOWNED) !== 0) && derived2.deps !== null ? MAYBE_DIRTY : CLEAN;
    set_signal_status(derived2, status);
  }
}

// node_modules/svelte/src/internal/client/reactivity/sources.js
var inspect_effects = /* @__PURE__ */ new Set();
var old_values = /* @__PURE__ */ new Map();
function set_inspect_effects(v) {
  inspect_effects = v;
}
var inspect_effects_deferred = false;
function set_inspect_effects_deferred() {
  inspect_effects_deferred = true;
}
function source(v, stack2) {
  var signal = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v,
    reactions: null,
    equals,
    rv: 0,
    wv: 0
  };
  if (dev_fallback_default && tracing_mode_flag) {
    signal.created = stack2 != null ? stack2 : get_stack("CreatedAt");
    signal.updated = null;
    signal.set_during_effect = false;
    signal.trace = null;
  }
  return signal;
}
// @__NO_SIDE_EFFECTS__
function state(v, stack2) {
  const s = source(v, stack2);
  push_reaction_value(s);
  return s;
}
// @__NO_SIDE_EFFECTS__
function mutable_source(initial_value, immutable = false, trackable = true) {
  var _a3, _b3;
  const s = source(initial_value);
  if (!immutable) {
    s.equals = safe_equals;
  }
  if (legacy_mode_flag && trackable && component_context !== null && component_context.l !== null) {
    ((_b3 = (_a3 = component_context.l).s) != null ? _b3 : _a3.s = []).push(s);
  }
  return s;
}
function set(source2, value, should_proxy = false) {
  var _a3;
  if (active_reaction !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!untracking || (active_reaction.f & INSPECT_EFFECT) !== 0) && is_runes() && (active_reaction.f & (DERIVED | BLOCK_EFFECT | ASYNC | INSPECT_EFFECT)) !== 0 && !((_a3 = current_sources) == null ? void 0 : _a3.includes(source2))) {
    state_unsafe_mutation();
  }
  let new_value = should_proxy ? proxy(value) : value;
  if (dev_fallback_default) {
    tag_proxy(
      new_value,
      /** @type {string} */
      source2.label
    );
  }
  return internal_set(source2, new_value);
}
function internal_set(source2, value) {
  var _a3;
  if (!source2.equals(value)) {
    var old_value = source2.v;
    if (is_destroying_effect) {
      old_values.set(source2, value);
    } else {
      old_values.set(source2, old_value);
    }
    source2.v = value;
    var batch = Batch.ensure();
    batch.capture(source2, old_value);
    if (dev_fallback_default) {
      if (tracing_mode_flag || active_effect !== null) {
        const error = get_stack("UpdatedAt");
        if (error !== null) {
          (_a3 = source2.updated) != null ? _a3 : source2.updated = /* @__PURE__ */ new Map();
          let entry = source2.updated.get(error.stack);
          if (!entry) {
            entry = { error, count: 0 };
            source2.updated.set(error.stack, entry);
          }
          entry.count++;
        }
      }
      if (active_effect !== null) {
        source2.set_during_effect = true;
      }
    }
    if ((source2.f & DERIVED) !== 0) {
      if ((source2.f & DIRTY) !== 0) {
        execute_derived(
          /** @type {Derived} */
          source2
        );
      }
      set_signal_status(source2, (source2.f & UNOWNED) === 0 ? CLEAN : MAYBE_DIRTY);
    }
    source2.wv = increment_write_version();
    mark_reactions(source2, DIRTY);
    if (is_runes() && active_effect !== null && (active_effect.f & CLEAN) !== 0 && (active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {
      if (untracked_writes === null) {
        set_untracked_writes([source2]);
      } else {
        untracked_writes.push(source2);
      }
    }
    if (dev_fallback_default && inspect_effects.size > 0 && !inspect_effects_deferred) {
      flush_inspect_effects();
    }
  }
  return value;
}
function flush_inspect_effects() {
  inspect_effects_deferred = false;
  const inspects = Array.from(inspect_effects);
  for (const effect2 of inspects) {
    if ((effect2.f & CLEAN) !== 0) {
      set_signal_status(effect2, MAYBE_DIRTY);
    }
    if (is_dirty(effect2)) {
      update_effect(effect2);
    }
  }
  inspect_effects.clear();
}
function update(source2, d = 1) {
  var value = get(source2);
  var result = d === 1 ? value++ : value--;
  set(source2, value);
  return result;
}
function increment(source2) {
  set(source2, source2.v + 1);
}
function mark_reactions(signal, status) {
  var reactions = signal.reactions;
  if (reactions === null) return;
  var runes = is_runes();
  var length = reactions.length;
  for (var i = 0; i < length; i++) {
    var reaction = reactions[i];
    var flags2 = reaction.f;
    if (!runes && reaction === active_effect) continue;
    if (dev_fallback_default && (flags2 & INSPECT_EFFECT) !== 0) {
      inspect_effects.add(reaction);
      continue;
    }
    var not_dirty = (flags2 & DIRTY) === 0;
    if (not_dirty) {
      set_signal_status(reaction, status);
    }
    if ((flags2 & DERIVED) !== 0) {
      mark_reactions(
        /** @type {Derived} */
        reaction,
        MAYBE_DIRTY
      );
    } else if (not_dirty) {
      if ((flags2 & BLOCK_EFFECT) !== 0) {
        if (eager_block_effects !== null) {
          eager_block_effects.push(
            /** @type {Effect} */
            reaction
          );
        }
      }
      schedule_effect(
        /** @type {Effect} */
        reaction
      );
    }
  }
}

// node_modules/svelte/src/internal/client/proxy.js
var regex_is_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
function proxy(value) {
  if (typeof value !== "object" || value === null || STATE_SYMBOL in value) {
    return value;
  }
  const prototype = get_prototype_of(value);
  if (prototype !== object_prototype && prototype !== array_prototype) {
    return value;
  }
  var sources = /* @__PURE__ */ new Map();
  var is_proxied_array = is_array(value);
  var version = state(0);
  var stack2 = dev_fallback_default && tracing_mode_flag ? get_stack("CreatedAt") : null;
  var parent_version = update_version;
  var with_parent = (fn) => {
    if (update_version === parent_version) {
      return fn();
    }
    var reaction = active_reaction;
    var version2 = update_version;
    set_active_reaction(null);
    set_update_version(parent_version);
    var result = fn();
    set_active_reaction(reaction);
    set_update_version(version2);
    return result;
  };
  if (is_proxied_array) {
    sources.set("length", state(
      /** @type {any[]} */
      value.length,
      stack2
    ));
    if (dev_fallback_default) {
      value = /** @type {any} */
      inspectable_array(
        /** @type {any[]} */
        value
      );
    }
  }
  var path = "";
  let updating = false;
  function update_path(new_path) {
    if (updating) return;
    updating = true;
    path = new_path;
    tag(version, `${path} version`);
    for (const [prop2, source2] of sources) {
      tag(source2, get_label(path, prop2));
    }
    updating = false;
  }
  return new Proxy(
    /** @type {any} */
    value,
    {
      defineProperty(_, prop2, descriptor) {
        if (!("value" in descriptor) || descriptor.configurable === false || descriptor.enumerable === false || descriptor.writable === false) {
          state_descriptors_fixed();
        }
        var s = sources.get(prop2);
        if (s === void 0) {
          s = with_parent(() => {
            var s2 = state(descriptor.value, stack2);
            sources.set(prop2, s2);
            if (dev_fallback_default && typeof prop2 === "string") {
              tag(s2, get_label(path, prop2));
            }
            return s2;
          });
        } else {
          set(s, descriptor.value, true);
        }
        return true;
      },
      deleteProperty(target, prop2) {
        var s = sources.get(prop2);
        if (s === void 0) {
          if (prop2 in target) {
            const s2 = with_parent(() => state(UNINITIALIZED, stack2));
            sources.set(prop2, s2);
            increment(version);
            if (dev_fallback_default) {
              tag(s2, get_label(path, prop2));
            }
          }
        } else {
          set(s, UNINITIALIZED);
          increment(version);
        }
        return true;
      },
      get(target, prop2, receiver) {
        var _a3;
        if (prop2 === STATE_SYMBOL) {
          return value;
        }
        if (dev_fallback_default && prop2 === PROXY_PATH_SYMBOL) {
          return update_path;
        }
        var s = sources.get(prop2);
        var exists = prop2 in target;
        if (s === void 0 && (!exists || ((_a3 = get_descriptor(target, prop2)) == null ? void 0 : _a3.writable))) {
          s = with_parent(() => {
            var p = proxy(exists ? target[prop2] : UNINITIALIZED);
            var s2 = state(p, stack2);
            if (dev_fallback_default) {
              tag(s2, get_label(path, prop2));
            }
            return s2;
          });
          sources.set(prop2, s);
        }
        if (s !== void 0) {
          var v = get(s);
          return v === UNINITIALIZED ? void 0 : v;
        }
        return Reflect.get(target, prop2, receiver);
      },
      getOwnPropertyDescriptor(target, prop2) {
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
        if (descriptor && "value" in descriptor) {
          var s = sources.get(prop2);
          if (s) descriptor.value = get(s);
        } else if (descriptor === void 0) {
          var source2 = sources.get(prop2);
          var value2 = source2 == null ? void 0 : source2.v;
          if (source2 !== void 0 && value2 !== UNINITIALIZED) {
            return {
              enumerable: true,
              configurable: true,
              value: value2,
              writable: true
            };
          }
        }
        return descriptor;
      },
      has(target, prop2) {
        var _a3;
        if (prop2 === STATE_SYMBOL) {
          return true;
        }
        var s = sources.get(prop2);
        var has = s !== void 0 && s.v !== UNINITIALIZED || Reflect.has(target, prop2);
        if (s !== void 0 || active_effect !== null && (!has || ((_a3 = get_descriptor(target, prop2)) == null ? void 0 : _a3.writable))) {
          if (s === void 0) {
            s = with_parent(() => {
              var p = has ? proxy(target[prop2]) : UNINITIALIZED;
              var s2 = state(p, stack2);
              if (dev_fallback_default) {
                tag(s2, get_label(path, prop2));
              }
              return s2;
            });
            sources.set(prop2, s);
          }
          var value2 = get(s);
          if (value2 === UNINITIALIZED) {
            return false;
          }
        }
        return has;
      },
      set(target, prop2, value2, receiver) {
        var _a3;
        var s = sources.get(prop2);
        var has = prop2 in target;
        if (is_proxied_array && prop2 === "length") {
          for (var i = value2; i < /** @type {Source<number>} */
          s.v; i += 1) {
            var other_s = sources.get(i + "");
            if (other_s !== void 0) {
              set(other_s, UNINITIALIZED);
            } else if (i in target) {
              other_s = with_parent(() => state(UNINITIALIZED, stack2));
              sources.set(i + "", other_s);
              if (dev_fallback_default) {
                tag(other_s, get_label(path, i));
              }
            }
          }
        }
        if (s === void 0) {
          if (!has || ((_a3 = get_descriptor(target, prop2)) == null ? void 0 : _a3.writable)) {
            s = with_parent(() => state(void 0, stack2));
            if (dev_fallback_default) {
              tag(s, get_label(path, prop2));
            }
            set(s, proxy(value2));
            sources.set(prop2, s);
          }
        } else {
          has = s.v !== UNINITIALIZED;
          var p = with_parent(() => proxy(value2));
          set(s, p);
        }
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
        if (descriptor == null ? void 0 : descriptor.set) {
          descriptor.set.call(receiver, value2);
        }
        if (!has) {
          if (is_proxied_array && typeof prop2 === "string") {
            var ls = (
              /** @type {Source<number>} */
              sources.get("length")
            );
            var n = Number(prop2);
            if (Number.isInteger(n) && n >= ls.v) {
              set(ls, n + 1);
            }
          }
          increment(version);
        }
        return true;
      },
      ownKeys(target) {
        get(version);
        var own_keys = Reflect.ownKeys(target).filter((key4) => {
          var source3 = sources.get(key4);
          return source3 === void 0 || source3.v !== UNINITIALIZED;
        });
        for (var [key3, source2] of sources) {
          if (source2.v !== UNINITIALIZED && !(key3 in target)) {
            own_keys.push(key3);
          }
        }
        return own_keys;
      },
      setPrototypeOf() {
        state_prototype_fixed();
      }
    }
  );
}
function get_label(path, prop2) {
  var _a3;
  if (typeof prop2 === "symbol") return `${path}[Symbol(${(_a3 = prop2.description) != null ? _a3 : ""})]`;
  if (regex_is_valid_identifier.test(prop2)) return `${path}.${prop2}`;
  return /^\d+$/.test(prop2) ? `${path}[${prop2}]` : `${path}['${prop2}']`;
}
function get_proxied_value(value) {
  try {
    if (value !== null && typeof value === "object" && STATE_SYMBOL in value) {
      return value[STATE_SYMBOL];
    }
  } catch (e) {
  }
  return value;
}
function is(a, b) {
  return Object.is(get_proxied_value(a), get_proxied_value(b));
}
var ARRAY_MUTATING_METHODS = /* @__PURE__ */ new Set([
  "copyWithin",
  "fill",
  "pop",
  "push",
  "reverse",
  "shift",
  "sort",
  "splice",
  "unshift"
]);
function inspectable_array(array2) {
  return new Proxy(array2, {
    get(target, prop2, receiver) {
      var value = Reflect.get(target, prop2, receiver);
      if (!ARRAY_MUTATING_METHODS.has(
        /** @type {string} */
        prop2
      )) {
        return value;
      }
      return function(...args) {
        set_inspect_effects_deferred();
        var result = value.apply(this, args);
        flush_inspect_effects();
        return result;
      };
    }
  });
}

// node_modules/svelte/src/internal/client/dev/equality.js
function init_array_prototype_warnings() {
  const array_prototype2 = Array.prototype;
  const cleanup = Array.__svelte_cleanup;
  if (cleanup) {
    cleanup();
  }
  const { indexOf, lastIndexOf, includes } = array_prototype2;
  array_prototype2.indexOf = function(item, from_index) {
    const index2 = indexOf.call(this, item, from_index);
    if (index2 === -1) {
      for (let i = from_index != null ? from_index : 0; i < this.length; i += 1) {
        if (get_proxied_value(this[i]) === item) {
          state_proxy_equality_mismatch("array.indexOf(...)");
          break;
        }
      }
    }
    return index2;
  };
  array_prototype2.lastIndexOf = function(item, from_index) {
    const index2 = lastIndexOf.call(this, item, from_index != null ? from_index : this.length - 1);
    if (index2 === -1) {
      for (let i = 0; i <= (from_index != null ? from_index : this.length - 1); i += 1) {
        if (get_proxied_value(this[i]) === item) {
          state_proxy_equality_mismatch("array.lastIndexOf(...)");
          break;
        }
      }
    }
    return index2;
  };
  array_prototype2.includes = function(item, from_index) {
    const has = includes.call(this, item, from_index);
    if (!has) {
      for (let i = 0; i < this.length; i += 1) {
        if (get_proxied_value(this[i]) === item) {
          state_proxy_equality_mismatch("array.includes(...)");
          break;
        }
      }
    }
    return has;
  };
  Array.__svelte_cleanup = () => {
    array_prototype2.indexOf = indexOf;
    array_prototype2.lastIndexOf = lastIndexOf;
    array_prototype2.includes = includes;
  };
}

// node_modules/svelte/src/internal/client/dom/operations.js
var $window;
var $document;
var is_firefox;
var first_child_getter;
var next_sibling_getter;
function init_operations() {
  if ($window !== void 0) {
    return;
  }
  $window = window;
  $document = document;
  is_firefox = /Firefox/.test(navigator.userAgent);
  var element_prototype = Element.prototype;
  var node_prototype = Node.prototype;
  var text_prototype = Text.prototype;
  first_child_getter = get_descriptor(node_prototype, "firstChild").get;
  next_sibling_getter = get_descriptor(node_prototype, "nextSibling").get;
  if (is_extensible(element_prototype)) {
    element_prototype.__click = void 0;
    element_prototype.__className = void 0;
    element_prototype.__attributes = null;
    element_prototype.__style = void 0;
    element_prototype.__e = void 0;
  }
  if (is_extensible(text_prototype)) {
    text_prototype.__t = void 0;
  }
  if (dev_fallback_default) {
    element_prototype.__svelte_meta = null;
    init_array_prototype_warnings();
  }
}
function create_text(value = "") {
  return document.createTextNode(value);
}
// @__NO_SIDE_EFFECTS__
function get_first_child(node) {
  return first_child_getter.call(node);
}
// @__NO_SIDE_EFFECTS__
function get_next_sibling(node) {
  return next_sibling_getter.call(node);
}
function child(node, is_text) {
  if (!hydrating) {
    return /* @__PURE__ */ get_first_child(node);
  }
  var child2 = (
    /** @type {TemplateNode} */
    /* @__PURE__ */ get_first_child(hydrate_node)
  );
  if (child2 === null) {
    child2 = hydrate_node.appendChild(create_text());
  } else if (is_text && child2.nodeType !== TEXT_NODE) {
    var text2 = create_text();
    child2 == null ? void 0 : child2.before(text2);
    set_hydrate_node(text2);
    return text2;
  }
  set_hydrate_node(child2);
  return child2;
}
function first_child(fragment, is_text = false) {
  var _a3, _b3;
  if (!hydrating) {
    var first = (
      /** @type {DocumentFragment} */
      /* @__PURE__ */ get_first_child(
        /** @type {Node} */
        fragment
      )
    );
    if (first instanceof Comment && first.data === "") return /* @__PURE__ */ get_next_sibling(first);
    return first;
  }
  if (is_text && ((_a3 = hydrate_node) == null ? void 0 : _a3.nodeType) !== TEXT_NODE) {
    var text2 = create_text();
    (_b3 = hydrate_node) == null ? void 0 : _b3.before(text2);
    set_hydrate_node(text2);
    return text2;
  }
  return hydrate_node;
}
function sibling(node, count = 1, is_text = false) {
  let next_sibling = hydrating ? hydrate_node : node;
  var last_sibling;
  while (count--) {
    last_sibling = next_sibling;
    next_sibling = /** @type {TemplateNode} */
    /* @__PURE__ */ get_next_sibling(next_sibling);
  }
  if (!hydrating) {
    return next_sibling;
  }
  if (is_text && (next_sibling == null ? void 0 : next_sibling.nodeType) !== TEXT_NODE) {
    var text2 = create_text();
    if (next_sibling === null) {
      last_sibling == null ? void 0 : last_sibling.after(text2);
    } else {
      next_sibling.before(text2);
    }
    set_hydrate_node(text2);
    return text2;
  }
  set_hydrate_node(next_sibling);
  return (
    /** @type {TemplateNode} */
    next_sibling
  );
}
function clear_text_content(node) {
  node.textContent = "";
}
function should_defer_append() {
  if (!async_mode_flag) return false;
  if (eager_block_effects !== null) return false;
  var flags2 = (
    /** @type {Effect} */
    active_effect.f
  );
  return (flags2 & EFFECT_RAN) !== 0;
}

// node_modules/svelte/src/internal/client/dom/elements/misc.js
function autofocus(dom, value) {
  if (value) {
    const body = document.body;
    dom.autofocus = true;
    queue_micro_task(() => {
      if (document.activeElement === body) {
        dom.focus();
      }
    });
  }
}
function remove_textarea_child(dom) {
  if (hydrating && get_first_child(dom) !== null) {
    clear_text_content(dom);
  }
}
var listening_to_form_reset = false;
function add_form_reset_listener() {
  if (!listening_to_form_reset) {
    listening_to_form_reset = true;
    document.addEventListener(
      "reset",
      (evt) => {
        Promise.resolve().then(() => {
          var _a3;
          if (!evt.defaultPrevented) {
            for (
              const e of
              /**@type {HTMLFormElement} */
              evt.target.elements
            ) {
              (_a3 = e.__on_r) == null ? void 0 : _a3.call(e);
            }
          }
        });
      },
      // In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)
      { capture: true }
    );
  }
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/shared.js
function without_reactive_context(fn) {
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    return fn();
  } finally {
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}
function listen_to_event_and_reset_event(element2, event2, handler, on_reset = handler) {
  element2.addEventListener(event2, () => without_reactive_context(handler));
  const prev = element2.__on_r;
  if (prev) {
    element2.__on_r = () => {
      prev();
      on_reset(true);
    };
  } else {
    element2.__on_r = () => on_reset(true);
  }
  add_form_reset_listener();
}

// node_modules/svelte/src/internal/client/reactivity/effects.js
function validate_effect(rune) {
  if (active_effect === null && active_reaction === null) {
    effect_orphan(rune);
  }
  if (active_reaction !== null && (active_reaction.f & UNOWNED) !== 0 && active_effect === null) {
    effect_in_unowned_derived();
  }
  if (is_destroying_effect) {
    effect_in_teardown(rune);
  }
}
function push_effect(effect2, parent_effect) {
  var parent_last = parent_effect.last;
  if (parent_last === null) {
    parent_effect.last = parent_effect.first = effect2;
  } else {
    parent_last.next = effect2;
    effect2.prev = parent_last;
    parent_effect.last = effect2;
  }
}
function create_effect(type, fn, sync, push2 = true) {
  var _a3;
  var parent = active_effect;
  if (dev_fallback_default) {
    while (parent !== null && (parent.f & INSPECT_EFFECT) !== 0) {
      parent = parent.parent;
    }
  }
  if (parent !== null && (parent.f & INERT) !== 0) {
    type |= INERT;
  }
  var effect2 = {
    ctx: component_context,
    deps: null,
    nodes_start: null,
    nodes_end: null,
    f: type | DIRTY,
    first: null,
    fn,
    last: null,
    next: null,
    parent,
    b: parent && parent.b,
    prev: null,
    teardown: null,
    transitions: null,
    wv: 0,
    ac: null
  };
  if (dev_fallback_default) {
    effect2.component_function = dev_current_component_function;
  }
  if (sync) {
    try {
      update_effect(effect2);
      effect2.f |= EFFECT_RAN;
    } catch (e2) {
      destroy_effect(effect2);
      throw e2;
    }
  } else if (fn !== null) {
    schedule_effect(effect2);
  }
  if (push2) {
    var e = effect2;
    if (sync && e.deps === null && e.teardown === null && e.nodes_start === null && e.first === e.last && // either `null`, or a singular child
    (e.f & EFFECT_PRESERVED) === 0) {
      e = e.first;
    }
    if (e !== null) {
      e.parent = parent;
      if (parent !== null) {
        push_effect(e, parent);
      }
      if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0 && (type & ROOT_EFFECT) === 0) {
        var derived2 = (
          /** @type {Derived} */
          active_reaction
        );
        ((_a3 = derived2.effects) != null ? _a3 : derived2.effects = []).push(e);
      }
    }
  }
  return effect2;
}
function effect_tracking() {
  return active_reaction !== null && !untracking;
}
function teardown(fn) {
  const effect2 = create_effect(RENDER_EFFECT, null, false);
  set_signal_status(effect2, CLEAN);
  effect2.teardown = fn;
  return effect2;
}
function user_effect(fn) {
  var _a3;
  validate_effect("$effect");
  if (dev_fallback_default) {
    define_property(fn, "name", {
      value: "$effect"
    });
  }
  var flags2 = (
    /** @type {Effect} */
    active_effect.f
  );
  var defer = !active_reaction && (flags2 & BRANCH_EFFECT) !== 0 && (flags2 & EFFECT_RAN) === 0;
  if (defer) {
    var context = (
      /** @type {ComponentContext} */
      component_context
    );
    ((_a3 = context.e) != null ? _a3 : context.e = []).push(fn);
  } else {
    return create_user_effect(fn);
  }
}
function create_user_effect(fn) {
  return create_effect(EFFECT | USER_EFFECT, fn, false);
}
function user_pre_effect(fn) {
  validate_effect("$effect.pre");
  if (dev_fallback_default) {
    define_property(fn, "name", {
      value: "$effect.pre"
    });
  }
  return create_effect(RENDER_EFFECT | USER_EFFECT, fn, true);
}
function effect_root(fn) {
  Batch.ensure();
  const effect2 = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);
  return () => {
    destroy_effect(effect2);
  };
}
function component_root(fn) {
  Batch.ensure();
  const effect2 = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);
  return (options = {}) => {
    return new Promise((fulfil) => {
      if (options.outro) {
        pause_effect(effect2, () => {
          destroy_effect(effect2);
          fulfil(void 0);
        });
      } else {
        destroy_effect(effect2);
        fulfil(void 0);
      }
    });
  };
}
function effect(fn) {
  return create_effect(EFFECT, fn, false);
}
function async_effect(fn) {
  return create_effect(ASYNC | EFFECT_PRESERVED, fn, true);
}
function render_effect(fn, flags2 = 0) {
  return create_effect(RENDER_EFFECT | flags2, fn, true);
}
function template_effect(fn, sync = [], async2 = []) {
  flatten(sync, async2, (values) => {
    create_effect(RENDER_EFFECT, () => fn(...values.map(get)), true);
  });
}
function block(fn, flags2 = 0) {
  var effect2 = create_effect(BLOCK_EFFECT | flags2, fn, true);
  if (dev_fallback_default) {
    effect2.dev_stack = dev_stack;
  }
  return effect2;
}
function branch(fn, push2 = true) {
  return create_effect(BRANCH_EFFECT | EFFECT_PRESERVED, fn, true, push2);
}
function execute_effect_teardown(effect2) {
  var teardown2 = effect2.teardown;
  if (teardown2 !== null) {
    const previously_destroying_effect = is_destroying_effect;
    const previous_reaction = active_reaction;
    set_is_destroying_effect(true);
    set_active_reaction(null);
    try {
      teardown2.call(null);
    } finally {
      set_is_destroying_effect(previously_destroying_effect);
      set_active_reaction(previous_reaction);
    }
  }
}
function destroy_effect_children(signal, remove_dom = false) {
  var effect2 = signal.first;
  signal.first = signal.last = null;
  while (effect2 !== null) {
    const controller = effect2.ac;
    if (controller !== null) {
      without_reactive_context(() => {
        controller.abort(STALE_REACTION);
      });
    }
    var next2 = effect2.next;
    if ((effect2.f & ROOT_EFFECT) !== 0) {
      effect2.parent = null;
    } else {
      destroy_effect(effect2, remove_dom);
    }
    effect2 = next2;
  }
}
function destroy_block_effect_children(signal) {
  var effect2 = signal.first;
  while (effect2 !== null) {
    var next2 = effect2.next;
    if ((effect2.f & BRANCH_EFFECT) === 0) {
      destroy_effect(effect2);
    }
    effect2 = next2;
  }
}
function destroy_effect(effect2, remove_dom = true) {
  var removed = false;
  if ((remove_dom || (effect2.f & HEAD_EFFECT) !== 0) && effect2.nodes_start !== null && effect2.nodes_end !== null) {
    remove_effect_dom(
      effect2.nodes_start,
      /** @type {TemplateNode} */
      effect2.nodes_end
    );
    removed = true;
  }
  destroy_effect_children(effect2, remove_dom && !removed);
  remove_reactions(effect2, 0);
  set_signal_status(effect2, DESTROYED);
  var transitions = effect2.transitions;
  if (transitions !== null) {
    for (const transition3 of transitions) {
      transition3.stop();
    }
  }
  execute_effect_teardown(effect2);
  var parent = effect2.parent;
  if (parent !== null && parent.first !== null) {
    unlink_effect(effect2);
  }
  if (dev_fallback_default) {
    effect2.component_function = null;
  }
  effect2.next = effect2.prev = effect2.teardown = effect2.ctx = effect2.deps = effect2.fn = effect2.nodes_start = effect2.nodes_end = effect2.ac = null;
}
function remove_effect_dom(node, end) {
  while (node !== null) {
    var next2 = node === end ? null : (
      /** @type {TemplateNode} */
      get_next_sibling(node)
    );
    node.remove();
    node = next2;
  }
}
function unlink_effect(effect2) {
  var parent = effect2.parent;
  var prev = effect2.prev;
  var next2 = effect2.next;
  if (prev !== null) prev.next = next2;
  if (next2 !== null) next2.prev = prev;
  if (parent !== null) {
    if (parent.first === effect2) parent.first = next2;
    if (parent.last === effect2) parent.last = prev;
  }
}
function pause_effect(effect2, callback) {
  var transitions = [];
  pause_children(effect2, transitions, true);
  run_out_transitions(transitions, () => {
    destroy_effect(effect2);
    if (callback) callback();
  });
}
function run_out_transitions(transitions, fn) {
  var remaining = transitions.length;
  if (remaining > 0) {
    var check = () => --remaining || fn();
    for (var transition3 of transitions) {
      transition3.out(check);
    }
  } else {
    fn();
  }
}
function pause_children(effect2, transitions, local) {
  if ((effect2.f & INERT) !== 0) return;
  effect2.f ^= INERT;
  if (effect2.transitions !== null) {
    for (const transition3 of effect2.transitions) {
      if (transition3.is_global || local) {
        transitions.push(transition3);
      }
    }
  }
  var child2 = effect2.first;
  while (child2 !== null) {
    var sibling2 = child2.next;
    var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || (child2.f & BRANCH_EFFECT) !== 0;
    pause_children(child2, transitions, transparent ? local : false);
    child2 = sibling2;
  }
}
function resume_effect(effect2) {
  resume_children(effect2, true);
}
function resume_children(effect2, local) {
  if ((effect2.f & INERT) === 0) return;
  effect2.f ^= INERT;
  if ((effect2.f & CLEAN) === 0) {
    set_signal_status(effect2, DIRTY);
    schedule_effect(effect2);
  }
  var child2 = effect2.first;
  while (child2 !== null) {
    var sibling2 = child2.next;
    var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || (child2.f & BRANCH_EFFECT) !== 0;
    resume_children(child2, transparent ? local : false);
    child2 = sibling2;
  }
  if (effect2.transitions !== null) {
    for (const transition3 of effect2.transitions) {
      if (transition3.is_global || local) {
        transition3.in();
      }
    }
  }
}

// node_modules/svelte/src/internal/client/legacy.js
var captured_signals = null;

// node_modules/svelte/src/internal/client/runtime.js
var is_updating_effect = false;
function set_is_updating_effect(value) {
  is_updating_effect = value;
}
var is_destroying_effect = false;
function set_is_destroying_effect(value) {
  is_destroying_effect = value;
}
var active_reaction = null;
var untracking = false;
function set_active_reaction(reaction) {
  active_reaction = reaction;
}
var active_effect = null;
function set_active_effect(effect2) {
  active_effect = effect2;
}
var current_sources = null;
function push_reaction_value(value) {
  if (active_reaction !== null && (!async_mode_flag || (active_reaction.f & DERIVED) !== 0)) {
    if (current_sources === null) {
      current_sources = [value];
    } else {
      current_sources.push(value);
    }
  }
}
var new_deps = null;
var skipped_deps = 0;
var untracked_writes = null;
function set_untracked_writes(value) {
  untracked_writes = value;
}
var write_version = 1;
var read_version = 0;
var update_version = read_version;
function set_update_version(value) {
  update_version = value;
}
var skip_reaction = false;
function increment_write_version() {
  return ++write_version;
}
function is_dirty(reaction) {
  var _a3, _b3;
  var flags2 = reaction.f;
  if ((flags2 & DIRTY) !== 0) {
    return true;
  }
  if ((flags2 & MAYBE_DIRTY) !== 0) {
    var dependencies = reaction.deps;
    var is_unowned = (flags2 & UNOWNED) !== 0;
    if (dependencies !== null) {
      var i;
      var dependency;
      var is_disconnected = (flags2 & DISCONNECTED) !== 0;
      var is_unowned_connected = is_unowned && active_effect !== null && !skip_reaction;
      var length = dependencies.length;
      if ((is_disconnected || is_unowned_connected) && (active_effect === null || (active_effect.f & DESTROYED) === 0)) {
        var derived2 = (
          /** @type {Derived} */
          reaction
        );
        var parent = derived2.parent;
        for (i = 0; i < length; i++) {
          dependency = dependencies[i];
          if (is_disconnected || !((_a3 = dependency == null ? void 0 : dependency.reactions) == null ? void 0 : _a3.includes(derived2))) {
            ((_b3 = dependency.reactions) != null ? _b3 : dependency.reactions = []).push(derived2);
          }
        }
        if (is_disconnected) {
          derived2.f ^= DISCONNECTED;
        }
        if (is_unowned_connected && parent !== null && (parent.f & UNOWNED) === 0) {
          derived2.f ^= UNOWNED;
        }
      }
      for (i = 0; i < length; i++) {
        dependency = dependencies[i];
        if (is_dirty(
          /** @type {Derived} */
          dependency
        )) {
          update_derived(
            /** @type {Derived} */
            dependency
          );
        }
        if (dependency.wv > reaction.wv) {
          return true;
        }
      }
    }
    if (!is_unowned || active_effect !== null && !skip_reaction) {
      set_signal_status(reaction, CLEAN);
    }
  }
  return false;
}
function schedule_possible_effect_self_invalidation(signal, effect2, root37 = true) {
  var reactions = signal.reactions;
  if (reactions === null) return;
  if (!async_mode_flag && (current_sources == null ? void 0 : current_sources.includes(signal))) {
    return;
  }
  for (var i = 0; i < reactions.length; i++) {
    var reaction = reactions[i];
    if ((reaction.f & DERIVED) !== 0) {
      schedule_possible_effect_self_invalidation(
        /** @type {Derived} */
        reaction,
        effect2,
        false
      );
    } else if (effect2 === reaction) {
      if (root37) {
        set_signal_status(reaction, DIRTY);
      } else if ((reaction.f & CLEAN) !== 0) {
        set_signal_status(reaction, MAYBE_DIRTY);
      }
      schedule_effect(
        /** @type {Effect} */
        reaction
      );
    }
  }
}
function update_reaction(reaction) {
  var _a3, _b3;
  var previous_deps = new_deps;
  var previous_skipped_deps = skipped_deps;
  var previous_untracked_writes = untracked_writes;
  var previous_reaction = active_reaction;
  var previous_skip_reaction = skip_reaction;
  var previous_sources = current_sources;
  var previous_component_context = component_context;
  var previous_untracking = untracking;
  var previous_update_version = update_version;
  var flags2 = reaction.f;
  new_deps = /** @type {null | Value[]} */
  null;
  skipped_deps = 0;
  untracked_writes = null;
  skip_reaction = (flags2 & UNOWNED) !== 0 && (untracking || !is_updating_effect || active_reaction === null);
  active_reaction = (flags2 & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;
  current_sources = null;
  set_component_context(reaction.ctx);
  untracking = false;
  update_version = ++read_version;
  if (reaction.ac !== null) {
    without_reactive_context(() => {
      reaction.ac.abort(STALE_REACTION);
    });
    reaction.ac = null;
  }
  try {
    reaction.f |= REACTION_IS_UPDATING;
    var fn = (
      /** @type {Function} */
      reaction.fn
    );
    var result = fn();
    var deps = reaction.deps;
    if (new_deps !== null) {
      var i;
      remove_reactions(reaction, skipped_deps);
      if (deps !== null && skipped_deps > 0) {
        deps.length = skipped_deps + new_deps.length;
        for (i = 0; i < new_deps.length; i++) {
          deps[skipped_deps + i] = new_deps[i];
        }
      } else {
        reaction.deps = deps = new_deps;
      }
      if (!skip_reaction || // Deriveds that already have reactions can cleanup, so we still add them as reactions
      (flags2 & DERIVED) !== 0 && /** @type {import('#client').Derived} */
      reaction.reactions !== null) {
        for (i = skipped_deps; i < deps.length; i++) {
          ((_b3 = (_a3 = deps[i]).reactions) != null ? _b3 : _a3.reactions = []).push(reaction);
        }
      }
    } else if (deps !== null && skipped_deps < deps.length) {
      remove_reactions(reaction, skipped_deps);
      deps.length = skipped_deps;
    }
    if (is_runes() && untracked_writes !== null && !untracking && deps !== null && (reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0) {
      for (i = 0; i < /** @type {Source[]} */
      untracked_writes.length; i++) {
        schedule_possible_effect_self_invalidation(
          untracked_writes[i],
          /** @type {Effect} */
          reaction
        );
      }
    }
    if (previous_reaction !== null && previous_reaction !== reaction) {
      read_version++;
      if (untracked_writes !== null) {
        if (previous_untracked_writes === null) {
          previous_untracked_writes = untracked_writes;
        } else {
          previous_untracked_writes.push(.../** @type {Source[]} */
          untracked_writes);
        }
      }
    }
    if ((reaction.f & ERROR_VALUE) !== 0) {
      reaction.f ^= ERROR_VALUE;
    }
    return result;
  } catch (error) {
    return handle_error(error);
  } finally {
    reaction.f ^= REACTION_IS_UPDATING;
    new_deps = previous_deps;
    skipped_deps = previous_skipped_deps;
    untracked_writes = previous_untracked_writes;
    active_reaction = previous_reaction;
    skip_reaction = previous_skip_reaction;
    current_sources = previous_sources;
    set_component_context(previous_component_context);
    untracking = previous_untracking;
    update_version = previous_update_version;
  }
}
function remove_reaction(signal, dependency) {
  let reactions = dependency.reactions;
  if (reactions !== null) {
    var index2 = index_of.call(reactions, signal);
    if (index2 !== -1) {
      var new_length = reactions.length - 1;
      if (new_length === 0) {
        reactions = dependency.reactions = null;
      } else {
        reactions[index2] = reactions[new_length];
        reactions.pop();
      }
    }
  }
  if (reactions === null && (dependency.f & DERIVED) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (new_deps === null || !new_deps.includes(dependency))) {
    set_signal_status(dependency, MAYBE_DIRTY);
    if ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {
      dependency.f ^= DISCONNECTED;
    }
    destroy_derived_effects(
      /** @type {Derived} **/
      dependency
    );
    remove_reactions(
      /** @type {Derived} **/
      dependency,
      0
    );
  }
}
function remove_reactions(signal, start_index) {
  var dependencies = signal.deps;
  if (dependencies === null) return;
  for (var i = start_index; i < dependencies.length; i++) {
    remove_reaction(signal, dependencies[i]);
  }
}
function update_effect(effect2) {
  var _a3;
  var flags2 = effect2.f;
  if ((flags2 & DESTROYED) !== 0) {
    return;
  }
  set_signal_status(effect2, CLEAN);
  var previous_effect = active_effect;
  var was_updating_effect = is_updating_effect;
  active_effect = effect2;
  is_updating_effect = true;
  if (dev_fallback_default) {
    var previous_component_fn = dev_current_component_function;
    set_dev_current_component_function(effect2.component_function);
    var previous_stack = (
      /** @type {any} */
      dev_stack
    );
    set_dev_stack((_a3 = effect2.dev_stack) != null ? _a3 : dev_stack);
  }
  try {
    if ((flags2 & BLOCK_EFFECT) !== 0) {
      destroy_block_effect_children(effect2);
    } else {
      destroy_effect_children(effect2);
    }
    execute_effect_teardown(effect2);
    var teardown2 = update_reaction(effect2);
    effect2.teardown = typeof teardown2 === "function" ? teardown2 : null;
    effect2.wv = write_version;
    if (dev_fallback_default && tracing_mode_flag && (effect2.f & DIRTY) !== 0 && effect2.deps !== null) {
      for (var dep of effect2.deps) {
        if (dep.set_during_effect) {
          dep.wv = increment_write_version();
          dep.set_during_effect = false;
        }
      }
    }
  } finally {
    is_updating_effect = was_updating_effect;
    active_effect = previous_effect;
    if (dev_fallback_default) {
      set_dev_current_component_function(previous_component_fn);
      set_dev_stack(previous_stack);
    }
  }
}
async function tick() {
  if (async_mode_flag) {
    return new Promise((f) => {
      requestAnimationFrame(() => f());
      setTimeout(() => f());
    });
  }
  await Promise.resolve();
  flushSync();
}
function get(signal) {
  var _a3, _b3, _c2, _d, _e;
  var flags2 = signal.f;
  var is_derived = (flags2 & DERIVED) !== 0;
  (_a3 = captured_signals) == null ? void 0 : _a3.add(signal);
  if (active_reaction !== null && !untracking) {
    var destroyed = active_effect !== null && (active_effect.f & DESTROYED) !== 0;
    if (!destroyed && !(current_sources == null ? void 0 : current_sources.includes(signal))) {
      var deps = active_reaction.deps;
      if ((active_reaction.f & REACTION_IS_UPDATING) !== 0) {
        if (signal.rv < read_version) {
          signal.rv = read_version;
          if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
            skipped_deps++;
          } else if (new_deps === null) {
            new_deps = [signal];
          } else if (!skip_reaction || !new_deps.includes(signal)) {
            new_deps.push(signal);
          }
        }
      } else {
        ((_b3 = active_reaction.deps) != null ? _b3 : active_reaction.deps = []).push(signal);
        var reactions = signal.reactions;
        if (reactions === null) {
          signal.reactions = [active_reaction];
        } else if (!reactions.includes(active_reaction)) {
          reactions.push(active_reaction);
        }
      }
    }
  } else if (is_derived && /** @type {Derived} */
  signal.deps === null && /** @type {Derived} */
  signal.effects === null) {
    var derived2 = (
      /** @type {Derived} */
      signal
    );
    var parent = derived2.parent;
    if (parent !== null && (parent.f & UNOWNED) === 0) {
      derived2.f ^= UNOWNED;
    }
  }
  if (dev_fallback_default) {
    if (current_async_effect) {
      var tracking = (current_async_effect.f & REACTION_IS_UPDATING) !== 0;
      var was_read = (_c2 = current_async_effect.deps) == null ? void 0 : _c2.includes(signal);
      if (!tracking && !untracking && !was_read) {
        await_reactivity_loss(
          /** @type {string} */
          signal.label
        );
        var trace2 = get_stack("TracedAt");
        if (trace2) console.warn(trace2);
      }
    }
    recent_async_deriveds.delete(signal);
    if (tracing_mode_flag && !untracking && tracing_expressions !== null && active_reaction !== null && tracing_expressions.reaction === active_reaction) {
      if (signal.trace) {
        signal.trace();
      } else {
        trace2 = get_stack("TracedAt");
        if (trace2) {
          var entry = tracing_expressions.entries.get(signal);
          if (entry === void 0) {
            entry = { traces: [] };
            tracing_expressions.entries.set(signal, entry);
          }
          var last = entry.traces[entry.traces.length - 1];
          if (trace2.stack !== (last == null ? void 0 : last.stack)) {
            entry.traces.push(trace2);
          }
        }
      }
    }
  }
  if (is_destroying_effect) {
    if (old_values.has(signal)) {
      return old_values.get(signal);
    }
    if (is_derived) {
      derived2 = /** @type {Derived} */
      signal;
      var value = derived2.v;
      if ((derived2.f & CLEAN) === 0 && derived2.reactions !== null || depends_on_old_values(derived2)) {
        value = execute_derived(derived2);
      }
      old_values.set(derived2, value);
      return value;
    }
  } else if (is_derived) {
    derived2 = /** @type {Derived} */
    signal;
    if ((_d = batch_values) == null ? void 0 : _d.has(derived2)) {
      return batch_values.get(derived2);
    }
    if (is_dirty(derived2)) {
      update_derived(derived2);
    }
  }
  if ((_e = batch_values) == null ? void 0 : _e.has(signal)) {
    return batch_values.get(signal);
  }
  if ((signal.f & ERROR_VALUE) !== 0) {
    throw signal.v;
  }
  return signal.v;
}
function depends_on_old_values(derived2) {
  if (derived2.v === UNINITIALIZED) return true;
  if (derived2.deps === null) return false;
  for (const dep of derived2.deps) {
    if (old_values.has(dep)) {
      return true;
    }
    if ((dep.f & DERIVED) !== 0 && depends_on_old_values(
      /** @type {Derived} */
      dep
    )) {
      return true;
    }
  }
  return false;
}
function untrack(fn) {
  var previous_untracking = untracking;
  try {
    untracking = true;
    return fn();
  } finally {
    untracking = previous_untracking;
  }
}
var STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);
function set_signal_status(signal, status) {
  signal.f = signal.f & STATUS_MASK | status;
}
function exclude_from_object(obj, keys) {
  var result = {};
  for (var key3 in obj) {
    if (!keys.includes(key3)) {
      result[key3] = obj[key3];
    }
  }
  return result;
}
function deep_read_state(value) {
  if (typeof value !== "object" || !value || value instanceof EventTarget) {
    return;
  }
  if (STATE_SYMBOL in value) {
    deep_read(value);
  } else if (!Array.isArray(value)) {
    for (let key3 in value) {
      const prop2 = value[key3];
      if (typeof prop2 === "object" && prop2 && STATE_SYMBOL in prop2) {
        deep_read(prop2);
      }
    }
  }
}
function deep_read(value, visited = /* @__PURE__ */ new Set()) {
  if (typeof value === "object" && value !== null && // We don't want to traverse DOM elements
  !(value instanceof EventTarget) && !visited.has(value)) {
    visited.add(value);
    if (value instanceof Date) {
      value.getTime();
    }
    for (let key3 in value) {
      try {
        deep_read(value[key3], visited);
      } catch (e) {
      }
    }
    const proto = get_prototype_of(value);
    if (proto !== Object.prototype && proto !== Array.prototype && proto !== Map.prototype && proto !== Set.prototype && proto !== Date.prototype) {
      const descriptors = get_descriptors(proto);
      for (let key3 in descriptors) {
        const get5 = descriptors[key3].get;
        if (get5) {
          try {
            get5.call(value);
          } catch (e) {
          }
        }
      }
    }
  }
}

// node_modules/svelte/src/utils.js
function is_capture_event(name) {
  return name.endsWith("capture") && name !== "gotpointercapture" && name !== "lostpointercapture";
}
var DELEGATED_EVENTS = [
  "beforeinput",
  "click",
  "change",
  "dblclick",
  "contextmenu",
  "focusin",
  "focusout",
  "input",
  "keydown",
  "keyup",
  "mousedown",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "pointerdown",
  "pointermove",
  "pointerout",
  "pointerover",
  "pointerup",
  "touchend",
  "touchmove",
  "touchstart"
];
function is_delegated(event_name) {
  return DELEGATED_EVENTS.includes(event_name);
}
var DOM_BOOLEAN_ATTRIBUTES = [
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "disabled",
  "formnovalidate",
  "indeterminate",
  "inert",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "seamless",
  "selected",
  "webkitdirectory",
  "defer",
  "disablepictureinpicture",
  "disableremoteplayback"
];
var ATTRIBUTE_ALIASES = {
  // no `class: 'className'` because we handle that separately
  formnovalidate: "formNoValidate",
  ismap: "isMap",
  nomodule: "noModule",
  playsinline: "playsInline",
  readonly: "readOnly",
  defaultvalue: "defaultValue",
  defaultchecked: "defaultChecked",
  srcobject: "srcObject",
  novalidate: "noValidate",
  allowfullscreen: "allowFullscreen",
  disablepictureinpicture: "disablePictureInPicture",
  disableremoteplayback: "disableRemotePlayback"
};
function normalize_attribute(name) {
  var _a3;
  name = name.toLowerCase();
  return (_a3 = ATTRIBUTE_ALIASES[name]) != null ? _a3 : name;
}
var DOM_PROPERTIES = [
  ...DOM_BOOLEAN_ATTRIBUTES,
  "formNoValidate",
  "isMap",
  "noModule",
  "playsInline",
  "readOnly",
  "value",
  "volume",
  "defaultValue",
  "defaultChecked",
  "srcObject",
  "noValidate",
  "allowFullscreen",
  "disablePictureInPicture",
  "disableRemotePlayback"
];
var PASSIVE_EVENTS = ["touchstart", "touchmove"];
function is_passive_event(name) {
  return PASSIVE_EVENTS.includes(name);
}
var STATE_CREATION_RUNES = (
  /** @type {const} */
  [
    "$state",
    "$state.raw",
    "$derived",
    "$derived.by"
  ]
);
var RUNES = (
  /** @type {const} */
  [
    ...STATE_CREATION_RUNES,
    "$state.snapshot",
    "$props",
    "$props.id",
    "$bindable",
    "$effect",
    "$effect.pre",
    "$effect.tracking",
    "$effect.root",
    "$effect.pending",
    "$inspect",
    "$inspect().with",
    "$inspect.trace",
    "$host"
  ]
);
var RAW_TEXT_ELEMENTS = (
  /** @type {const} */
  ["textarea", "script", "style", "title"]
);
function is_raw_text_element(name) {
  return RAW_TEXT_ELEMENTS.includes(
    /** @type {typeof RAW_TEXT_ELEMENTS[number]} */
    name
  );
}

// node_modules/svelte/src/internal/client/dev/css.js
var all_styles = /* @__PURE__ */ new Map();
function register_style(hash2, style) {
  var styles = all_styles.get(hash2);
  if (!styles) {
    styles = /* @__PURE__ */ new Set();
    all_styles.set(hash2, styles);
  }
  styles.add(style);
}

// node_modules/svelte/src/internal/client/dom/elements/events.js
var all_registered_events = /* @__PURE__ */ new Set();
var root_event_handles = /* @__PURE__ */ new Set();
function create_event(event_name, dom, handler, options = {}) {
  function target_handler(event2) {
    if (!options.capture) {
      handle_event_propagation.call(dom, event2);
    }
    if (!event2.cancelBubble) {
      return without_reactive_context(() => {
        return handler == null ? void 0 : handler.call(this, event2);
      });
    }
  }
  if (event_name.startsWith("pointer") || event_name.startsWith("touch") || event_name === "wheel") {
    queue_micro_task(() => {
      dom.addEventListener(event_name, target_handler, options);
    });
  } else {
    dom.addEventListener(event_name, target_handler, options);
  }
  return target_handler;
}
function on(element2, type, handler, options = {}) {
  var target_handler = create_event(type, element2, handler, options);
  return () => {
    element2.removeEventListener(type, target_handler, options);
  };
}
function event(event_name, dom, handler, capture2, passive2) {
  var options = { capture: capture2, passive: passive2 };
  var target_handler = create_event(event_name, dom, handler, options);
  if (dom === document.body || // @ts-ignore
  dom === window || // @ts-ignore
  dom === document || // Firefox has quirky behavior, it can happen that we still get "canplay" events when the element is already removed
  dom instanceof HTMLMediaElement) {
    teardown(() => {
      dom.removeEventListener(event_name, target_handler, options);
    });
  }
}
function delegate(events) {
  for (var i = 0; i < events.length; i++) {
    all_registered_events.add(events[i]);
  }
  for (var fn of root_event_handles) {
    fn(events);
  }
}
var last_propagated_event = null;
function handle_event_propagation(event2) {
  var _a3;
  var handler_element = this;
  var owner_document = (
    /** @type {Node} */
    handler_element.ownerDocument
  );
  var event_name = event2.type;
  var path = ((_a3 = event2.composedPath) == null ? void 0 : _a3.call(event2)) || [];
  var current_target = (
    /** @type {null | Element} */
    path[0] || event2.target
  );
  last_propagated_event = event2;
  var path_idx = 0;
  var handled_at = last_propagated_event === event2 && event2.__root;
  if (handled_at) {
    var at_idx = path.indexOf(handled_at);
    if (at_idx !== -1 && (handler_element === document || handler_element === /** @type {any} */
    window)) {
      event2.__root = handler_element;
      return;
    }
    var handler_idx = path.indexOf(handler_element);
    if (handler_idx === -1) {
      return;
    }
    if (at_idx <= handler_idx) {
      path_idx = at_idx;
    }
  }
  current_target = /** @type {Element} */
  path[path_idx] || event2.target;
  if (current_target === handler_element) return;
  define_property(event2, "currentTarget", {
    configurable: true,
    get() {
      return current_target || owner_document;
    }
  });
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    var throw_error;
    var other_errors = [];
    while (current_target !== null) {
      var parent_element = current_target.assignedSlot || current_target.parentNode || /** @type {any} */
      current_target.host || null;
      try {
        var delegated = current_target["__" + event_name];
        if (delegated != null && (!/** @type {any} */
        current_target.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
        // -> the target could not have been disabled because it emits the event in the first place
        event2.target === current_target)) {
          if (is_array(delegated)) {
            var [fn, ...data] = delegated;
            fn.apply(current_target, [event2, ...data]);
          } else {
            delegated.call(current_target, event2);
          }
        }
      } catch (error) {
        if (throw_error) {
          other_errors.push(error);
        } else {
          throw_error = error;
        }
      }
      if (event2.cancelBubble || parent_element === handler_element || parent_element === null) {
        break;
      }
      current_target = parent_element;
    }
    if (throw_error) {
      for (let error of other_errors) {
        queueMicrotask(() => {
          throw error;
        });
      }
      throw throw_error;
    }
  } finally {
    event2.__root = handler_element;
    delete event2.currentTarget;
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}

// node_modules/svelte/src/internal/client/dom/blocks/svelte-head.js
var head_anchor;
function reset_head_anchor() {
  head_anchor = void 0;
}

// node_modules/svelte/src/internal/client/dom/reconciler.js
function create_fragment_from_html(html2) {
  var elem = document.createElement("template");
  elem.innerHTML = html2.replaceAll("<!>", "<!---->");
  return elem.content;
}

// node_modules/svelte/src/internal/client/dom/template.js
function assign_nodes(start2, end) {
  var effect2 = (
    /** @type {Effect} */
    active_effect
  );
  if (effect2.nodes_start === null) {
    effect2.nodes_start = start2;
    effect2.nodes_end = end;
  }
}
// @__NO_SIDE_EFFECTS__
function from_html(content, flags2) {
  var is_fragment = (flags2 & TEMPLATE_FRAGMENT) !== 0;
  var use_import_node = (flags2 & TEMPLATE_USE_IMPORT_NODE) !== 0;
  var node;
  var has_start = !content.startsWith("<!>");
  return () => {
    if (hydrating) {
      assign_nodes(hydrate_node, null);
      return hydrate_node;
    }
    if (node === void 0) {
      node = create_fragment_from_html(has_start ? content : "<!>" + content);
      if (!is_fragment) node = /** @type {Node} */
      get_first_child(node);
    }
    var clone2 = (
      /** @type {TemplateNode} */
      use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)
    );
    if (is_fragment) {
      var start2 = (
        /** @type {TemplateNode} */
        get_first_child(clone2)
      );
      var end = (
        /** @type {TemplateNode} */
        clone2.lastChild
      );
      assign_nodes(start2, end);
    } else {
      assign_nodes(clone2, clone2);
    }
    return clone2;
  };
}
// @__NO_SIDE_EFFECTS__
function from_namespace(content, flags2, ns = "svg") {
  var has_start = !content.startsWith("<!>");
  var is_fragment = (flags2 & TEMPLATE_FRAGMENT) !== 0;
  var wrapped = `<${ns}>${has_start ? content : "<!>" + content}</${ns}>`;
  var node;
  return () => {
    if (hydrating) {
      assign_nodes(hydrate_node, null);
      return hydrate_node;
    }
    if (!node) {
      var fragment = (
        /** @type {DocumentFragment} */
        create_fragment_from_html(wrapped)
      );
      var root37 = (
        /** @type {Element} */
        get_first_child(fragment)
      );
      if (is_fragment) {
        node = document.createDocumentFragment();
        while (get_first_child(root37)) {
          node.appendChild(
            /** @type {Node} */
            get_first_child(root37)
          );
        }
      } else {
        node = /** @type {Element} */
        get_first_child(root37);
      }
    }
    var clone2 = (
      /** @type {TemplateNode} */
      node.cloneNode(true)
    );
    if (is_fragment) {
      var start2 = (
        /** @type {TemplateNode} */
        get_first_child(clone2)
      );
      var end = (
        /** @type {TemplateNode} */
        clone2.lastChild
      );
      assign_nodes(start2, end);
    } else {
      assign_nodes(clone2, clone2);
    }
    return clone2;
  };
}
// @__NO_SIDE_EFFECTS__
function from_svg(content, flags2) {
  return /* @__PURE__ */ from_namespace(content, flags2, "svg");
}
function text(value = "") {
  if (!hydrating) {
    var t = create_text(value + "");
    assign_nodes(t, t);
    return t;
  }
  var node = hydrate_node;
  if (node.nodeType !== TEXT_NODE) {
    node.before(node = create_text());
    set_hydrate_node(node);
  }
  assign_nodes(node, node);
  return node;
}
function comment() {
  if (hydrating) {
    assign_nodes(hydrate_node, null);
    return hydrate_node;
  }
  var frag = document.createDocumentFragment();
  var start2 = document.createComment("");
  var anchor = create_text();
  frag.append(start2, anchor);
  assign_nodes(start2, anchor);
  return frag;
}
function append(anchor, dom) {
  if (hydrating) {
    active_effect.nodes_end = hydrate_node;
    hydrate_next();
    return;
  }
  if (anchor === null) {
    return;
  }
  anchor.before(
    /** @type {Node} */
    dom
  );
}

// node_modules/svelte/src/internal/client/render.js
var should_intro = true;
function set_should_intro(value) {
  should_intro = value;
}
function set_text(text2, value) {
  var _a3;
  var str = value == null ? "" : typeof value === "object" ? value + "" : value;
  if (str !== ((_a3 = text2.__t) != null ? _a3 : text2.__t = text2.nodeValue)) {
    text2.__t = str;
    text2.nodeValue = str + "";
  }
}
function mount(component2, options) {
  return _mount(component2, options);
}
function hydrate(component2, options) {
  var _a3;
  init_operations();
  options.intro = (_a3 = options.intro) != null ? _a3 : false;
  const target = options.target;
  const was_hydrating = hydrating;
  const previous_hydrate_node = hydrate_node;
  try {
    var anchor = (
      /** @type {TemplateNode} */
      get_first_child(target)
    );
    while (anchor && (anchor.nodeType !== COMMENT_NODE || /** @type {Comment} */
    anchor.data !== HYDRATION_START)) {
      anchor = /** @type {TemplateNode} */
      get_next_sibling(anchor);
    }
    if (!anchor) {
      throw HYDRATION_ERROR;
    }
    set_hydrating(true);
    set_hydrate_node(
      /** @type {Comment} */
      anchor
    );
    const instance = _mount(component2, { ...options, anchor });
    set_hydrating(false);
    return (
      /**  @type {Exports} */
      instance
    );
  } catch (error) {
    if (error instanceof Error && error.message.split("\n").some((line) => line.startsWith("https://svelte.dev/e/"))) {
      throw error;
    }
    if (error !== HYDRATION_ERROR) {
      console.warn("Failed to hydrate: ", error);
    }
    if (options.recover === false) {
      hydration_failed();
    }
    init_operations();
    clear_text_content(target);
    set_hydrating(false);
    return mount(component2, options);
  } finally {
    set_hydrating(was_hydrating);
    set_hydrate_node(previous_hydrate_node);
    reset_head_anchor();
  }
}
var document_listeners = /* @__PURE__ */ new Map();
function _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {
  init_operations();
  var registered_events = /* @__PURE__ */ new Set();
  var event_handle = (events2) => {
    for (var i = 0; i < events2.length; i++) {
      var event_name = events2[i];
      if (registered_events.has(event_name)) continue;
      registered_events.add(event_name);
      var passive2 = is_passive_event(event_name);
      target.addEventListener(event_name, handle_event_propagation, { passive: passive2 });
      var n = document_listeners.get(event_name);
      if (n === void 0) {
        document.addEventListener(event_name, handle_event_propagation, { passive: passive2 });
        document_listeners.set(event_name, 1);
      } else {
        document_listeners.set(event_name, n + 1);
      }
    }
  };
  event_handle(array_from(all_registered_events));
  root_event_handles.add(event_handle);
  var component2 = void 0;
  var unmount2 = component_root(() => {
    var anchor_node = anchor != null ? anchor : target.appendChild(create_text());
    boundary(
      /** @type {TemplateNode} */
      anchor_node,
      {
        pending: () => {
        }
      },
      (anchor_node2) => {
        if (context) {
          push({});
          var ctx = (
            /** @type {ComponentContext} */
            component_context
          );
          ctx.c = context;
        }
        if (events) {
          props.$$events = events;
        }
        if (hydrating) {
          assign_nodes(
            /** @type {TemplateNode} */
            anchor_node2,
            null
          );
        }
        should_intro = intro;
        component2 = Component(anchor_node2, props) || {};
        should_intro = true;
        if (hydrating) {
          active_effect.nodes_end = hydrate_node;
          if (hydrate_node === null || hydrate_node.nodeType !== COMMENT_NODE || /** @type {Comment} */
          hydrate_node.data !== HYDRATION_END) {
            hydration_mismatch();
            throw HYDRATION_ERROR;
          }
        }
        if (context) {
          pop();
        }
      }
    );
    return () => {
      var _a3;
      for (var event_name of registered_events) {
        target.removeEventListener(event_name, handle_event_propagation);
        var n = (
          /** @type {number} */
          document_listeners.get(event_name)
        );
        if (--n === 0) {
          document.removeEventListener(event_name, handle_event_propagation);
          document_listeners.delete(event_name);
        } else {
          document_listeners.set(event_name, n);
        }
      }
      root_event_handles.delete(event_handle);
      if (anchor_node !== anchor) {
        (_a3 = anchor_node.parentNode) == null ? void 0 : _a3.removeChild(anchor_node);
      }
    };
  });
  mounted_components.set(component2, unmount2);
  return component2;
}
var mounted_components = /* @__PURE__ */ new WeakMap();
function unmount(component2, options) {
  const fn = mounted_components.get(component2);
  if (fn) {
    mounted_components.delete(component2);
    return fn(options);
  }
  if (dev_fallback_default) {
    if (STATE_SYMBOL in component2) {
      state_proxy_unmount();
    } else {
      lifecycle_double_unmount();
    }
  }
  return Promise.resolve();
}

// node_modules/svelte/src/internal/client/dom/blocks/if.js
function if_block(node, fn, elseif = false) {
  if (hydrating) {
    hydrate_next();
  }
  var anchor = node;
  var consequent_effect = null;
  var alternate_effect = null;
  var condition = UNINITIALIZED;
  var flags2 = elseif ? EFFECT_TRANSPARENT : 0;
  var has_branch = false;
  const set_branch = (fn2, flag = true) => {
    has_branch = true;
    update_branch(flag, fn2);
  };
  var offscreen_fragment = null;
  function commit() {
    if (offscreen_fragment !== null) {
      offscreen_fragment.lastChild.remove();
      anchor.before(offscreen_fragment);
      offscreen_fragment = null;
    }
    var active = condition ? consequent_effect : alternate_effect;
    var inactive = condition ? alternate_effect : consequent_effect;
    if (active) {
      resume_effect(active);
    }
    if (inactive) {
      pause_effect(inactive, () => {
        if (condition) {
          alternate_effect = null;
        } else {
          consequent_effect = null;
        }
      });
    }
  }
  const update_branch = (new_condition, fn2) => {
    if (condition === (condition = new_condition)) return;
    let mismatch = false;
    if (hydrating) {
      const is_else = read_hydration_instruction(anchor) === HYDRATION_START_ELSE;
      if (!!condition === is_else) {
        anchor = skip_nodes();
        set_hydrate_node(anchor);
        set_hydrating(false);
        mismatch = true;
      }
    }
    var defer = should_defer_append();
    var target = anchor;
    if (defer) {
      offscreen_fragment = document.createDocumentFragment();
      offscreen_fragment.append(target = create_text());
    }
    if (condition) {
      consequent_effect != null ? consequent_effect : consequent_effect = fn2 && branch(() => fn2(target));
    } else {
      alternate_effect != null ? alternate_effect : alternate_effect = fn2 && branch(() => fn2(target));
    }
    if (defer) {
      var batch = (
        /** @type {Batch} */
        current_batch
      );
      var active = condition ? consequent_effect : alternate_effect;
      var inactive = condition ? alternate_effect : consequent_effect;
      if (active) batch.skipped_effects.delete(active);
      if (inactive) batch.skipped_effects.add(inactive);
      batch.add_callback(commit);
    } else {
      commit();
    }
    if (mismatch) {
      set_hydrating(true);
    }
  };
  block(() => {
    has_branch = false;
    fn(set_branch);
    if (!has_branch) {
      update_branch(null, null);
    }
  }, flags2);
  if (hydrating) {
    anchor = hydrate_node;
  }
}

// node_modules/svelte/src/internal/client/dom/blocks/css-props.js
function css_props(element2, get_styles) {
  if (hydrating) {
    set_hydrate_node(
      /** @type {TemplateNode} */
      get_first_child(element2)
    );
  }
  render_effect(() => {
    var styles = get_styles();
    for (var key3 in styles) {
      var value = styles[key3];
      if (value) {
        element2.style.setProperty(key3, value);
      } else {
        element2.style.removeProperty(key3);
      }
    }
  });
}

// node_modules/svelte/src/internal/client/dom/blocks/each.js
var current_each_item = null;
function set_current_each_item(item) {
  current_each_item = item;
}
function index(_, i) {
  return i;
}
function pause_effects(state2, items, controlled_anchor) {
  var items_map = state2.items;
  var transitions = [];
  var length = items.length;
  for (var i = 0; i < length; i++) {
    pause_children(items[i].e, transitions, true);
  }
  var is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;
  if (is_controlled) {
    var parent_node = (
      /** @type {Element} */
      /** @type {Element} */
      controlled_anchor.parentNode
    );
    clear_text_content(parent_node);
    parent_node.append(
      /** @type {Element} */
      controlled_anchor
    );
    items_map.clear();
    link(state2, items[0].prev, items[length - 1].next);
  }
  run_out_transitions(transitions, () => {
    for (var i2 = 0; i2 < length; i2++) {
      var item = items[i2];
      if (!is_controlled) {
        items_map.delete(item.k);
        link(state2, item.prev, item.next);
      }
      destroy_effect(item.e, !is_controlled);
    }
  });
}
function each(node, flags2, get_collection, get_key, render_fn, fallback_fn = null) {
  var anchor = node;
  var state2 = { flags: flags2, items: /* @__PURE__ */ new Map(), first: null };
  var is_controlled = (flags2 & EACH_IS_CONTROLLED) !== 0;
  if (is_controlled) {
    var parent_node = (
      /** @type {Element} */
      node
    );
    anchor = hydrating ? set_hydrate_node(
      /** @type {Comment | Text} */
      get_first_child(parent_node)
    ) : parent_node.appendChild(create_text());
  }
  if (hydrating) {
    hydrate_next();
  }
  var fallback2 = null;
  var was_empty = false;
  var offscreen_items = /* @__PURE__ */ new Map();
  var each_array = derived_safe_equal(() => {
    var collection = get_collection();
    return is_array(collection) ? collection : collection == null ? [] : array_from(collection);
  });
  var array2;
  var each_effect;
  function commit() {
    reconcile(
      each_effect,
      array2,
      state2,
      offscreen_items,
      anchor,
      render_fn,
      flags2,
      get_key,
      get_collection
    );
    if (fallback_fn !== null) {
      if (array2.length === 0) {
        if (fallback2) {
          resume_effect(fallback2);
        } else {
          fallback2 = branch(() => fallback_fn(anchor));
        }
      } else if (fallback2 !== null) {
        pause_effect(fallback2, () => {
          fallback2 = null;
        });
      }
    }
  }
  block(() => {
    var _a3;
    each_effect != null ? each_effect : each_effect = /** @type {Effect} */
    active_effect;
    array2 = /** @type {V[]} */
    get(each_array);
    var length = array2.length;
    if (was_empty && length === 0) {
      return;
    }
    was_empty = length === 0;
    let mismatch = false;
    if (hydrating) {
      var is_else = read_hydration_instruction(anchor) === HYDRATION_START_ELSE;
      if (is_else !== (length === 0)) {
        anchor = skip_nodes();
        set_hydrate_node(anchor);
        set_hydrating(false);
        mismatch = true;
      }
    }
    if (hydrating) {
      var prev = null;
      var item;
      for (var i = 0; i < length; i++) {
        if (hydrate_node.nodeType === COMMENT_NODE && /** @type {Comment} */
        hydrate_node.data === HYDRATION_END) {
          anchor = /** @type {Comment} */
          hydrate_node;
          mismatch = true;
          set_hydrating(false);
          break;
        }
        var value = array2[i];
        var key3 = get_key(value, i);
        item = create_item(
          hydrate_node,
          state2,
          prev,
          null,
          value,
          key3,
          i,
          render_fn,
          flags2,
          get_collection
        );
        state2.items.set(key3, item);
        prev = item;
      }
      if (length > 0) {
        set_hydrate_node(skip_nodes());
      }
    }
    if (hydrating) {
      if (length === 0 && fallback_fn) {
        fallback2 = branch(() => fallback_fn(anchor));
      }
    } else {
      if (should_defer_append()) {
        var keys = /* @__PURE__ */ new Set();
        var batch = (
          /** @type {Batch} */
          current_batch
        );
        for (i = 0; i < length; i += 1) {
          value = array2[i];
          key3 = get_key(value, i);
          var existing = (_a3 = state2.items.get(key3)) != null ? _a3 : offscreen_items.get(key3);
          if (existing) {
            if ((flags2 & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0) {
              update_item(existing, value, i, flags2);
            }
          } else {
            item = create_item(
              null,
              state2,
              null,
              null,
              value,
              key3,
              i,
              render_fn,
              flags2,
              get_collection,
              true
            );
            offscreen_items.set(key3, item);
          }
          keys.add(key3);
        }
        for (const [key4, item2] of state2.items) {
          if (!keys.has(key4)) {
            batch.skipped_effects.add(item2.e);
          }
        }
        batch.add_callback(commit);
      } else {
        commit();
      }
    }
    if (mismatch) {
      set_hydrating(true);
    }
    get(each_array);
  });
  if (hydrating) {
    anchor = hydrate_node;
  }
}
function reconcile(each_effect, array2, state2, offscreen_items, anchor, render_fn, flags2, get_key, get_collection) {
  var _a3, _b3, _c2, _d;
  var is_animated = (flags2 & EACH_IS_ANIMATED) !== 0;
  var should_update = (flags2 & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;
  var length = array2.length;
  var items = state2.items;
  var first = state2.first;
  var current = first;
  var seen;
  var prev = null;
  var to_animate;
  var matched = [];
  var stashed = [];
  var value;
  var key3;
  var item;
  var i;
  if (is_animated) {
    for (i = 0; i < length; i += 1) {
      value = array2[i];
      key3 = get_key(value, i);
      item = items.get(key3);
      if (item !== void 0) {
        (_a3 = item.a) == null ? void 0 : _a3.measure();
        (to_animate != null ? to_animate : to_animate = /* @__PURE__ */ new Set()).add(item);
      }
    }
  }
  for (i = 0; i < length; i += 1) {
    value = array2[i];
    key3 = get_key(value, i);
    item = items.get(key3);
    if (item === void 0) {
      var pending2 = offscreen_items.get(key3);
      if (pending2 !== void 0) {
        offscreen_items.delete(key3);
        items.set(key3, pending2);
        var next2 = prev ? prev.next : current;
        link(state2, prev, pending2);
        link(state2, pending2, next2);
        move(pending2, next2, anchor);
        prev = pending2;
      } else {
        var child_anchor = current ? (
          /** @type {TemplateNode} */
          current.e.nodes_start
        ) : anchor;
        prev = create_item(
          child_anchor,
          state2,
          prev,
          prev === null ? state2.first : prev.next,
          value,
          key3,
          i,
          render_fn,
          flags2,
          get_collection
        );
      }
      items.set(key3, prev);
      matched = [];
      stashed = [];
      current = prev.next;
      continue;
    }
    if (should_update) {
      update_item(item, value, i, flags2);
    }
    if ((item.e.f & INERT) !== 0) {
      resume_effect(item.e);
      if (is_animated) {
        (_b3 = item.a) == null ? void 0 : _b3.unfix();
        (to_animate != null ? to_animate : to_animate = /* @__PURE__ */ new Set()).delete(item);
      }
    }
    if (item !== current) {
      if (seen !== void 0 && seen.has(item)) {
        if (matched.length < stashed.length) {
          var start2 = stashed[0];
          var j;
          prev = start2.prev;
          var a = matched[0];
          var b = matched[matched.length - 1];
          for (j = 0; j < matched.length; j += 1) {
            move(matched[j], start2, anchor);
          }
          for (j = 0; j < stashed.length; j += 1) {
            seen.delete(stashed[j]);
          }
          link(state2, a.prev, b.next);
          link(state2, prev, a);
          link(state2, b, start2);
          current = start2;
          prev = b;
          i -= 1;
          matched = [];
          stashed = [];
        } else {
          seen.delete(item);
          move(item, current, anchor);
          link(state2, item.prev, item.next);
          link(state2, item, prev === null ? state2.first : prev.next);
          link(state2, prev, item);
          prev = item;
        }
        continue;
      }
      matched = [];
      stashed = [];
      while (current !== null && current.k !== key3) {
        if ((current.e.f & INERT) === 0) {
          (seen != null ? seen : seen = /* @__PURE__ */ new Set()).add(current);
        }
        stashed.push(current);
        current = current.next;
      }
      if (current === null) {
        continue;
      }
      item = current;
    }
    matched.push(item);
    prev = item;
    current = item.next;
  }
  if (current !== null || seen !== void 0) {
    var to_destroy = seen === void 0 ? [] : array_from(seen);
    while (current !== null) {
      if ((current.e.f & INERT) === 0) {
        to_destroy.push(current);
      }
      current = current.next;
    }
    var destroy_length = to_destroy.length;
    if (destroy_length > 0) {
      var controlled_anchor = (flags2 & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;
      if (is_animated) {
        for (i = 0; i < destroy_length; i += 1) {
          (_c2 = to_destroy[i].a) == null ? void 0 : _c2.measure();
        }
        for (i = 0; i < destroy_length; i += 1) {
          (_d = to_destroy[i].a) == null ? void 0 : _d.fix();
        }
      }
      pause_effects(state2, to_destroy, controlled_anchor);
    }
  }
  if (is_animated) {
    queue_micro_task(() => {
      var _a4;
      if (to_animate === void 0) return;
      for (item of to_animate) {
        (_a4 = item.a) == null ? void 0 : _a4.apply();
      }
    });
  }
  each_effect.first = state2.first && state2.first.e;
  each_effect.last = prev && prev.e;
  for (var unused of offscreen_items.values()) {
    destroy_effect(unused.e);
  }
  offscreen_items.clear();
}
function update_item(item, value, index2, type) {
  if ((type & EACH_ITEM_REACTIVE) !== 0) {
    internal_set(item.v, value);
  }
  if ((type & EACH_INDEX_REACTIVE) !== 0) {
    internal_set(
      /** @type {Value<number>} */
      item.i,
      index2
    );
  } else {
    item.i = index2;
  }
}
function create_item(anchor, state2, prev, next2, value, key3, index2, render_fn, flags2, get_collection, deferred2) {
  var previous_each_item = current_each_item;
  var reactive = (flags2 & EACH_ITEM_REACTIVE) !== 0;
  var mutable = (flags2 & EACH_ITEM_IMMUTABLE) === 0;
  var v = reactive ? mutable ? mutable_source(value, false, false) : source(value) : value;
  var i = (flags2 & EACH_INDEX_REACTIVE) === 0 ? index2 : source(index2);
  if (dev_fallback_default && reactive) {
    v.trace = () => {
      var collection_index = typeof i === "number" ? index2 : i.v;
      get_collection()[collection_index];
    };
  }
  var item = {
    i,
    v,
    k: key3,
    a: null,
    // @ts-expect-error
    e: null,
    prev,
    next: next2
  };
  current_each_item = item;
  try {
    if (anchor === null) {
      var fragment = document.createDocumentFragment();
      fragment.append(anchor = create_text());
    }
    item.e = branch(() => render_fn(
      /** @type {Node} */
      anchor,
      v,
      i,
      get_collection
    ), hydrating);
    item.e.prev = prev && prev.e;
    item.e.next = next2 && next2.e;
    if (prev === null) {
      if (!deferred2) {
        state2.first = item;
      }
    } else {
      prev.next = item;
      prev.e.next = item.e;
    }
    if (next2 !== null) {
      next2.prev = item;
      next2.e.prev = item.e;
    }
    return item;
  } finally {
    current_each_item = previous_each_item;
  }
}
function move(item, next2, anchor) {
  var end = item.next ? (
    /** @type {TemplateNode} */
    item.next.e.nodes_start
  ) : anchor;
  var dest = next2 ? (
    /** @type {TemplateNode} */
    next2.e.nodes_start
  ) : anchor;
  var node = (
    /** @type {TemplateNode} */
    item.e.nodes_start
  );
  while (node !== null && node !== end) {
    var next_node = (
      /** @type {TemplateNode} */
      get_next_sibling(node)
    );
    dest.before(node);
    node = next_node;
  }
}
function link(state2, prev, next2) {
  if (prev === null) {
    state2.first = next2;
  } else {
    prev.next = next2;
    prev.e.next = next2 && next2.e;
  }
  if (next2 !== null) {
    next2.prev = prev;
    next2.e.prev = prev && prev.e;
  }
}

// node_modules/svelte/src/internal/client/dom/blocks/slot.js
function slot(anchor, $$props, name, slot_props, fallback_fn) {
  var _a3;
  if (hydrating) {
    hydrate_next();
  }
  var slot_fn = (_a3 = $$props.$$slots) == null ? void 0 : _a3[name];
  var is_interop = false;
  if (slot_fn === true) {
    slot_fn = $$props[name === "default" ? "children" : name];
    is_interop = true;
  }
  if (slot_fn === void 0) {
    if (fallback_fn !== null) {
      fallback_fn(anchor);
    }
  } else {
    slot_fn(anchor, is_interop ? () => slot_props : slot_props);
  }
}

// node_modules/svelte/src/internal/client/dom/blocks/snippet.js
function snippet(node, get_snippet, ...args) {
  var anchor = node;
  var snippet2 = noop;
  var snippet_effect;
  block(() => {
    if (snippet2 === (snippet2 = get_snippet())) return;
    if (snippet_effect) {
      destroy_effect(snippet_effect);
      snippet_effect = null;
    }
    if (dev_fallback_default && snippet2 == null) {
      invalid_snippet();
    }
    snippet_effect = branch(() => (
      /** @type {SnippetFn} */
      snippet2(anchor, ...args)
    ));
  }, EFFECT_TRANSPARENT);
  if (hydrating) {
    anchor = hydrate_node;
  }
}

// node_modules/svelte/src/internal/client/dom/blocks/svelte-component.js
function component(node, get_component, render_fn) {
  if (hydrating) {
    hydrate_next();
  }
  var anchor = node;
  var component2;
  var effect2;
  var offscreen_fragment = null;
  var pending_effect = null;
  function commit() {
    if (effect2) {
      pause_effect(effect2);
      effect2 = null;
    }
    if (offscreen_fragment) {
      offscreen_fragment.lastChild.remove();
      anchor.before(offscreen_fragment);
      offscreen_fragment = null;
    }
    effect2 = pending_effect;
    pending_effect = null;
  }
  block(() => {
    if (component2 === (component2 = get_component())) return;
    var defer = should_defer_append();
    if (component2) {
      var target = anchor;
      if (defer) {
        offscreen_fragment = document.createDocumentFragment();
        offscreen_fragment.append(target = create_text());
        if (effect2) {
          current_batch.skipped_effects.add(effect2);
        }
      }
      pending_effect = branch(() => render_fn(target, component2));
    }
    if (defer) {
      current_batch.add_callback(commit);
    } else {
      commit();
    }
  }, EFFECT_TRANSPARENT);
  if (hydrating) {
    anchor = hydrate_node;
  }
}

// node_modules/svelte/src/internal/client/dom/blocks/svelte-element.js
function element(node, get_tag, is_svg, render_fn, get_namespace, location) {
  var _a3;
  let was_hydrating = hydrating;
  if (hydrating) {
    hydrate_next();
  }
  var filename = dev_fallback_default && location && ((_a3 = component_context) == null ? void 0 : _a3.function[FILENAME]);
  var tag2;
  var current_tag;
  var element2 = null;
  if (hydrating && hydrate_node.nodeType === ELEMENT_NODE) {
    element2 = /** @type {Element} */
    hydrate_node;
    hydrate_next();
  }
  var anchor = (
    /** @type {TemplateNode} */
    hydrating ? hydrate_node : node
  );
  var effect2;
  var each_item_block = current_each_item;
  block(() => {
    const next_tag = get_tag() || null;
    var ns = get_namespace ? get_namespace() : is_svg || next_tag === "svg" ? NAMESPACE_SVG : null;
    if (next_tag === tag2) return;
    var previous_each_item = current_each_item;
    set_current_each_item(each_item_block);
    if (effect2) {
      if (next_tag === null) {
        pause_effect(effect2, () => {
          effect2 = null;
          current_tag = null;
        });
      } else if (next_tag === current_tag) {
        resume_effect(effect2);
      } else {
        destroy_effect(effect2);
        set_should_intro(false);
      }
    }
    if (next_tag && next_tag !== current_tag) {
      effect2 = branch(() => {
        element2 = hydrating ? (
          /** @type {Element} */
          element2
        ) : ns ? document.createElementNS(ns, next_tag) : document.createElement(next_tag);
        if (dev_fallback_default && location) {
          element2.__svelte_meta = {
            parent: dev_stack,
            loc: {
              file: filename,
              line: location[0],
              column: location[1]
            }
          };
        }
        assign_nodes(element2, element2);
        if (render_fn) {
          if (hydrating && is_raw_text_element(next_tag)) {
            element2.append(document.createComment(""));
          }
          var child_anchor = (
            /** @type {TemplateNode} */
            hydrating ? get_first_child(element2) : element2.appendChild(create_text())
          );
          if (hydrating) {
            if (child_anchor === null) {
              set_hydrating(false);
            } else {
              set_hydrate_node(child_anchor);
            }
          }
          render_fn(element2, child_anchor);
        }
        active_effect.nodes_end = element2;
        anchor.before(element2);
      });
    }
    tag2 = next_tag;
    if (tag2) current_tag = tag2;
    set_should_intro(true);
    set_current_each_item(previous_each_item);
  }, EFFECT_TRANSPARENT);
  if (was_hydrating) {
    set_hydrating(true);
    set_hydrate_node(anchor);
  }
}

// node_modules/svelte/src/internal/client/dom/css.js
function append_styles(anchor, css) {
  effect(() => {
    var _a3;
    var root37 = anchor.getRootNode();
    var target = (
      /** @type {ShadowRoot} */
      root37.host ? (
        /** @type {ShadowRoot} */
        root37
      ) : (
        /** @type {Document} */
        (_a3 = root37.head) != null ? _a3 : (
          /** @type {Document} */
          root37.ownerDocument.head
        )
      )
    );
    if (!target.querySelector("#" + css.hash)) {
      const style = document.createElement("style");
      style.id = css.hash;
      style.textContent = css.code;
      target.appendChild(style);
      if (dev_fallback_default) {
        register_style(css.hash, style);
      }
    }
  });
}

// node_modules/svelte/src/internal/client/dom/elements/actions.js
function action(dom, action2, get_value) {
  effect(() => {
    var payload = untrack(() => action2(dom, get_value == null ? void 0 : get_value()) || {});
    if (get_value && (payload == null ? void 0 : payload.update)) {
      var inited = false;
      var prev = (
        /** @type {any} */
        {}
      );
      render_effect(() => {
        var value = get_value();
        deep_read_state(value);
        if (inited && safe_not_equal(prev, value)) {
          prev = value;
          payload.update(value);
        }
      });
      inited = true;
    }
    if (payload == null ? void 0 : payload.destroy) {
      return () => (
        /** @type {Function} */
        payload.destroy()
      );
    }
  });
}

// node_modules/svelte/src/internal/client/dom/elements/attachments.js
function attach(node, get_fn) {
  var fn = void 0;
  var e;
  block(() => {
    if (fn !== (fn = get_fn())) {
      if (e) {
        destroy_effect(e);
        e = null;
      }
      if (fn) {
        e = branch(() => {
          effect(() => (
            /** @type {(node: Element) => void} */
            fn(node)
          ));
        });
      }
    }
  });
}

// node_modules/clsx/dist/clsx.mjs
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  } else for (f in e) e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}

// node_modules/svelte/src/internal/shared/attributes.js
function clsx2(value) {
  if (typeof value === "object") {
    return clsx(value);
  } else {
    return value != null ? value : "";
  }
}
var whitespace = [..." 	\n\r\f\xA0\v\uFEFF"];
function to_class(value, hash2, directives) {
  var classname = value == null ? "" : "" + value;
  if (hash2) {
    classname = classname ? classname + " " + hash2 : hash2;
  }
  if (directives) {
    for (var key3 in directives) {
      if (directives[key3]) {
        classname = classname ? classname + " " + key3 : key3;
      } else if (classname.length) {
        var len = key3.length;
        var a = 0;
        while ((a = classname.indexOf(key3, a)) >= 0) {
          var b = a + len;
          if ((a === 0 || whitespace.includes(classname[a - 1])) && (b === classname.length || whitespace.includes(classname[b]))) {
            classname = (a === 0 ? "" : classname.substring(0, a)) + classname.substring(b + 1);
          } else {
            a = b;
          }
        }
      }
    }
  }
  return classname === "" ? null : classname;
}
function append_styles2(styles, important = false) {
  var separator = important ? " !important;" : ";";
  var css = "";
  for (var key3 in styles) {
    var value = styles[key3];
    if (value != null && value !== "") {
      css += " " + key3 + ": " + value + separator;
    }
  }
  return css;
}
function to_css_name(name) {
  if (name[0] !== "-" || name[1] !== "-") {
    return name.toLowerCase();
  }
  return name;
}
function to_style(value, styles) {
  if (styles) {
    var new_style = "";
    var normal_styles;
    var important_styles;
    if (Array.isArray(styles)) {
      normal_styles = styles[0];
      important_styles = styles[1];
    } else {
      normal_styles = styles;
    }
    if (value) {
      value = String(value).replaceAll(/\s*\/\*.*?\*\/\s*/g, "").trim();
      var in_str = false;
      var in_apo = 0;
      var in_comment = false;
      var reserved_names = [];
      if (normal_styles) {
        reserved_names.push(...Object.keys(normal_styles).map(to_css_name));
      }
      if (important_styles) {
        reserved_names.push(...Object.keys(important_styles).map(to_css_name));
      }
      var start_index = 0;
      var name_index = -1;
      const len = value.length;
      for (var i = 0; i < len; i++) {
        var c = value[i];
        if (in_comment) {
          if (c === "/" && value[i - 1] === "*") {
            in_comment = false;
          }
        } else if (in_str) {
          if (in_str === c) {
            in_str = false;
          }
        } else if (c === "/" && value[i + 1] === "*") {
          in_comment = true;
        } else if (c === '"' || c === "'") {
          in_str = c;
        } else if (c === "(") {
          in_apo++;
        } else if (c === ")") {
          in_apo--;
        }
        if (!in_comment && in_str === false && in_apo === 0) {
          if (c === ":" && name_index === -1) {
            name_index = i;
          } else if (c === ";" || i === len - 1) {
            if (name_index !== -1) {
              var name = to_css_name(value.substring(start_index, name_index).trim());
              if (!reserved_names.includes(name)) {
                if (c !== ";") {
                  i++;
                }
                var property = value.substring(start_index, i).trim();
                new_style += " " + property + ";";
              }
            }
            start_index = i + 1;
            name_index = -1;
          }
        }
      }
    }
    if (normal_styles) {
      new_style += append_styles2(normal_styles);
    }
    if (important_styles) {
      new_style += append_styles2(important_styles, true);
    }
    new_style = new_style.trim();
    return new_style === "" ? null : new_style;
  }
  return value == null ? null : String(value);
}

// node_modules/svelte/src/internal/client/dom/elements/class.js
function set_class(dom, is_html, value, hash2, prev_classes, next_classes) {
  var prev = dom.__className;
  if (hydrating || prev !== value || prev === void 0) {
    var next_class_name = to_class(value, hash2, next_classes);
    if (!hydrating || next_class_name !== dom.getAttribute("class")) {
      if (next_class_name == null) {
        dom.removeAttribute("class");
      } else if (is_html) {
        dom.className = next_class_name;
      } else {
        dom.setAttribute("class", next_class_name);
      }
    }
    dom.__className = value;
  } else if (next_classes && prev_classes !== next_classes) {
    for (var key3 in next_classes) {
      var is_present = !!next_classes[key3];
      if (prev_classes == null || is_present !== !!prev_classes[key3]) {
        dom.classList.toggle(key3, is_present);
      }
    }
  }
  return next_classes;
}

// node_modules/svelte/src/internal/client/dom/elements/style.js
function update_styles(dom, prev = {}, next2, priority) {
  for (var key3 in next2) {
    var value = next2[key3];
    if (prev[key3] !== value) {
      if (next2[key3] == null) {
        dom.style.removeProperty(key3);
      } else {
        dom.style.setProperty(key3, value, priority);
      }
    }
  }
}
function set_style(dom, value, prev_styles, next_styles) {
  var prev = dom.__style;
  if (hydrating || prev !== value) {
    var next_style_attr = to_style(value, next_styles);
    if (!hydrating || next_style_attr !== dom.getAttribute("style")) {
      if (next_style_attr == null) {
        dom.removeAttribute("style");
      } else {
        dom.style.cssText = next_style_attr;
      }
    }
    dom.__style = value;
  } else if (next_styles) {
    if (Array.isArray(next_styles)) {
      update_styles(dom, prev_styles == null ? void 0 : prev_styles[0], next_styles[0]);
      update_styles(dom, prev_styles == null ? void 0 : prev_styles[1], next_styles[1], "important");
    } else {
      update_styles(dom, prev_styles, next_styles);
    }
  }
  return next_styles;
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/select.js
function select_option(select, value, mounting = false) {
  if (select.multiple) {
    if (value == void 0) {
      return;
    }
    if (!is_array(value)) {
      return select_multiple_invalid_value();
    }
    for (var option of select.options) {
      option.selected = value.includes(get_option_value(option));
    }
    return;
  }
  for (option of select.options) {
    var option_value = get_option_value(option);
    if (is(option_value, value)) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function init_select(select) {
  var observer = new MutationObserver(() => {
    select_option(select, select.__value);
  });
  observer.observe(select, {
    // Listen to option element changes
    childList: true,
    subtree: true,
    // because of <optgroup>
    // Listen to option element value attribute changes
    // (doesn't get notified of select value changes,
    // because that property is not reflected as an attribute)
    attributes: true,
    attributeFilter: ["value"]
  });
  teardown(() => {
    observer.disconnect();
  });
}
function get_option_value(option) {
  if ("__value" in option) {
    return option.__value;
  } else {
    return option.value;
  }
}

// node_modules/svelte/src/internal/client/dom/elements/attributes.js
var CLASS = Symbol("class");
var STYLE = Symbol("style");
var IS_CUSTOM_ELEMENT = Symbol("is custom element");
var IS_HTML = Symbol("is html");
function remove_input_defaults(input) {
  if (!hydrating) return;
  var already_removed = false;
  var remove_defaults = () => {
    if (already_removed) return;
    already_removed = true;
    if (input.hasAttribute("value")) {
      var value = input.value;
      set_attribute2(input, "value", null);
      input.value = value;
    }
    if (input.hasAttribute("checked")) {
      var checked = input.checked;
      set_attribute2(input, "checked", null);
      input.checked = checked;
    }
  };
  input.__on_r = remove_defaults;
  queue_micro_task(remove_defaults);
  add_form_reset_listener();
}
function set_selected(element2, selected) {
  if (selected) {
    if (!element2.hasAttribute("selected")) {
      element2.setAttribute("selected", "");
    }
  } else {
    element2.removeAttribute("selected");
  }
}
function set_attribute2(element2, attribute, value, skip_warning) {
  var attributes = get_attributes(element2);
  if (hydrating) {
    attributes[attribute] = element2.getAttribute(attribute);
    if (attribute === "src" || attribute === "srcset" || attribute === "href" && element2.nodeName === "LINK") {
      if (!skip_warning) {
        check_src_in_dev_hydration(element2, attribute, value != null ? value : "");
      }
      return;
    }
  }
  if (attributes[attribute] === (attributes[attribute] = value)) return;
  if (attribute === "loading") {
    element2[LOADING_ATTR_SYMBOL] = value;
  }
  if (value == null) {
    element2.removeAttribute(attribute);
  } else if (typeof value !== "string" && get_setters(element2).includes(attribute)) {
    element2[attribute] = value;
  } else {
    element2.setAttribute(attribute, value);
  }
}
function set_attributes(element2, prev, next2, css_hash, should_remove_defaults = false, skip_warning = false) {
  var _a3;
  if (hydrating && should_remove_defaults && element2.tagName === "INPUT") {
    var input = (
      /** @type {HTMLInputElement} */
      element2
    );
    var attribute = input.type === "checkbox" ? "defaultChecked" : "defaultValue";
    if (!(attribute in next2)) {
      remove_input_defaults(input);
    }
  }
  var attributes = get_attributes(element2);
  var is_custom_element = attributes[IS_CUSTOM_ELEMENT];
  var preserve_attribute_case = !attributes[IS_HTML];
  let is_hydrating_custom_element = hydrating && is_custom_element;
  if (is_hydrating_custom_element) {
    set_hydrating(false);
  }
  var current = prev || {};
  var is_option_element = element2.tagName === "OPTION";
  for (var key3 in prev) {
    if (!(key3 in next2)) {
      next2[key3] = null;
    }
  }
  if (next2.class) {
    next2.class = clsx2(next2.class);
  } else if (css_hash || next2[CLASS]) {
    next2.class = null;
  }
  if (next2[STYLE]) {
    (_a3 = next2.style) != null ? _a3 : next2.style = null;
  }
  var setters = get_setters(element2);
  for (const key4 in next2) {
    let value = next2[key4];
    if (is_option_element && key4 === "value" && value == null) {
      element2.value = element2.__value = "";
      current[key4] = value;
      continue;
    }
    if (key4 === "class") {
      var is_html = element2.namespaceURI === "http://www.w3.org/1999/xhtml";
      set_class(element2, is_html, value, css_hash, prev == null ? void 0 : prev[CLASS], next2[CLASS]);
      current[key4] = value;
      current[CLASS] = next2[CLASS];
      continue;
    }
    if (key4 === "style") {
      set_style(element2, value, prev == null ? void 0 : prev[STYLE], next2[STYLE]);
      current[key4] = value;
      current[STYLE] = next2[STYLE];
      continue;
    }
    var prev_value = current[key4];
    if (value === prev_value && !(value === void 0 && element2.hasAttribute(key4))) {
      continue;
    }
    current[key4] = value;
    var prefix = key4[0] + key4[1];
    if (prefix === "$$") continue;
    if (prefix === "on") {
      const opts = {};
      const event_handle_key = "$$" + key4;
      let event_name = key4.slice(2);
      var delegated = is_delegated(event_name);
      if (is_capture_event(event_name)) {
        event_name = event_name.slice(0, -7);
        opts.capture = true;
      }
      if (!delegated && prev_value) {
        if (value != null) continue;
        element2.removeEventListener(event_name, current[event_handle_key], opts);
        current[event_handle_key] = null;
      }
      if (value != null) {
        if (!delegated) {
          let handle = function(evt) {
            current[key4].call(this, evt);
          };
          current[event_handle_key] = create_event(event_name, element2, handle, opts);
        } else {
          element2[`__${event_name}`] = value;
          delegate([event_name]);
        }
      } else if (delegated) {
        element2[`__${event_name}`] = void 0;
      }
    } else if (key4 === "style") {
      set_attribute2(element2, key4, value);
    } else if (key4 === "autofocus") {
      autofocus(
        /** @type {HTMLElement} */
        element2,
        Boolean(value)
      );
    } else if (!is_custom_element && (key4 === "__value" || key4 === "value" && value != null)) {
      element2.value = element2.__value = value;
    } else if (key4 === "selected" && is_option_element) {
      set_selected(
        /** @type {HTMLOptionElement} */
        element2,
        value
      );
    } else {
      var name = key4;
      if (!preserve_attribute_case) {
        name = normalize_attribute(name);
      }
      var is_default = name === "defaultValue" || name === "defaultChecked";
      if (value == null && !is_custom_element && !is_default) {
        attributes[key4] = null;
        if (name === "value" || name === "checked") {
          let input2 = (
            /** @type {HTMLInputElement} */
            element2
          );
          const use_default = prev === void 0;
          if (name === "value") {
            let previous = input2.defaultValue;
            input2.removeAttribute(name);
            input2.defaultValue = previous;
            input2.value = input2.__value = use_default ? previous : null;
          } else {
            let previous = input2.defaultChecked;
            input2.removeAttribute(name);
            input2.defaultChecked = previous;
            input2.checked = use_default ? previous : false;
          }
        } else {
          element2.removeAttribute(key4);
        }
      } else if (is_default || setters.includes(name) && (is_custom_element || typeof value !== "string")) {
        element2[name] = value;
        if (name in attributes) attributes[name] = UNINITIALIZED;
      } else if (typeof value !== "function") {
        set_attribute2(element2, name, value, skip_warning);
      }
    }
  }
  if (is_hydrating_custom_element) {
    set_hydrating(true);
  }
  return current;
}
function attribute_effect(element2, fn, sync = [], async2 = [], css_hash, should_remove_defaults = false, skip_warning = false) {
  flatten(sync, async2, (values) => {
    var prev = void 0;
    var effects = {};
    var is_select = element2.nodeName === "SELECT";
    var inited = false;
    block(() => {
      var next2 = fn(...values.map(get));
      var current = set_attributes(
        element2,
        prev,
        next2,
        css_hash,
        should_remove_defaults,
        skip_warning
      );
      if (inited && is_select && "value" in next2) {
        select_option(
          /** @type {HTMLSelectElement} */
          element2,
          next2.value
        );
      }
      for (let symbol of Object.getOwnPropertySymbols(effects)) {
        if (!next2[symbol]) destroy_effect(effects[symbol]);
      }
      for (let symbol of Object.getOwnPropertySymbols(next2)) {
        var n = next2[symbol];
        if (symbol.description === ATTACHMENT_KEY && (!prev || n !== prev[symbol])) {
          if (effects[symbol]) destroy_effect(effects[symbol]);
          effects[symbol] = branch(() => attach(element2, () => n));
        }
        current[symbol] = n;
      }
      prev = current;
    });
    if (is_select) {
      var select = (
        /** @type {HTMLSelectElement} */
        element2
      );
      effect(() => {
        select_option(
          select,
          /** @type {Record<string | symbol, any>} */
          prev.value,
          true
        );
        init_select(select);
      });
    }
    inited = true;
  });
}
function get_attributes(element2) {
  var _a3;
  return (
    /** @type {Record<string | symbol, unknown>} **/
    // @ts-expect-error
    (_a3 = element2.__attributes) != null ? _a3 : element2.__attributes = {
      [IS_CUSTOM_ELEMENT]: element2.nodeName.includes("-"),
      [IS_HTML]: element2.namespaceURI === NAMESPACE_HTML
    }
  );
}
var setters_cache = /* @__PURE__ */ new Map();
function get_setters(element2) {
  var cache_key = element2.getAttribute("is") || element2.nodeName;
  var setters = setters_cache.get(cache_key);
  if (setters) return setters;
  setters_cache.set(cache_key, setters = []);
  var descriptors;
  var proto = element2;
  var element_proto = Element.prototype;
  while (element_proto !== proto) {
    descriptors = get_descriptors(proto);
    for (var key3 in descriptors) {
      if (descriptors[key3].set) {
        setters.push(key3);
      }
    }
    proto = get_prototype_of(proto);
  }
  return setters;
}
function check_src_in_dev_hydration(element2, attribute, value) {
  var _a3;
  if (!dev_fallback_default) return;
  if (attribute === "srcset" && srcset_url_equal(element2, value)) return;
  if (src_url_equal((_a3 = element2.getAttribute(attribute)) != null ? _a3 : "", value)) return;
  hydration_attribute_changed(
    attribute,
    element2.outerHTML.replace(element2.innerHTML, element2.innerHTML && "..."),
    String(value)
  );
}
function src_url_equal(element_src, url) {
  if (element_src === url) return true;
  return new URL(element_src, document.baseURI).href === new URL(url, document.baseURI).href;
}
function split_srcset(srcset) {
  return srcset.split(",").map((src) => src.trim().split(" ").filter(Boolean));
}
function srcset_url_equal(element2, srcset) {
  var element_urls = split_srcset(element2.srcset);
  var urls = split_srcset(srcset);
  return urls.length === element_urls.length && urls.every(
    ([url, width], i) => width === element_urls[i][1] && // We need to test both ways because Vite will create an a full URL with
    // `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the
    // relative URLs inside srcset are not automatically resolved to absolute URLs by
    // browsers (in contrast to img.src). This means both SSR and DOM code could
    // contain relative or absolute URLs.
    (src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))
  );
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/input.js
function bind_value(input, get5, set4 = get5) {
  var batches2 = /* @__PURE__ */ new WeakSet();
  listen_to_event_and_reset_event(input, "input", async (is_reset) => {
    if (dev_fallback_default && input.type === "checkbox") {
      bind_invalid_checkbox_value();
    }
    var value = is_reset ? input.defaultValue : input.value;
    value = is_numberlike_input(input) ? to_number(value) : value;
    set4(value);
    if (current_batch !== null) {
      batches2.add(current_batch);
    }
    await tick();
    if (value !== (value = get5())) {
      var start2 = input.selectionStart;
      var end = input.selectionEnd;
      var length = input.value.length;
      input.value = value != null ? value : "";
      if (end !== null) {
        var new_length = input.value.length;
        if (start2 === end && end === length && new_length > length) {
          input.selectionStart = new_length;
          input.selectionEnd = new_length;
        } else {
          input.selectionStart = start2;
          input.selectionEnd = Math.min(end, new_length);
        }
      }
    }
  });
  if (
    // If we are hydrating and the value has since changed,
    // then use the updated value from the input instead.
    hydrating && input.defaultValue !== input.value || // If defaultValue is set, then value == defaultValue
    // TODO Svelte 6: remove input.value check and set to empty string?
    untrack(get5) == null && input.value
  ) {
    set4(is_numberlike_input(input) ? to_number(input.value) : input.value);
    if (current_batch !== null) {
      batches2.add(current_batch);
    }
  }
  render_effect(() => {
    var _a3;
    if (dev_fallback_default && input.type === "checkbox") {
      bind_invalid_checkbox_value();
    }
    var value = get5();
    if (input === document.activeElement) {
      var batch = (
        /** @type {Batch} */
        (_a3 = previous_batch) != null ? _a3 : current_batch
      );
      if (batches2.has(batch)) {
        return;
      }
    }
    if (is_numberlike_input(input) && value === to_number(input.value)) {
      return;
    }
    if (input.type === "date" && !value && !input.value) {
      return;
    }
    if (value !== input.value) {
      input.value = value != null ? value : "";
    }
  });
}
function bind_checked(input, get5, set4 = get5) {
  listen_to_event_and_reset_event(input, "change", (is_reset) => {
    var value = is_reset ? input.defaultChecked : input.checked;
    set4(value);
  });
  if (
    // If we are hydrating and the value has since changed,
    // then use the update value from the input instead.
    hydrating && input.defaultChecked !== input.checked || // If defaultChecked is set, then checked == defaultChecked
    untrack(get5) == null
  ) {
    set4(input.checked);
  }
  render_effect(() => {
    var value = get5();
    input.checked = Boolean(value);
  });
}
function is_numberlike_input(input) {
  var type = input.type;
  return type === "number" || type === "range";
}
function to_number(value) {
  return value === "" ? null : +value;
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/size.js
var _listeners, _observer, _options, _ResizeObserverSingleton_instances, getObserver_fn;
var _ResizeObserverSingleton = class _ResizeObserverSingleton {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    __privateAdd(this, _ResizeObserverSingleton_instances);
    /** */
    __privateAdd(this, _listeners, /* @__PURE__ */ new WeakMap());
    /** @type {ResizeObserver | undefined} */
    __privateAdd(this, _observer);
    /** @type {ResizeObserverOptions} */
    __privateAdd(this, _options);
    __privateSet(this, _options, options);
  }
  /**
   * @param {Element} element
   * @param {(entry: ResizeObserverEntry) => any} listener
   */
  observe(element2, listener) {
    var listeners = __privateGet(this, _listeners).get(element2) || /* @__PURE__ */ new Set();
    listeners.add(listener);
    __privateGet(this, _listeners).set(element2, listeners);
    __privateMethod(this, _ResizeObserverSingleton_instances, getObserver_fn).call(this).observe(element2, __privateGet(this, _options));
    return () => {
      var listeners2 = __privateGet(this, _listeners).get(element2);
      listeners2.delete(listener);
      if (listeners2.size === 0) {
        __privateGet(this, _listeners).delete(element2);
        __privateGet(this, _observer).unobserve(element2);
      }
    };
  }
};
_listeners = new WeakMap();
_observer = new WeakMap();
_options = new WeakMap();
_ResizeObserverSingleton_instances = new WeakSet();
getObserver_fn = function() {
  var _a3;
  return (_a3 = __privateGet(this, _observer)) != null ? _a3 : __privateSet(this, _observer, new ResizeObserver(
    /** @param {any} entries */
    (entries) => {
      for (var entry of entries) {
        _ResizeObserverSingleton.entries.set(entry.target, entry);
        for (var listener of __privateGet(this, _listeners).get(entry.target) || []) {
          listener(entry);
        }
      }
    }
  ));
};
/** @static */
__publicField(_ResizeObserverSingleton, "entries", /* @__PURE__ */ new WeakMap());
var ResizeObserverSingleton = _ResizeObserverSingleton;
var resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({
  box: "border-box"
});
function bind_element_size(element2, type, set4) {
  var unsub = resize_observer_border_box.observe(element2, () => set4(element2[type]));
  effect(() => {
    untrack(() => set4(element2[type]));
    return unsub;
  });
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/this.js
function is_bound_this(bound_value, element_or_component) {
  return bound_value === element_or_component || (bound_value == null ? void 0 : bound_value[STATE_SYMBOL]) === element_or_component;
}
function bind_this(element_or_component = {}, update2, get_value, get_parts) {
  effect(() => {
    var old_parts;
    var parts;
    render_effect(() => {
      old_parts = parts;
      parts = (get_parts == null ? void 0 : get_parts()) || [];
      untrack(() => {
        if (element_or_component !== get_value(...parts)) {
          update2(element_or_component, ...parts);
          if (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) {
            update2(null, ...old_parts);
          }
        }
      });
    });
    return () => {
      queue_micro_task(() => {
        if (parts && is_bound_this(get_value(...parts), element_or_component)) {
          update2(null, ...parts);
        }
      });
    };
  });
  return element_or_component;
}

// node_modules/svelte/src/internal/client/dom/legacy/lifecycle.js
function init(immutable = false) {
  const context = (
    /** @type {ComponentContextLegacy} */
    component_context
  );
  const callbacks = context.l.u;
  if (!callbacks) return;
  let props = () => deep_read_state(context.s);
  if (immutable) {
    let version = 0;
    let prev = (
      /** @type {Record<string, any>} */
      {}
    );
    const d = derived(() => {
      let changed = false;
      const props2 = context.s;
      for (const key3 in props2) {
        if (props2[key3] !== prev[key3]) {
          prev[key3] = props2[key3];
          changed = true;
        }
      }
      if (changed) version++;
      return version;
    });
    props = () => get(d);
  }
  if (callbacks.b.length) {
    user_pre_effect(() => {
      observe_all(context, props);
      run_all(callbacks.b);
    });
  }
  user_effect(() => {
    const fns = untrack(() => callbacks.m.map(run));
    return () => {
      for (const fn of fns) {
        if (typeof fn === "function") {
          fn();
        }
      }
    };
  });
  if (callbacks.a.length) {
    user_effect(() => {
      observe_all(context, props);
      run_all(callbacks.a);
    });
  }
}
function observe_all(context, props) {
  if (context.l.s) {
    for (const signal of context.l.s) get(signal);
  }
  props();
}

// node_modules/svelte/src/internal/client/reactivity/store.js
var is_store_binding = false;
var IS_UNMOUNTED = Symbol();
function capture_store_binding(fn) {
  var previous_is_store_binding = is_store_binding;
  try {
    is_store_binding = false;
    return [fn(), is_store_binding];
  } finally {
    is_store_binding = previous_is_store_binding;
  }
}

// node_modules/svelte/src/internal/client/reactivity/props.js
var rest_props_handler = {
  get(target, key3) {
    if (target.exclude.includes(key3)) return;
    return target.props[key3];
  },
  set(target, key3) {
    if (dev_fallback_default) {
      props_rest_readonly(`${target.name}.${String(key3)}`);
    }
    return false;
  },
  getOwnPropertyDescriptor(target, key3) {
    if (target.exclude.includes(key3)) return;
    if (key3 in target.props) {
      return {
        enumerable: true,
        configurable: true,
        value: target.props[key3]
      };
    }
  },
  has(target, key3) {
    if (target.exclude.includes(key3)) return false;
    return key3 in target.props;
  },
  ownKeys(target) {
    return Reflect.ownKeys(target.props).filter((key3) => !target.exclude.includes(key3));
  }
};
// @__NO_SIDE_EFFECTS__
function rest_props(props, exclude, name) {
  return new Proxy(
    dev_fallback_default ? { props, exclude, name, other: {}, to_proxy: [] } : { props, exclude },
    rest_props_handler
  );
}
var legacy_rest_props_handler = {
  get(target, key3) {
    if (target.exclude.includes(key3)) return;
    get(target.version);
    return key3 in target.special ? target.special[key3]() : target.props[key3];
  },
  set(target, key3, value) {
    if (!(key3 in target.special)) {
      var previous_effect = active_effect;
      try {
        set_active_effect(target.parent_effect);
        target.special[key3] = prop(
          {
            get [key3]() {
              return target.props[key3];
            }
          },
          /** @type {string} */
          key3,
          PROPS_IS_UPDATED
        );
      } finally {
        set_active_effect(previous_effect);
      }
    }
    target.special[key3](value);
    update(target.version);
    return true;
  },
  getOwnPropertyDescriptor(target, key3) {
    if (target.exclude.includes(key3)) return;
    if (key3 in target.props) {
      return {
        enumerable: true,
        configurable: true,
        value: target.props[key3]
      };
    }
  },
  deleteProperty(target, key3) {
    if (target.exclude.includes(key3)) return true;
    target.exclude.push(key3);
    update(target.version);
    return true;
  },
  has(target, key3) {
    if (target.exclude.includes(key3)) return false;
    return key3 in target.props;
  },
  ownKeys(target) {
    return Reflect.ownKeys(target.props).filter((key3) => !target.exclude.includes(key3));
  }
};
function legacy_rest_props(props, exclude) {
  return new Proxy(
    {
      props,
      exclude,
      special: {},
      version: source(0),
      // TODO this is only necessary because we need to track component
      // destruction inside `prop`, because of `bind:this`, but it
      // seems likely that we can simplify `bind:this` instead
      parent_effect: (
        /** @type {Effect} */
        active_effect
      )
    },
    legacy_rest_props_handler
  );
}
var spread_props_handler = {
  get(target, key3) {
    let i = target.props.length;
    while (i--) {
      let p = target.props[i];
      if (is_function(p)) p = p();
      if (typeof p === "object" && p !== null && key3 in p) return p[key3];
    }
  },
  set(target, key3, value) {
    let i = target.props.length;
    while (i--) {
      let p = target.props[i];
      if (is_function(p)) p = p();
      const desc = get_descriptor(p, key3);
      if (desc && desc.set) {
        desc.set(value);
        return true;
      }
    }
    return false;
  },
  getOwnPropertyDescriptor(target, key3) {
    let i = target.props.length;
    while (i--) {
      let p = target.props[i];
      if (is_function(p)) p = p();
      if (typeof p === "object" && p !== null && key3 in p) {
        const descriptor = get_descriptor(p, key3);
        if (descriptor && !descriptor.configurable) {
          descriptor.configurable = true;
        }
        return descriptor;
      }
    }
  },
  has(target, key3) {
    if (key3 === STATE_SYMBOL || key3 === LEGACY_PROPS) return false;
    for (let p of target.props) {
      if (is_function(p)) p = p();
      if (p != null && key3 in p) return true;
    }
    return false;
  },
  ownKeys(target) {
    const keys = [];
    for (let p of target.props) {
      if (is_function(p)) p = p();
      if (!p) continue;
      for (const key3 in p) {
        if (!keys.includes(key3)) keys.push(key3);
      }
      for (const key3 of Object.getOwnPropertySymbols(p)) {
        if (!keys.includes(key3)) keys.push(key3);
      }
    }
    return keys;
  }
};
function spread_props(...props) {
  return new Proxy({ props }, spread_props_handler);
}
function prop(props, key3, flags2, fallback2) {
  var _a3, _b3;
  var runes = !legacy_mode_flag || (flags2 & PROPS_IS_RUNES) !== 0;
  var bindable = (flags2 & PROPS_IS_BINDABLE) !== 0;
  var lazy = (flags2 & PROPS_IS_LAZY_INITIAL) !== 0;
  var fallback_value = (
    /** @type {V} */
    fallback2
  );
  var fallback_dirty = true;
  var get_fallback = () => {
    if (fallback_dirty) {
      fallback_dirty = false;
      fallback_value = lazy ? untrack(
        /** @type {() => V} */
        fallback2
      ) : (
        /** @type {V} */
        fallback2
      );
    }
    return fallback_value;
  };
  var setter;
  if (bindable) {
    var is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;
    setter = (_b3 = (_a3 = get_descriptor(props, key3)) == null ? void 0 : _a3.set) != null ? _b3 : is_entry_props && key3 in props ? (v) => props[key3] = v : void 0;
  }
  var initial_value;
  var is_store_sub = false;
  if (bindable) {
    [initial_value, is_store_sub] = capture_store_binding(() => (
      /** @type {V} */
      props[key3]
    ));
  } else {
    initial_value = /** @type {V} */
    props[key3];
  }
  if (initial_value === void 0 && fallback2 !== void 0) {
    initial_value = get_fallback();
    if (setter) {
      if (runes) props_invalid_value(key3);
      setter(initial_value);
    }
  }
  var getter;
  if (runes) {
    getter = () => {
      var value = (
        /** @type {V} */
        props[key3]
      );
      if (value === void 0) return get_fallback();
      fallback_dirty = true;
      return value;
    };
  } else {
    getter = () => {
      var value = (
        /** @type {V} */
        props[key3]
      );
      if (value !== void 0) {
        fallback_value = /** @type {V} */
        void 0;
      }
      return value === void 0 ? fallback_value : value;
    };
  }
  if (runes && (flags2 & PROPS_IS_UPDATED) === 0) {
    return getter;
  }
  if (setter) {
    var legacy_parent = props.$$legacy;
    return (
      /** @type {() => V} */
      (function(value, mutation) {
        if (arguments.length > 0) {
          if (!runes || !mutation || legacy_parent || is_store_sub) {
            setter(mutation ? getter() : value);
          }
          return value;
        }
        return getter();
      })
    );
  }
  var overridden = false;
  var d = ((flags2 & PROPS_IS_IMMUTABLE) !== 0 ? derived : derived_safe_equal)(() => {
    overridden = false;
    return getter();
  });
  if (dev_fallback_default) {
    d.label = key3;
  }
  if (bindable) get(d);
  var parent_effect = (
    /** @type {Effect} */
    active_effect
  );
  return (
    /** @type {() => V} */
    (function(value, mutation) {
      if (arguments.length > 0) {
        const new_value = mutation ? get(d) : runes && bindable ? proxy(value) : value;
        set(d, new_value);
        overridden = true;
        if (fallback_value !== void 0) {
          fallback_value = new_value;
        }
        return value;
      }
      if (is_destroying_effect && overridden || (parent_effect.f & DESTROYED) !== 0) {
        return d.v;
      }
      return get(d);
    })
  );
}

// node_modules/svelte/src/legacy/legacy-client.js
function createClassComponent(options) {
  return new Svelte4Component(options);
}
var _events, _instance;
var Svelte4Component = class {
  /**
   * @param {ComponentConstructorOptions & {
   *  component: any;
   * }} options
   */
  constructor(options) {
    /** @type {any} */
    __privateAdd(this, _events);
    /** @type {Record<string, any>} */
    __privateAdd(this, _instance);
    var _a3, _b3;
    var sources = /* @__PURE__ */ new Map();
    var add_source = (key3, value) => {
      var s = mutable_source(value, false, false);
      sources.set(key3, s);
      return s;
    };
    const props = new Proxy(
      { ...options.props || {}, $$events: {} },
      {
        get(target, prop2) {
          var _a4;
          return get((_a4 = sources.get(prop2)) != null ? _a4 : add_source(prop2, Reflect.get(target, prop2)));
        },
        has(target, prop2) {
          var _a4;
          if (prop2 === LEGACY_PROPS) return true;
          get((_a4 = sources.get(prop2)) != null ? _a4 : add_source(prop2, Reflect.get(target, prop2)));
          return Reflect.has(target, prop2);
        },
        set(target, prop2, value) {
          var _a4;
          set((_a4 = sources.get(prop2)) != null ? _a4 : add_source(prop2, value), value);
          return Reflect.set(target, prop2, value);
        }
      }
    );
    __privateSet(this, _instance, (options.hydrate ? hydrate : mount)(options.component, {
      target: options.target,
      anchor: options.anchor,
      props,
      context: options.context,
      intro: (_a3 = options.intro) != null ? _a3 : false,
      recover: options.recover
    }));
    if (!async_mode_flag && (!((_b3 = options == null ? void 0 : options.props) == null ? void 0 : _b3.$$host) || options.sync === false)) {
      flushSync();
    }
    __privateSet(this, _events, props.$$events);
    for (const key3 of Object.keys(__privateGet(this, _instance))) {
      if (key3 === "$set" || key3 === "$destroy" || key3 === "$on") continue;
      define_property(this, key3, {
        get() {
          return __privateGet(this, _instance)[key3];
        },
        /** @param {any} value */
        set(value) {
          __privateGet(this, _instance)[key3] = value;
        },
        enumerable: true
      });
    }
    __privateGet(this, _instance).$set = /** @param {Record<string, any>} next */
    (next2) => {
      Object.assign(props, next2);
    };
    __privateGet(this, _instance).$destroy = () => {
      unmount(__privateGet(this, _instance));
    };
  }
  /** @param {Record<string, any>} props */
  $set(props) {
    __privateGet(this, _instance).$set(props);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(event2, callback) {
    __privateGet(this, _events)[event2] = __privateGet(this, _events)[event2] || [];
    const cb = (...args) => callback.call(this, ...args);
    __privateGet(this, _events)[event2].push(cb);
    return () => {
      __privateGet(this, _events)[event2] = __privateGet(this, _events)[event2].filter(
        /** @param {any} fn */
        (fn) => fn !== cb
      );
    };
  }
  $destroy() {
    __privateGet(this, _instance).$destroy();
  }
};
_events = new WeakMap();
_instance = new WeakMap();

// node_modules/svelte/src/internal/client/dom/elements/custom-element.js
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    /**
     * @param {*} $$componentCtor
     * @param {*} $$slots
     * @param {*} use_shadow_dom
     */
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** @type {any} The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** @type {Record<string, any>} Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      /** @type {any} The managed render effect for reflecting attributes */
      __publicField(this, "$$me");
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    /**
     * @param {string} type
     * @param {EventListenerOrEventListenerObject} listener
     * @param {boolean | AddEventListenerOptions} [options]
     */
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    /**
     * @param {string} type
     * @param {EventListenerOrEventListenerObject} listener
     * @param {boolean | AddEventListenerOptions} [options]
     */
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot = function(name) {
          return (anchor) => {
            const slot2 = document.createElement("slot");
            if (name !== "default") slot2.name = name;
            append(anchor, slot2);
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            if (name === "default" && !this.$$d.children) {
              this.$$d.children = create_slot(name);
              $$slots.default = true;
            } else {
              $$slots[name] = create_slot(name);
            }
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key3 in this.$$p_d) {
          if (!(key3 in this.$$d) && this[key3] !== void 0) {
            this.$$d[key3] = this[key3];
            delete this[key3];
          }
        }
        this.$$c = createClassComponent({
          component: this.$$ctor,
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$host: this
          }
        });
        this.$$me = effect_root(() => {
          render_effect(() => {
            var _a3;
            this.$$r = true;
            for (const key3 of object_keys(this.$$c)) {
              if (!((_a3 = this.$$p_d[key3]) == null ? void 0 : _a3.reflect)) continue;
              this.$$d[key3] = this.$$c[key3];
              const attribute_value = get_custom_element_value(
                key3,
                this.$$d[key3],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key3].attribute || key3);
              } else {
                this.setAttribute(this.$$p_d[key3].attribute || key3, attribute_value);
              }
            }
            this.$$r = false;
          });
        });
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    /**
     * @param {string} attr
     * @param {string} _oldValue
     * @param {string} newValue
     */
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a3;
      if (this.$$r) return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a3 = this.$$c) == null ? void 0 : _a3.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn && this.$$c) {
          this.$$c.$destroy();
          this.$$me();
          this.$$c = void 0;
        }
      });
    }
    /**
     * @param {string} attribute_name
     */
    $$g_p(attribute_name) {
      return object_keys(this.$$p_d).find(
        (key3) => this.$$p_d[key3].attribute === attribute_name || !this.$$p_d[key3].attribute && key3.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop2, value, props_definition, transform2) {
  var _a3;
  const type = (_a3 = props_definition[prop2]) == null ? void 0 : _a3.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform2 || !props_definition[prop2]) {
    return value;
  } else if (transform2 === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      // conversion already handled above
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach((node) => {
    result[
      /** @type {Element} node */
      node.slot || "default"
    ] = true;
  });
  return result;
}

// node_modules/svelte/src/index-client.js
if (dev_fallback_default) {
  let throw_rune_error = function(rune) {
    if (!(rune in globalThis)) {
      let value;
      Object.defineProperty(globalThis, rune, {
        configurable: true,
        // eslint-disable-next-line getter-return
        get: () => {
          if (value !== void 0) {
            return value;
          }
          rune_outside_svelte(rune);
        },
        set: (v) => {
          value = v;
        }
      });
    }
  };
  throw_rune_error("$state");
  throw_rune_error("$effect");
  throw_rune_error("$derived");
  throw_rune_error("$inspect");
  throw_rune_error("$props");
  throw_rune_error("$bindable");
}
function onMount(fn) {
  if (component_context === null) {
    lifecycle_outside_component("onMount");
  }
  if (legacy_mode_flag && component_context.l !== null) {
    init_update_callbacks(component_context).m.push(fn);
  } else {
    user_effect(() => {
      const cleanup = untrack(fn);
      if (typeof cleanup === "function") return (
        /** @type {() => void} */
        cleanup
      );
    });
  }
}
function onDestroy(fn) {
  if (component_context === null) {
    lifecycle_outside_component("onDestroy");
  }
  onMount(() => () => untrack(fn));
}
function init_update_callbacks(context) {
  var _a3;
  var l = (
    /** @type {ComponentContextLegacy} */
    context.l
  );
  return (_a3 = l.u) != null ? _a3 : l.u = { a: [], b: [], m: [] };
}

// node_modules/svelte/src/version.js
var PUBLIC_VERSION = "5";

// node_modules/svelte/src/internal/disclose-version.js
var _a2, _b2, _c;
if (typeof window !== "undefined") {
  ((_c = (_b2 = (_a2 = window.__svelte) != null ? _a2 : window.__svelte = {}).v) != null ? _c : _b2.v = /* @__PURE__ */ new Set()).add(PUBLIC_VERSION);
}

// node_modules/d3-dispatch/src/dispatch.js
var noop2 = { value: () => {
} };
function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return { type: t, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._, T = parseTypenames(typename + "", _), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get3(_[t], typename.name))) return t;
      return;
    }
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set2(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set2(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};
function get3(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}
function set2(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop2, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({ name, value: callback });
  return type;
}
var dispatch_default = dispatch;

// node_modules/d3-selection/src/namespaces.js
var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces_default = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

// node_modules/d3-selection/src/namespace.js
function namespace_default(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;
}

// node_modules/d3-selection/src/creator.js
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator_default(name) {
  var fullname = namespace_default(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}

// node_modules/d3-selection/src/selector.js
function none() {
}
function selector_default(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

// node_modules/d3-selection/src/selection/select.js
function select_default(select) {
  if (typeof select !== "function") select = selector_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/array.js
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}

// node_modules/d3-selection/src/selectorAll.js
function empty2() {
  return [];
}
function selectorAll_default(selector) {
  return selector == null ? empty2 : function() {
    return this.querySelectorAll(selector);
  };
}

// node_modules/d3-selection/src/selection/selectAll.js
function arrayAll(select) {
  return function() {
    return array(select.apply(this, arguments));
  };
}
function selectAll_default(select) {
  if (typeof select === "function") select = arrayAll(select);
  else select = selectorAll_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }
  return new Selection(subgroups, parents);
}

// node_modules/d3-selection/src/matcher.js
function matcher_default(selector) {
  return function() {
    return this.matches(selector);
  };
}
function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}

// node_modules/d3-selection/src/selection/selectChild.js
var find = Array.prototype.find;
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selectChild_default(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/selectChildren.js
var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}
function selectChildren_default(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/filter.js
function filter_default(match) {
  if (typeof match !== "function") match = matcher_default(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/selection/sparse.js
function sparse_default(update2) {
  return new Array(update2.length);
}

// node_modules/d3-selection/src/selection/enter.js
function enter_default() {
  return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child2) {
    return this._parent.insertBefore(child2, this._next);
  },
  insertBefore: function(child2, next2) {
    return this._parent.insertBefore(child2, next2);
  },
  querySelector: function(selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function(selector) {
    return this._parent.querySelectorAll(selector);
  }
};

// node_modules/d3-selection/src/constant.js
function constant_default(x) {
  return function() {
    return x;
  };
}

// node_modules/d3-selection/src/selection/data.js
function bindIndex(parent, group, enter, update2, exit, data) {
  var i = 0, node, groupLength = group.length, dataLength = data.length;
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update2[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}
function bindKey(parent, group, enter, update2, exit, data, key3) {
  var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key3.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = key3.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update2[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
      exit[i] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function data_default(value, key3) {
  if (!arguments.length) return Array.from(this, datum);
  var bind = key3 ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  if (typeof value !== "function") value = constant_default(value);
  for (var m = groups.length, update2 = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j], group = groups[j], groupLength = group.length, data = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update2[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key3);
    for (var i0 = 0, i1 = 0, previous, next2; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next2 = updateGroup[i1]) && ++i1 < dataLength) ;
        previous._next = next2 || null;
      }
    }
  }
  update2 = new Selection(update2, parents);
  update2._enter = enter;
  update2._exit = exit;
  return update2;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}

// node_modules/d3-selection/src/selection/exit.js
function exit_default() {
  return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
}

// node_modules/d3-selection/src/selection/join.js
function join_default(onenter, onupdate, onexit) {
  var enter = this.enter(), update2 = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update2 = onupdate(update2);
    if (update2) update2 = update2.selection();
  }
  if (onexit == null) exit.remove();
  else onexit(exit);
  return enter && update2 ? enter.merge(update2).order() : update2;
}

// node_modules/d3-selection/src/selection/merge.js
function merge_default(context) {
  var selection2 = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection(merges, this._parents);
}

// node_modules/d3-selection/src/selection/order.js
function order_default() {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
    for (var group = groups[j], i = group.length - 1, next2 = group[i], node; --i >= 0; ) {
      if (node = group[i]) {
        if (next2 && node.compareDocumentPosition(next2) ^ 4) next2.parentNode.insertBefore(node, next2);
        next2 = node;
      }
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/sort.js
function sort_default(compare) {
  if (!compare) compare = ascending;
  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }
  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// node_modules/d3-selection/src/selection/call.js
function call_default() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

// node_modules/d3-selection/src/selection/nodes.js
function nodes_default() {
  return Array.from(this);
}

// node_modules/d3-selection/src/selection/node.js
function node_default() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }
  return null;
}

// node_modules/d3-selection/src/selection/size.js
function size_default() {
  let size = 0;
  for (const node of this) ++size;
  return size;
}

// node_modules/d3-selection/src/selection/empty.js
function empty_default() {
  return !this.node();
}

// node_modules/d3-selection/src/selection/each.js
function each_default(callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/attr.js
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}
function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function attr_default(name, value) {
  var fullname = namespace_default(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
}

// node_modules/d3-selection/src/window.js
function window_default(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}

// node_modules/d3-selection/src/selection/style.js
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}
function style_default(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);
}

// node_modules/d3-selection/src/selection/property.js
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}
function property_default(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}

// node_modules/d3-selection/src/selection/classed.js
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}
function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function classed_default(name, value) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}

// node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
function text_default(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
}

// node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
function html_default(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}

// node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}
function raise_default() {
  return this.each(raise);
}

// node_modules/d3-selection/src/selection/lower.js
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function lower_default() {
  return this.each(lower);
}

// node_modules/d3-selection/src/selection/append.js
function append_default(name) {
  var create2 = typeof name === "function" ? name : creator_default(name);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}

// node_modules/d3-selection/src/selection/insert.js
function constantNull() {
  return null;
}
function insert_default(name, before) {
  var create2 = typeof name === "function" ? name : creator_default(name), select = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

// node_modules/d3-selection/src/selection/remove.js
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}
function remove_default() {
  return this.each(remove);
}

// node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  var clone2 = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
}
function selection_cloneDeep() {
  var clone2 = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
}
function clone_default(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

// node_modules/d3-selection/src/selection/datum.js
function datum_default(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}

// node_modules/d3-selection/src/selection/on.js
function contextListener(listener) {
  return function(event2) {
    listener.call(this, event2, this.__data__);
  };
}
function parseTypenames2(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return { type: t, name };
  });
}
function onRemove(typename) {
  return function() {
    var on2 = this.__on;
    if (!on2) return;
    for (var j = 0, i = -1, m = on2.length, o; j < m; ++j) {
      if (o = on2[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on2[++i] = o;
      }
    }
    if (++i) on2.length = i;
    else delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on2 = this.__on, o, listener = contextListener(value);
    if (on2) for (var j = 0, m = on2.length; j < m; ++j) {
      if ((o = on2[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
        this.addEventListener(o.type, o.listener = listener, o.options = options);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o = { type: typename.type, name: typename.name, value, listener, options };
    if (!on2) this.__on = [o];
    else on2.push(o);
  };
}
function on_default(typename, value, options) {
  var typenames = parseTypenames2(typename + ""), i, n = typenames.length, t;
  if (arguments.length < 2) {
    var on2 = this.node().__on;
    if (on2) for (var j = 0, m = on2.length, o; j < m; ++j) {
      for (i = 0, o = on2[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }
  on2 = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on2(typenames[i], value, options));
  return this;
}

// node_modules/d3-selection/src/selection/dispatch.js
function dispatchEvent(node, type, params) {
  var window2 = window_default(node), event2 = window2.CustomEvent;
  if (typeof event2 === "function") {
    event2 = new event2(type, params);
  } else {
    event2 = window2.document.createEvent("Event");
    if (params) event2.initEvent(type, params.bubbles, params.cancelable), event2.detail = params.detail;
    else event2.initEvent(type, false, false);
  }
  node.dispatchEvent(event2);
}
function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}
function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}
function dispatch_default2(type, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
}

// node_modules/d3-selection/src/selection/iterator.js
function* iterator_default() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) yield node;
    }
  }
}

// node_modules/d3-selection/src/selection/index.js
var root = [null];
function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection() {
  return new Selection([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: select_default,
  selectAll: selectAll_default,
  selectChild: selectChild_default,
  selectChildren: selectChildren_default,
  filter: filter_default,
  data: data_default,
  enter: enter_default,
  exit: exit_default,
  join: join_default,
  merge: merge_default,
  selection: selection_selection,
  order: order_default,
  sort: sort_default,
  call: call_default,
  nodes: nodes_default,
  node: node_default,
  size: size_default,
  empty: empty_default,
  each: each_default,
  attr: attr_default,
  style: style_default,
  property: property_default,
  classed: classed_default,
  text: text_default,
  html: html_default,
  raise: raise_default,
  lower: lower_default,
  append: append_default,
  insert: insert_default,
  remove: remove_default,
  clone: clone_default,
  datum: datum_default,
  on: on_default,
  dispatch: dispatch_default2,
  [Symbol.iterator]: iterator_default
};
var selection_default = selection;

// node_modules/d3-selection/src/select.js
function select_default2(selector) {
  return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
}

// node_modules/d3-selection/src/sourceEvent.js
function sourceEvent_default(event2) {
  let sourceEvent;
  while (sourceEvent = event2.sourceEvent) event2 = sourceEvent;
  return event2;
}

// node_modules/d3-selection/src/pointer.js
function pointer_default(event2, node) {
  event2 = sourceEvent_default(event2);
  if (node === void 0) node = event2.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event2.clientX, point.y = event2.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event2.clientX - rect.left - node.clientLeft, event2.clientY - rect.top - node.clientTop];
    }
  }
  return [event2.pageX, event2.pageY];
}

// node_modules/d3-drag/src/noevent.js
var nonpassive2 = { passive: false };
var nonpassivecapture = { capture: true, passive: false };
function nopropagation(event2) {
  event2.stopImmediatePropagation();
}
function noevent_default(event2) {
  event2.preventDefault();
  event2.stopImmediatePropagation();
}

// node_modules/d3-drag/src/nodrag.js
function nodrag_default(view) {
  var root37 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", noevent_default, nonpassivecapture);
  if ("onselectstart" in root37) {
    selection2.on("selectstart.drag", noevent_default, nonpassivecapture);
  } else {
    root37.__noselect = root37.style.MozUserSelect;
    root37.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root37 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", null);
  if (noclick) {
    selection2.on("click.drag", noevent_default, nonpassivecapture);
    setTimeout(function() {
      selection2.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root37) {
    selection2.on("selectstart.drag", null);
  } else {
    root37.style.MozUserSelect = root37.__noselect;
    delete root37.__noselect;
  }
}

// node_modules/d3-drag/src/constant.js
var constant_default2 = (x) => () => x;

// node_modules/d3-drag/src/event.js
function DragEvent(type, {
  sourceEvent,
  subject,
  target,
  identifier,
  active,
  x,
  y,
  dx,
  dy,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
    subject: { value: subject, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    identifier: { value: identifier, enumerable: true, configurable: true },
    active: { value: active, enumerable: true, configurable: true },
    x: { value: x, enumerable: true, configurable: true },
    y: { value: y, enumerable: true, configurable: true },
    dx: { value: dx, enumerable: true, configurable: true },
    dy: { value: dy, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}
DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};

// node_modules/d3-drag/src/drag.js
function defaultFilter(event2) {
  return !event2.ctrlKey && !event2.button;
}
function defaultContainer() {
  return this.parentNode;
}
function defaultSubject(event2, d) {
  return d == null ? { x: event2.x, y: event2.y } : d;
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function drag_default() {
  var filter2 = defaultFilter, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable, gestures = {}, listeners = dispatch_default("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
  function drag2(selection2) {
    selection2.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, nonpassive2).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function mousedowned(event2, d) {
    if (touchending || !filter2.call(this, event2, d)) return;
    var gesture = beforestart(this, container.call(this, event2, d), event2, d, "mouse");
    if (!gesture) return;
    select_default2(event2.view).on("mousemove.drag", mousemoved, nonpassivecapture).on("mouseup.drag", mouseupped, nonpassivecapture);
    nodrag_default(event2.view);
    nopropagation(event2);
    mousemoving = false;
    mousedownx = event2.clientX;
    mousedowny = event2.clientY;
    gesture("start", event2);
  }
  function mousemoved(event2) {
    noevent_default(event2);
    if (!mousemoving) {
      var dx = event2.clientX - mousedownx, dy = event2.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag", event2);
  }
  function mouseupped(event2) {
    select_default2(event2.view).on("mousemove.drag mouseup.drag", null);
    yesdrag(event2.view, mousemoving);
    noevent_default(event2);
    gestures.mouse("end", event2);
  }
  function touchstarted(event2, d) {
    if (!filter2.call(this, event2, d)) return;
    var touches = event2.changedTouches, c = container.call(this, event2, d), n = touches.length, i, gesture;
    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(this, c, event2, d, touches[i].identifier, touches[i])) {
        nopropagation(event2);
        gesture("start", event2, touches[i]);
      }
    }
  }
  function touchmoved(event2) {
    var touches = event2.changedTouches, n = touches.length, i, gesture;
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        noevent_default(event2);
        gesture("drag", event2, touches[i]);
      }
    }
  }
  function touchended(event2) {
    var touches = event2.changedTouches, n = touches.length, i, gesture;
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, 500);
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        nopropagation(event2);
        gesture("end", event2, touches[i]);
      }
    }
  }
  function beforestart(that, container2, event2, d, identifier, touch) {
    var dispatch2 = listeners.copy(), p = pointer_default(touch || event2, container2), dx, dy, s;
    if ((s = subject.call(that, new DragEvent("beforestart", {
      sourceEvent: event2,
      target: drag2,
      identifier,
      active,
      x: p[0],
      y: p[1],
      dx: 0,
      dy: 0,
      dispatch: dispatch2
    }), d)) == null) return;
    dx = s.x - p[0] || 0;
    dy = s.y - p[1] || 0;
    return function gesture(type, event3, touch2) {
      var p0 = p, n;
      switch (type) {
        case "start":
          gestures[identifier] = gesture, n = active++;
          break;
        case "end":
          delete gestures[identifier], --active;
        // falls through
        case "drag":
          p = pointer_default(touch2 || event3, container2), n = active;
          break;
      }
      dispatch2.call(
        type,
        that,
        new DragEvent(type, {
          sourceEvent: event3,
          subject: s,
          target: drag2,
          identifier,
          active: n,
          x: p[0] + dx,
          y: p[1] + dy,
          dx: p[0] - p0[0],
          dy: p[1] - p0[1],
          dispatch: dispatch2
        }),
        d
      );
    };
  }
  drag2.filter = function(_) {
    return arguments.length ? (filter2 = typeof _ === "function" ? _ : constant_default2(!!_), drag2) : filter2;
  };
  drag2.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : constant_default2(_), drag2) : container;
  };
  drag2.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : constant_default2(_), drag2) : subject;
  };
  drag2.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant_default2(!!_), drag2) : touchable;
  };
  drag2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag2 : value;
  };
  drag2.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag2) : Math.sqrt(clickDistance2);
  };
  return drag2;
}

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key3 in definition) prototype[key3] = definition[key3];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r2, g, b, a) {
  if (a <= 0) r2 = g = b = NaN;
  return new Rgb(r2, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r2, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r2, g, b, opacity) {
  this.r = +r2;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r2 = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r2, g, b), max = Math.max(r2, g, b), h = NaN, s = max - min, l = (max + min) / 2;
  if (s) {
    if (r2 === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r2) / s + 2;
    else h = (r2 - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

// node_modules/d3-interpolate/src/basis.js
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}
function basis_default(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default3 = (x) => () => x;

// node_modules/d3-interpolate/src/color.js
function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant_default3(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant_default3(isNaN(a) ? b : a);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = (function rgbGamma(y) {
  var color2 = gamma(y);
  function rgb2(start2, end) {
    var r2 = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.r = r2(t);
      start2.g = g(t);
      start2.b = b(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
})(1);
function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length, r2 = new Array(n), g = new Array(n), b = new Array(n), i, color2;
    for (i = 0; i < n; ++i) {
      color2 = rgb(colors[i]);
      r2[i] = color2.r || 0;
      g[i] = color2.g || 0;
      b[i] = color2.b || 0;
    }
    r2 = spline(r2);
    g = spline(g);
    b = spline(b);
    color2.opacity = 1;
    return function(t) {
      color2.r = r2(t);
      color2.g = g(t);
      color2.b = b(t);
      return color2 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}
function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}

// node_modules/d3-interpolate/src/array.js
function genericArray(a, b) {
  var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
  for (i = 0; i < na; ++i) x[i] = value_default(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}

// node_modules/d3-interpolate/src/date.js
function date_default(a, b) {
  var d = /* @__PURE__ */ new Date();
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}

// node_modules/d3-interpolate/src/number.js
function number_default(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}

// node_modules/d3-interpolate/src/object.js
function object_default(a, b) {
  var i = {}, c = {}, k;
  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};
  for (k in b) {
    if (k in a) {
      i[k] = value_default(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }
  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string_default(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs;
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i]) s[i] += bm;
      else s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs;
    else s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2) s[(o = q[i2]).i] = o.x(t);
    return s.join("");
  });
}

// node_modules/d3-interpolate/src/value.js
function value_default(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant_default3(b) : (t === "number" ? number_default : t === "string" ? (c = color(b)) ? (b = c, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a, b);
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees = 180 / Math.PI;
var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? identity : decompose_default(m.a, m.b, m.c, m.d, m.e, m.f);
}
function parseSvg(value) {
  if (value == null) return identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop2(s) {
    return s.length ? s.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360;
      else if (b - a > 180) a += 360;
      q.push({ i: s.push(pop2(s) + "rotate(", null, degParen) - 2, x: number_default(a, b) });
    } else if (b) {
      s.push(pop2(s) + "rotate(" + b + degParen);
    }
  }
  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({ i: s.push(pop2(s) + "skewX(", null, degParen) - 2, x: number_default(a, b) });
    } else if (b) {
      s.push(pop2(s) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop2(s) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop2(s) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a, b) {
    var s = [], q = [];
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/zoom.js
var epsilon2 = 1e-12;
function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}
function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}
function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}
var zoom_default = (function zoomRho(rho, rho2, rho4) {
  function zoom2(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      };
    }
    i.duration = S * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom2.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };
  return zoom2;
})(Math.SQRT2, 2, 4);

// node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep2();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep2();
    }
  }
};
function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(void 0, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep2(time);
}
function sleep2(time) {
  if (frame) return;
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-timer/src/timeout.js
function timeout_default(callback, delay, time) {
  var t = new Timer();
  delay = delay == null ? 0 : +delay;
  t.restart((elapsed) => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}

// node_modules/d3-transition/src/transition/schedule.js
var emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule_default(node, name, id2, index2, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id2 in schedules) return;
  create(node, id2, {
    name,
    index: index2,
    // For context during callback.
    group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init2(node, id2) {
  var schedule = get4(node, id2);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}
function set3(node, id2) {
  var schedule = get4(node, id2);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}
function get4(node, id2) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id2])) throw new Error("transition not found");
  return schedule;
}
function create(node, id2, self2) {
  var schedules = node.__transition, tween;
  schedules[id2] = self2;
  self2.timer = timer(schedule, 0, self2.time);
  function schedule(elapsed) {
    self2.state = SCHEDULED;
    self2.timer.restart(start2, self2.delay, self2.time);
    if (self2.delay <= elapsed) start2(elapsed - self2.delay);
  }
  function start2(elapsed) {
    var i, j, n, o;
    if (self2.state !== SCHEDULED) return stop();
    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self2.name) continue;
      if (o.state === STARTED) return timeout_default(start2);
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      } else if (+i < id2) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }
    timeout_default(function() {
      if (self2.state === STARTED) {
        self2.state = RUNNING;
        self2.timer.restart(tick2, self2.delay, self2.time);
        tick2(elapsed);
      }
    });
    self2.state = STARTING;
    self2.on.call("start", node, node.__data__, self2.index, self2.group);
    if (self2.state !== STARTING) return;
    self2.state = STARTED;
    tween = new Array(n = self2.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self2.tween[i].value.call(node, node.__data__, self2.index, self2.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }
  function tick2(elapsed) {
    var t = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i = -1, n = tween.length;
    while (++i < n) {
      tween[i].call(node, t);
    }
    if (self2.state === ENDING) {
      self2.on.call("end", node, node.__data__, self2.index, self2.group);
      stop();
    }
  }
  function stop() {
    self2.state = ENDED;
    self2.timer.stop();
    delete schedules[id2];
    for (var i in schedules) return;
    delete node.__transition;
  }
}

// node_modules/d3-transition/src/interrupt.js
function interrupt_default(node, name) {
  var schedules = node.__transition, schedule, active, empty3 = true, i;
  if (!schedules) return;
  name = name == null ? null : name + "";
  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) {
      empty3 = false;
      continue;
    }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }
  if (empty3) delete node.__transition;
}

// node_modules/d3-transition/src/selection/interrupt.js
function interrupt_default2(name) {
  return this.each(function() {
    interrupt_default(this, name);
  });
}

// node_modules/d3-transition/src/transition/tween.js
function tweenRemove(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule = set3(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }
    schedule.tween = tween1;
  };
}
function tweenFunction(id2, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error();
  return function() {
    var schedule = set3(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = { name, value }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }
    schedule.tween = tween1;
  };
}
function tween_default(name, value) {
  var id2 = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = get4(this.node(), id2).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
}
function tweenValue(transition3, name, value) {
  var id2 = transition3._id;
  transition3.each(function() {
    var schedule = set3(this, id2);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });
  return function(node) {
    return get4(node, id2).value[name];
  };
}

// node_modules/d3-transition/src/transition/interpolate.js
function interpolate_default(a, b) {
  var c;
  return (typeof b === "number" ? number_default : b instanceof color ? rgb_default : (c = color(b)) ? (b = c, rgb_default) : string_default)(a, b);
}

// node_modules/d3-transition/src/transition/attr.js
function attrRemove2(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS2(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrConstantNS2(fullname, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attrFunctionNS2(fullname, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attr_default2(name, value) {
  var fullname = namespace_default(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i, value));
}

// node_modules/d3-transition/src/transition/attrTween.js
function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}
function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}
function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function attrTween_default(name, value) {
  var key3 = "attr." + name;
  if (arguments.length < 2) return (key3 = this.tween(key3)) && key3._value;
  if (value == null) return this.tween(key3, null);
  if (typeof value !== "function") throw new Error();
  var fullname = namespace_default(name);
  return this.tween(key3, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

// node_modules/d3-transition/src/transition/delay.js
function delayFunction(id2, value) {
  return function() {
    init2(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init2(this, id2).delay = value;
  };
}
function delay_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get4(this.node(), id2).delay;
}

// node_modules/d3-transition/src/transition/duration.js
function durationFunction(id2, value) {
  return function() {
    set3(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set3(this, id2).duration = value;
  };
}
function duration_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get4(this.node(), id2).duration;
}

// node_modules/d3-transition/src/transition/ease.js
function easeConstant(id2, value) {
  if (typeof value !== "function") throw new Error();
  return function() {
    set3(this, id2).ease = value;
  };
}
function ease_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get4(this.node(), id2).ease;
}

// node_modules/d3-transition/src/transition/easeVarying.js
function easeVarying(id2, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function") throw new Error();
    set3(this, id2).ease = v;
  };
}
function easeVarying_default(value) {
  if (typeof value !== "function") throw new Error();
  return this.each(easeVarying(this._id, value));
}

// node_modules/d3-transition/src/transition/filter.js
function filter_default2(match) {
  if (typeof match !== "function") match = matcher_default(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/merge.js
function merge_default2(transition3) {
  if (transition3._id !== this._id) throw new Error();
  for (var groups0 = this._groups, groups1 = transition3._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/on.js
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}
function onFunction(id2, name, listener) {
  var on0, on1, sit = start(name) ? init2 : set3;
  return function() {
    var schedule = sit(this, id2), on2 = schedule.on;
    if (on2 !== on0) (on1 = (on0 = on2).copy()).on(name, listener);
    schedule.on = on1;
  };
}
function on_default2(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get4(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
}

// node_modules/d3-transition/src/transition/remove.js
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id2) return;
    if (parent) parent.removeChild(this);
  };
}
function remove_default2() {
  return this.on("end.remove", removeFunction(this._id));
}

// node_modules/d3-transition/src/transition/select.js
function select_default3(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function") select = selector_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule_default(subgroup[i], name, id2, i, subgroup, get4(node, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name, id2);
}

// node_modules/d3-transition/src/transition/selectAll.js
function selectAll_default2(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function") select = selectorAll_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children2 = select.call(node, node.__data__, i, group), child2, inherit2 = get4(node, id2), k = 0, l = children2.length; k < l; ++k) {
          if (child2 = children2[k]) {
            schedule_default(child2, name, id2, k, children2, inherit2);
          }
        }
        subgroups.push(children2);
        parents.push(node);
      }
    }
  }
  return new Transition(subgroups, parents, name, id2);
}

// node_modules/d3-transition/src/transition/selection.js
var Selection2 = selection_default.prototype.constructor;
function selection_default2() {
  return new Selection2(this._groups, this._parents);
}

// node_modules/d3-transition/src/transition/style.js
function styleNull(name, interpolate) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}
function styleRemove2(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function styleFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name) {
  var on0, on1, listener0, key3 = "style." + name, event2 = "end." + key3, remove2;
  return function() {
    var schedule = set3(this, id2), on2 = schedule.on, listener = schedule.value[key3] == null ? remove2 || (remove2 = styleRemove2(name)) : void 0;
    if (on2 !== on0 || listener0 !== listener) (on1 = (on0 = on2).copy()).on(event2, listener0 = listener);
    schedule.on = on1;
  };
}
function style_default2(name, value, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate_default;
  return value == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove2(name)) : typeof value === "function" ? this.styleTween(name, styleFunction2(name, i, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i, value), priority).on("end.style." + name, null);
}

// node_modules/d3-transition/src/transition/styleTween.js
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}
function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}
function styleTween_default(name, value, priority) {
  var key3 = "style." + (name += "");
  if (arguments.length < 2) return (key3 = this.tween(key3)) && key3._value;
  if (value == null) return this.tween(key3, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key3, styleTween(name, value, priority == null ? "" : priority));
}

// node_modules/d3-transition/src/transition/text.js
function textConstant2(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction2(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function text_default2(value) {
  return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
}

// node_modules/d3-transition/src/transition/textTween.js
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}
function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function textTween_default(value) {
  var key3 = "text";
  if (arguments.length < 1) return (key3 = this.tween(key3)) && key3._value;
  if (value == null) return this.tween(key3, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key3, textTween(value));
}

// node_modules/d3-transition/src/transition/transition.js
function transition_default() {
  var name = this._name, id0 = this._id, id1 = newId();
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit2 = get4(node, id0);
        schedule_default(node, name, id1, i, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition(groups, this._parents, name, id1);
}

// node_modules/d3-transition/src/transition/end.js
function end_default() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = { value: reject }, end = { value: function() {
      if (--size === 0) resolve();
    } };
    that.each(function() {
      var schedule = set3(this, id2), on2 = schedule.on;
      if (on2 !== on0) {
        on1 = (on0 = on2).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule.on = on1;
    });
    if (size === 0) resolve();
  });
}

// node_modules/d3-transition/src/transition/index.js
var id = 0;
function Transition(groups, parents, name, id2) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id2;
}
function transition2(name) {
  return selection_default().transition(name);
}
function newId() {
  return ++id;
}
var selection_prototype = selection_default.prototype;
Transition.prototype = transition2.prototype = {
  constructor: Transition,
  select: select_default3,
  selectAll: selectAll_default2,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: filter_default2,
  merge: merge_default2,
  selection: selection_default2,
  transition: transition_default,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: on_default2,
  attr: attr_default2,
  attrTween: attrTween_default,
  style: style_default2,
  styleTween: styleTween_default,
  text: text_default2,
  textTween: textTween_default,
  remove: remove_default2,
  tween: tween_default,
  delay: delay_default,
  duration: duration_default,
  ease: ease_default,
  easeVarying: easeVarying_default,
  end: end_default,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};

// node_modules/d3-ease/src/cubic.js
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

// node_modules/d3-transition/src/selection/transition.js
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node, id2) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id2])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function transition_default2(name) {
  var id2, timing;
  if (name instanceof Transition) {
    id2 = name._id, name = name._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule_default(node, name, id2, i, group, timing || inherit(node, id2));
      }
    }
  }
  return new Transition(groups, this._parents, name, id2);
}

// node_modules/d3-transition/src/selection/index.js
selection_default.prototype.interrupt = interrupt_default2;
selection_default.prototype.transition = transition_default2;

// node_modules/d3-zoom/src/constant.js
var constant_default4 = (x) => () => x;

// node_modules/d3-zoom/src/event.js
function ZoomEvent(type, {
  sourceEvent,
  target,
  transform: transform2,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    transform: { value: transform2, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}

// node_modules/d3-zoom/src/transform.js
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity2 = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return identity2;
  return node.__zoom;
}

// node_modules/d3-zoom/src/noevent.js
function nopropagation2(event2) {
  event2.stopImmediatePropagation();
}
function noevent_default2(event2) {
  event2.preventDefault();
  event2.stopImmediatePropagation();
}

// node_modules/d3-zoom/src/zoom.js
function defaultFilter2(event2) {
  return (!event2.ctrlKey || event2.type === "wheel") && !event2.button;
}
function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}
function defaultTransform() {
  return this.__zoom || identity2;
}
function defaultWheelDelta(event2) {
  return -event2.deltaY * (event2.deltaMode === 1 ? 0.05 : event2.deltaMode ? 1 : 2e-3) * (event2.ctrlKey ? 10 : 1);
}
function defaultTouchable2() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform2, extent, translateExtent) {
  var dx0 = transform2.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent[1][1]) - translateExtent[1][1];
  return transform2.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}
function zoom_default2() {
  var filter2 = defaultFilter2, extent = defaultExtent, constrain = defaultConstrain, wheelDelta2 = defaultWheelDelta, touchable = defaultTouchable2, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate = zoom_default, listeners = dispatch_default("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
  function zoom2(selection2) {
    selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: false }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  zoom2.transform = function(collection, transform2, point, event2) {
    var selection2 = collection.selection ? collection.selection() : collection;
    selection2.property("__zoom", defaultTransform);
    if (collection !== selection2) {
      schedule(collection, transform2, point, event2);
    } else {
      selection2.interrupt().each(function() {
        gesture(this, arguments).event(event2).start().zoom(null, typeof transform2 === "function" ? transform2.apply(this, arguments) : transform2).end();
      });
    }
  };
  zoom2.scaleBy = function(selection2, k, p, event2) {
    zoom2.scaleTo(selection2, function() {
      var k0 = this.__zoom.k, k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event2);
  };
  zoom2.scaleTo = function(selection2, k, p, event2) {
    zoom2.transform(selection2, function() {
      var e = extent.apply(this, arguments), t0 = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p, p1 = t0.invert(p0), k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p, event2);
  };
  zoom2.translateBy = function(selection2, x, y, event2) {
    zoom2.transform(selection2, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    }, null, event2);
  };
  zoom2.translateTo = function(selection2, x, y, p, event2) {
    zoom2.transform(selection2, function() {
      var e = extent.apply(this, arguments), t = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(identity2.translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p, event2);
  };
  function scale(transform2, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform2.k ? transform2 : new Transform(k, transform2.x, transform2.y);
  }
  function translate(transform2, p0, p1) {
    var x = p0[0] - p1[0] * transform2.k, y = p0[1] - p1[1] * transform2.k;
    return x === transform2.x && y === transform2.y ? transform2 : new Transform(transform2.k, x, y);
  }
  function centroid(extent2) {
    return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
  }
  function schedule(transition3, transform2, point, event2) {
    transition3.on("start.zoom", function() {
      gesture(this, arguments).event(event2).start();
    }).on("interrupt.zoom end.zoom", function() {
      gesture(this, arguments).event(event2).end();
    }).tween("zoom", function() {
      var that = this, args = arguments, g = gesture(that, args).event(event2), e = extent.apply(that, args), p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point, w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]), a = that.__zoom, b = typeof transform2 === "function" ? transform2.apply(that, args) : transform2, i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
      return function(t) {
        if (t === 1) t = b;
        else {
          var l = i(t), k = w / l[2];
          t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k);
        }
        g.zoom(null, t);
      };
    });
  }
  function gesture(that, args, clean) {
    return !clean && that.__zooming || new Gesture(that, args);
  }
  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }
  Gesture.prototype = {
    event: function(event2) {
      if (event2) this.sourceEvent = event2;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key3, transform2) {
      if (this.mouse && key3 !== "mouse") this.mouse[1] = transform2.invert(this.mouse[0]);
      if (this.touch0 && key3 !== "touch") this.touch0[1] = transform2.invert(this.touch0[0]);
      if (this.touch1 && key3 !== "touch") this.touch1[1] = transform2.invert(this.touch1[0]);
      this.that.__zoom = transform2;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      var d = select_default2(this.that).datum();
      listeners.call(
        type,
        this.that,
        new ZoomEvent(type, {
          sourceEvent: this.sourceEvent,
          target: zoom2,
          type,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };
  function wheeled(event2, ...args) {
    if (!filter2.apply(this, arguments)) return;
    var g = gesture(this, args).event(event2), t = this.__zoom, k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta2.apply(this, arguments)))), p = pointer_default(event2);
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    } else if (t.k === k) return;
    else {
      g.mouse = [p, t.invert(p)];
      interrupt_default(this);
      g.start();
    }
    noevent_default2(event2);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }
  function mousedowned(event2, ...args) {
    if (touchending || !filter2.apply(this, arguments)) return;
    var currentTarget = event2.currentTarget, g = gesture(this, args, true).event(event2), v = select_default2(event2.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p = pointer_default(event2, currentTarget), x0 = event2.clientX, y0 = event2.clientY;
    nodrag_default(event2.view);
    nopropagation2(event2);
    g.mouse = [p, this.__zoom.invert(p)];
    interrupt_default(this);
    g.start();
    function mousemoved(event3) {
      noevent_default2(event3);
      if (!g.moved) {
        var dx = event3.clientX - x0, dy = event3.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event3).zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer_default(event3, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }
    function mouseupped(event3) {
      v.on("mousemove.zoom mouseup.zoom", null);
      yesdrag(event3.view, g.moved);
      noevent_default2(event3);
      g.event(event3).end();
    }
  }
  function dblclicked(event2, ...args) {
    if (!filter2.apply(this, arguments)) return;
    var t0 = this.__zoom, p0 = pointer_default(event2.changedTouches ? event2.changedTouches[0] : event2, this), p1 = t0.invert(p0), k1 = t0.k * (event2.shiftKey ? 0.5 : 2), t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);
    noevent_default2(event2);
    if (duration > 0) select_default2(this).transition().duration(duration).call(schedule, t1, p0, event2);
    else select_default2(this).call(zoom2.transform, t1, p0, event2);
  }
  function touchstarted(event2, ...args) {
    if (!filter2.apply(this, arguments)) return;
    var touches = event2.touches, n = touches.length, g = gesture(this, args, event2.changedTouches.length === n).event(event2), started, i, t, p;
    nopropagation2(event2);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = pointer_default(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }
    if (touchstarting) touchstarting = clearTimeout(touchstarting);
    if (started) {
      if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() {
        touchstarting = null;
      }, touchDelay);
      interrupt_default(this);
      g.start();
    }
  }
  function touchmoved(event2, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event2), touches = event2.changedTouches, n = touches.length, i, t, p, l;
    noevent_default2(event2);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = pointer_default(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }
  function touchended(event2, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event2), touches = event2.changedTouches, n = touches.length, i, t;
    nopropagation2(event2);
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      if (g.taps === 2) {
        t = pointer_default(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = select_default2(this).on("dblclick.zoom");
          if (p) p.apply(this, arguments);
        }
      }
    }
  }
  zoom2.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta2 = typeof _ === "function" ? _ : constant_default4(+_), zoom2) : wheelDelta2;
  };
  zoom2.filter = function(_) {
    return arguments.length ? (filter2 = typeof _ === "function" ? _ : constant_default4(!!_), zoom2) : filter2;
  };
  zoom2.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant_default4(!!_), zoom2) : touchable;
  };
  zoom2.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant_default4([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom2) : extent;
  };
  zoom2.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom2) : [scaleExtent[0], scaleExtent[1]];
  };
  zoom2.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom2) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };
  zoom2.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom2) : constrain;
  };
  zoom2.duration = function(_) {
    return arguments.length ? (duration = +_, zoom2) : duration;
  };
  zoom2.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom2) : interpolate;
  };
  zoom2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom2 : value;
  };
  zoom2.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom2) : Math.sqrt(clickDistance2);
  };
  zoom2.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom2) : tapDistance;
  };
  return zoom2;
}

// node_modules/@xyflow/system/dist/esm/index.js
var errorMessages = {
  error001: () => "[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001",
  error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
  error003: (nodeType) => `Node type "${nodeType}" not found. Using fallback type "default".`,
  error004: () => "The React Flow parent container needs a width and a height to render the graph.",
  error005: () => "Only child nodes can use a parent extent.",
  error006: () => "Can't create edge. An edge needs a source and a target.",
  error007: (id2) => `The old edge with id=${id2} does not exist.`,
  error009: (type) => `Marker type "${type}" doesn't exist.`,
  error008: (handleType, { id: id2, sourceHandle, targetHandle }) => `Couldn't create edge for ${handleType} handle id: "${handleType === "source" ? sourceHandle : targetHandle}", edge id: ${id2}.`,
  error010: () => "Handle: No node id found. Make sure to only use a Handle inside a custom Node.",
  error011: (edgeType) => `Edge type "${edgeType}" not found. Using fallback type "default".`,
  error012: (id2) => `Node with id "${id2}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`,
  error013: (lib = "react") => `It seems that you haven't loaded the styles. Please import '@xyflow/${lib}/dist/style.css' or base.css to make sure everything is working properly.`,
  error014: () => "useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.",
  error015: () => "It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs."
};
var infiniteExtent = [
  [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
  [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
];
var elementSelectionKeys = ["Enter", " ", "Escape"];
var defaultAriaLabelConfig = {
  "node.a11yDescription.default": "Press enter or space to select a node. Press delete to remove it and escape to cancel.",
  "node.a11yDescription.keyboardDisabled": "Press enter or space to select a node. You can then use the arrow keys to move the node around. Press delete to remove it and escape to cancel.",
  "node.a11yDescription.ariaLiveMessage": ({ direction, x, y }) => `Moved selected node ${direction}. New position, x: ${x}, y: ${y}`,
  "edge.a11yDescription.default": "Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.",
  // Control elements
  "controls.ariaLabel": "Control Panel",
  "controls.zoomIn.ariaLabel": "Zoom In",
  "controls.zoomOut.ariaLabel": "Zoom Out",
  "controls.fitView.ariaLabel": "Fit View",
  "controls.interactive.ariaLabel": "Toggle Interactivity",
  // Mini map
  "minimap.ariaLabel": "Mini Map",
  // Handle
  "handle.ariaLabel": "Handle"
};
var ConnectionMode;
(function(ConnectionMode2) {
  ConnectionMode2["Strict"] = "strict";
  ConnectionMode2["Loose"] = "loose";
})(ConnectionMode || (ConnectionMode = {}));
var PanOnScrollMode;
(function(PanOnScrollMode2) {
  PanOnScrollMode2["Free"] = "free";
  PanOnScrollMode2["Vertical"] = "vertical";
  PanOnScrollMode2["Horizontal"] = "horizontal";
})(PanOnScrollMode || (PanOnScrollMode = {}));
var SelectionMode;
(function(SelectionMode2) {
  SelectionMode2["Partial"] = "partial";
  SelectionMode2["Full"] = "full";
})(SelectionMode || (SelectionMode = {}));
var initialConnection = {
  inProgress: false,
  isValid: null,
  from: null,
  fromHandle: null,
  fromPosition: null,
  fromNode: null,
  to: null,
  toHandle: null,
  toPosition: null,
  toNode: null
};
var ConnectionLineType;
(function(ConnectionLineType2) {
  ConnectionLineType2["Bezier"] = "default";
  ConnectionLineType2["Straight"] = "straight";
  ConnectionLineType2["Step"] = "step";
  ConnectionLineType2["SmoothStep"] = "smoothstep";
  ConnectionLineType2["SimpleBezier"] = "simplebezier";
})(ConnectionLineType || (ConnectionLineType = {}));
var MarkerType;
(function(MarkerType2) {
  MarkerType2["Arrow"] = "arrow";
  MarkerType2["ArrowClosed"] = "arrowclosed";
})(MarkerType || (MarkerType = {}));
var Position;
(function(Position2) {
  Position2["Left"] = "left";
  Position2["Top"] = "top";
  Position2["Right"] = "right";
  Position2["Bottom"] = "bottom";
})(Position || (Position = {}));
var oppositePosition = {
  [Position.Left]: Position.Right,
  [Position.Right]: Position.Left,
  [Position.Top]: Position.Bottom,
  [Position.Bottom]: Position.Top
};
function areConnectionMapsEqual(a, b) {
  if (!a && !b) {
    return true;
  }
  if (!a || !b || a.size !== b.size) {
    return false;
  }
  if (!a.size && !b.size) {
    return true;
  }
  for (const key3 of a.keys()) {
    if (!b.has(key3)) {
      return false;
    }
  }
  return true;
}
function handleConnectionChange(a, b, cb) {
  if (!cb) {
    return;
  }
  const diff = [];
  a.forEach((connection, key3) => {
    if (!(b == null ? void 0 : b.has(key3))) {
      diff.push(connection);
    }
  });
  if (diff.length) {
    cb(diff);
  }
}
function getConnectionStatus(isValid) {
  return isValid === null ? null : isValid ? "valid" : "invalid";
}
var isEdgeBase = (element2) => "id" in element2 && "source" in element2 && "target" in element2;
var isNodeBase = (element2) => "id" in element2 && "position" in element2 && !("source" in element2) && !("target" in element2);
var isInternalNodeBase = (element2) => "id" in element2 && "internals" in element2 && !("source" in element2) && !("target" in element2);
var getNodePositionWithOrigin = (node, nodeOrigin = [0, 0]) => {
  var _a3;
  const { width, height } = getNodeDimensions(node);
  const origin = (_a3 = node.origin) != null ? _a3 : nodeOrigin;
  const offsetX = width * origin[0];
  const offsetY = height * origin[1];
  return {
    x: node.position.x - offsetX,
    y: node.position.y - offsetY
  };
};
var getNodesBounds = (nodes, params = { nodeOrigin: [0, 0] }) => {
  if (!params.nodeLookup) {
    console.warn("Please use `getNodesBounds` from `useReactFlow`/`useSvelteFlow` hook to ensure correct values for sub flows. If not possible, you have to provide a nodeLookup to support sub flows.");
  }
  if (nodes.length === 0) {
    return { x: 0, y: 0, width: 0, height: 0 };
  }
  const box = nodes.reduce((currBox, nodeOrId) => {
    const isId = typeof nodeOrId === "string";
    let currentNode = !params.nodeLookup && !isId ? nodeOrId : void 0;
    if (params.nodeLookup) {
      currentNode = isId ? params.nodeLookup.get(nodeOrId) : !isInternalNodeBase(nodeOrId) ? params.nodeLookup.get(nodeOrId.id) : nodeOrId;
    }
    const nodeBox = currentNode ? nodeToBox(currentNode, params.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };
    return getBoundsOfBoxes(currBox, nodeBox);
  }, { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity });
  return boxToRect(box);
};
var getInternalNodesBounds = (nodeLookup, params = {}) => {
  if (nodeLookup.size === 0) {
    return { x: 0, y: 0, width: 0, height: 0 };
  }
  let box = { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity };
  nodeLookup.forEach((node) => {
    if (params.filter === void 0 || params.filter(node)) {
      const nodeBox = nodeToBox(node);
      box = getBoundsOfBoxes(box, nodeBox);
    }
  });
  return boxToRect(box);
};
var getNodesInside = (nodes, rect, [tx, ty, tScale] = [0, 0, 1], partially = false, excludeNonSelectableNodes = false) => {
  var _a3, _b3, _c2, _d, _e, _f;
  const paneRect = {
    ...pointToRendererPoint(rect, [tx, ty, tScale]),
    width: rect.width / tScale,
    height: rect.height / tScale
  };
  const visibleNodes = [];
  for (const node of nodes.values()) {
    const { measured, selectable = true, hidden = false } = node;
    if (excludeNonSelectableNodes && !selectable || hidden) {
      continue;
    }
    const width = (_c2 = (_b3 = (_a3 = measured.width) != null ? _a3 : node.width) != null ? _b3 : node.initialWidth) != null ? _c2 : null;
    const height = (_f = (_e = (_d = measured.height) != null ? _d : node.height) != null ? _e : node.initialHeight) != null ? _f : null;
    const overlappingArea = getOverlappingArea(paneRect, nodeToRect(node));
    const area = (width != null ? width : 0) * (height != null ? height : 0);
    const partiallyVisible = partially && overlappingArea > 0;
    const forceInitialRender = !node.internals.handleBounds;
    const isVisible = forceInitialRender || partiallyVisible || overlappingArea >= area;
    if (isVisible || node.dragging) {
      visibleNodes.push(node);
    }
  }
  return visibleNodes;
};
var getConnectedEdges = (nodes, edges) => {
  const nodeIds = /* @__PURE__ */ new Set();
  nodes.forEach((node) => {
    nodeIds.add(node.id);
  });
  return edges.filter((edge) => nodeIds.has(edge.source) || nodeIds.has(edge.target));
};
function getFitViewNodes(nodeLookup, options) {
  const fitViewNodes = /* @__PURE__ */ new Map();
  const optionNodeIds = (options == null ? void 0 : options.nodes) ? new Set(options.nodes.map((node) => node.id)) : null;
  nodeLookup.forEach((n) => {
    const isVisible = n.measured.width && n.measured.height && ((options == null ? void 0 : options.includeHiddenNodes) || !n.hidden);
    if (isVisible && (!optionNodeIds || optionNodeIds.has(n.id))) {
      fitViewNodes.set(n.id, n);
    }
  });
  return fitViewNodes;
}
async function fitViewport({ nodes, width, height, panZoom, minZoom, maxZoom }, options) {
  var _a3, _b3, _c2;
  if (nodes.size === 0) {
    return Promise.resolve(true);
  }
  const nodesToFit = getFitViewNodes(nodes, options);
  const bounds = getInternalNodesBounds(nodesToFit);
  const viewport = getViewportForBounds(bounds, width, height, (_a3 = options == null ? void 0 : options.minZoom) != null ? _a3 : minZoom, (_b3 = options == null ? void 0 : options.maxZoom) != null ? _b3 : maxZoom, (_c2 = options == null ? void 0 : options.padding) != null ? _c2 : 0.1);
  await panZoom.setViewport(viewport, {
    duration: options == null ? void 0 : options.duration,
    ease: options == null ? void 0 : options.ease,
    interpolate: options == null ? void 0 : options.interpolate
  });
  return Promise.resolve(true);
}
function calculateNodePosition({ nodeId, nextPosition, nodeLookup, nodeOrigin = [0, 0], nodeExtent, onError }) {
  var _a3, _b3, _c2;
  const node = nodeLookup.get(nodeId);
  const parentNode = node.parentId ? nodeLookup.get(node.parentId) : void 0;
  const { x: parentX, y: parentY } = parentNode ? parentNode.internals.positionAbsolute : { x: 0, y: 0 };
  const origin = (_a3 = node.origin) != null ? _a3 : nodeOrigin;
  let extent = node.extent || nodeExtent;
  if (node.extent === "parent" && !node.expandParent) {
    if (!parentNode) {
      onError == null ? void 0 : onError("005", errorMessages["error005"]());
    } else {
      const parentWidth = parentNode.measured.width;
      const parentHeight = parentNode.measured.height;
      if (parentWidth && parentHeight) {
        extent = [
          [parentX, parentY],
          [parentX + parentWidth, parentY + parentHeight]
        ];
      }
    }
  } else if (parentNode && isCoordinateExtent(node.extent)) {
    extent = [
      [node.extent[0][0] + parentX, node.extent[0][1] + parentY],
      [node.extent[1][0] + parentX, node.extent[1][1] + parentY]
    ];
  }
  const positionAbsolute = isCoordinateExtent(extent) ? clampPosition(nextPosition, extent, node.measured) : nextPosition;
  if (node.measured.width === void 0 || node.measured.height === void 0) {
    onError == null ? void 0 : onError("015", errorMessages["error015"]());
  }
  return {
    position: {
      x: positionAbsolute.x - parentX + ((_b3 = node.measured.width) != null ? _b3 : 0) * origin[0],
      y: positionAbsolute.y - parentY + ((_c2 = node.measured.height) != null ? _c2 : 0) * origin[1]
    },
    positionAbsolute
  };
}
async function getElementsToRemove({ nodesToRemove = [], edgesToRemove = [], nodes, edges, onBeforeDelete }) {
  const nodeIds = new Set(nodesToRemove.map((node) => node.id));
  const matchingNodes = [];
  for (const node of nodes) {
    if (node.deletable === false) {
      continue;
    }
    const isIncluded = nodeIds.has(node.id);
    const parentHit = !isIncluded && node.parentId && matchingNodes.find((n) => n.id === node.parentId);
    if (isIncluded || parentHit) {
      matchingNodes.push(node);
    }
  }
  const edgeIds = new Set(edgesToRemove.map((edge) => edge.id));
  const deletableEdges = edges.filter((edge) => edge.deletable !== false);
  const connectedEdges = getConnectedEdges(matchingNodes, deletableEdges);
  const matchingEdges = connectedEdges;
  for (const edge of deletableEdges) {
    const isIncluded = edgeIds.has(edge.id);
    if (isIncluded && !matchingEdges.find((e) => e.id === edge.id)) {
      matchingEdges.push(edge);
    }
  }
  if (!onBeforeDelete) {
    return {
      edges: matchingEdges,
      nodes: matchingNodes
    };
  }
  const onBeforeDeleteResult = await onBeforeDelete({
    nodes: matchingNodes,
    edges: matchingEdges
  });
  if (typeof onBeforeDeleteResult === "boolean") {
    return onBeforeDeleteResult ? { edges: matchingEdges, nodes: matchingNodes } : { edges: [], nodes: [] };
  }
  return onBeforeDeleteResult;
}
var clamp = (val, min = 0, max = 1) => Math.min(Math.max(val, min), max);
var clampPosition = (position = { x: 0, y: 0 }, extent, dimensions) => {
  var _a3, _b3;
  return {
    x: clamp(position.x, extent[0][0], extent[1][0] - ((_a3 = dimensions == null ? void 0 : dimensions.width) != null ? _a3 : 0)),
    y: clamp(position.y, extent[0][1], extent[1][1] - ((_b3 = dimensions == null ? void 0 : dimensions.height) != null ? _b3 : 0))
  };
};
function clampPositionToParent(childPosition, childDimensions, parent) {
  const { width: parentWidth, height: parentHeight } = getNodeDimensions(parent);
  const { x: parentX, y: parentY } = parent.internals.positionAbsolute;
  return clampPosition(childPosition, [
    [parentX, parentY],
    [parentX + parentWidth, parentY + parentHeight]
  ], childDimensions);
}
var calcAutoPanVelocity = (value, min, max) => {
  if (value < min) {
    return clamp(Math.abs(value - min), 1, min) / min;
  } else if (value > max) {
    return -clamp(Math.abs(value - max), 1, min) / min;
  }
  return 0;
};
var calcAutoPan = (pos, bounds, speed = 15, distance2 = 40) => {
  const xMovement = calcAutoPanVelocity(pos.x, distance2, bounds.width - distance2) * speed;
  const yMovement = calcAutoPanVelocity(pos.y, distance2, bounds.height - distance2) * speed;
  return [xMovement, yMovement];
};
var getBoundsOfBoxes = (box1, box2) => ({
  x: Math.min(box1.x, box2.x),
  y: Math.min(box1.y, box2.y),
  x2: Math.max(box1.x2, box2.x2),
  y2: Math.max(box1.y2, box2.y2)
});
var rectToBox = ({ x, y, width, height }) => ({
  x,
  y,
  x2: x + width,
  y2: y + height
});
var boxToRect = ({ x, y, x2, y2 }) => ({
  x,
  y,
  width: x2 - x,
  height: y2 - y
});
var nodeToRect = (node, nodeOrigin = [0, 0]) => {
  var _a3, _b3, _c2, _d, _e, _f, _g, _h;
  const { x, y } = isInternalNodeBase(node) ? node.internals.positionAbsolute : getNodePositionWithOrigin(node, nodeOrigin);
  return {
    x,
    y,
    width: (_d = (_c2 = (_b3 = (_a3 = node.measured) == null ? void 0 : _a3.width) != null ? _b3 : node.width) != null ? _c2 : node.initialWidth) != null ? _d : 0,
    height: (_h = (_g = (_f = (_e = node.measured) == null ? void 0 : _e.height) != null ? _f : node.height) != null ? _g : node.initialHeight) != null ? _h : 0
  };
};
var nodeToBox = (node, nodeOrigin = [0, 0]) => {
  var _a3, _b3, _c2, _d, _e, _f, _g, _h;
  const { x, y } = isInternalNodeBase(node) ? node.internals.positionAbsolute : getNodePositionWithOrigin(node, nodeOrigin);
  return {
    x,
    y,
    x2: x + ((_d = (_c2 = (_b3 = (_a3 = node.measured) == null ? void 0 : _a3.width) != null ? _b3 : node.width) != null ? _c2 : node.initialWidth) != null ? _d : 0),
    y2: y + ((_h = (_g = (_f = (_e = node.measured) == null ? void 0 : _e.height) != null ? _f : node.height) != null ? _g : node.initialHeight) != null ? _h : 0)
  };
};
var getBoundsOfRects = (rect1, rect2) => boxToRect(getBoundsOfBoxes(rectToBox(rect1), rectToBox(rect2)));
var getOverlappingArea = (rectA, rectB) => {
  const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x));
  const yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));
  return Math.ceil(xOverlap * yOverlap);
};
var isRectObject = (obj) => isNumeric(obj.width) && isNumeric(obj.height) && isNumeric(obj.x) && isNumeric(obj.y);
var isNumeric = (n) => !isNaN(n) && isFinite(n);
var devWarn = (id2, message) => {
  if (true) {
    console.warn(`[React Flow]: ${message} Help: https://reactflow.dev/error#${id2}`);
  }
};
var snapPosition = (position, snapGrid = [1, 1]) => {
  return {
    x: snapGrid[0] * Math.round(position.x / snapGrid[0]),
    y: snapGrid[1] * Math.round(position.y / snapGrid[1])
  };
};
var pointToRendererPoint = ({ x, y }, [tx, ty, tScale], snapToGrid = false, snapGrid = [1, 1]) => {
  const position = {
    x: (x - tx) / tScale,
    y: (y - ty) / tScale
  };
  return snapToGrid ? snapPosition(position, snapGrid) : position;
};
var rendererPointToPoint = ({ x, y }, [tx, ty, tScale]) => {
  return {
    x: x * tScale + tx,
    y: y * tScale + ty
  };
};
function parsePadding(padding, viewport) {
  if (typeof padding === "number") {
    return Math.floor((viewport - viewport / (1 + padding)) * 0.5);
  }
  if (typeof padding === "string" && padding.endsWith("px")) {
    const paddingValue = parseFloat(padding);
    if (!Number.isNaN(paddingValue)) {
      return Math.floor(paddingValue);
    }
  }
  if (typeof padding === "string" && padding.endsWith("%")) {
    const paddingValue = parseFloat(padding);
    if (!Number.isNaN(paddingValue)) {
      return Math.floor(viewport * paddingValue * 0.01);
    }
  }
  console.error(`[React Flow] The padding value "${padding}" is invalid. Please provide a number or a string with a valid unit (px or %).`);
  return 0;
}
function parsePaddings(padding, width, height) {
  var _a3, _b3, _c2, _d, _e, _f, _g, _h;
  if (typeof padding === "string" || typeof padding === "number") {
    const paddingY = parsePadding(padding, height);
    const paddingX = parsePadding(padding, width);
    return {
      top: paddingY,
      right: paddingX,
      bottom: paddingY,
      left: paddingX,
      x: paddingX * 2,
      y: paddingY * 2
    };
  }
  if (typeof padding === "object") {
    const top = parsePadding((_b3 = (_a3 = padding.top) != null ? _a3 : padding.y) != null ? _b3 : 0, height);
    const bottom = parsePadding((_d = (_c2 = padding.bottom) != null ? _c2 : padding.y) != null ? _d : 0, height);
    const left = parsePadding((_f = (_e = padding.left) != null ? _e : padding.x) != null ? _f : 0, width);
    const right = parsePadding((_h = (_g = padding.right) != null ? _g : padding.x) != null ? _h : 0, width);
    return { top, right, bottom, left, x: left + right, y: top + bottom };
  }
  return { top: 0, right: 0, bottom: 0, left: 0, x: 0, y: 0 };
}
function calculateAppliedPaddings(bounds, x, y, zoom2, width, height) {
  const { x: left, y: top } = rendererPointToPoint(bounds, [x, y, zoom2]);
  const { x: boundRight, y: boundBottom } = rendererPointToPoint({ x: bounds.x + bounds.width, y: bounds.y + bounds.height }, [x, y, zoom2]);
  const right = width - boundRight;
  const bottom = height - boundBottom;
  return {
    left: Math.floor(left),
    top: Math.floor(top),
    right: Math.floor(right),
    bottom: Math.floor(bottom)
  };
}
var getViewportForBounds = (bounds, width, height, minZoom, maxZoom, padding) => {
  const p = parsePaddings(padding, width, height);
  const xZoom = (width - p.x) / bounds.width;
  const yZoom = (height - p.y) / bounds.height;
  const zoom2 = Math.min(xZoom, yZoom);
  const clampedZoom = clamp(zoom2, minZoom, maxZoom);
  const boundsCenterX = bounds.x + bounds.width / 2;
  const boundsCenterY = bounds.y + bounds.height / 2;
  const x = width / 2 - boundsCenterX * clampedZoom;
  const y = height / 2 - boundsCenterY * clampedZoom;
  const newPadding = calculateAppliedPaddings(bounds, x, y, clampedZoom, width, height);
  const offset = {
    left: Math.min(newPadding.left - p.left, 0),
    top: Math.min(newPadding.top - p.top, 0),
    right: Math.min(newPadding.right - p.right, 0),
    bottom: Math.min(newPadding.bottom - p.bottom, 0)
  };
  return {
    x: x - offset.left + offset.right,
    y: y - offset.top + offset.bottom,
    zoom: clampedZoom
  };
};
var isMacOs = () => {
  var _a3;
  return typeof navigator !== "undefined" && ((_a3 = navigator == null ? void 0 : navigator.userAgent) == null ? void 0 : _a3.indexOf("Mac")) >= 0;
};
function isCoordinateExtent(extent) {
  return extent !== void 0 && extent !== null && extent !== "parent";
}
function getNodeDimensions(node) {
  var _a3, _b3, _c2, _d, _e, _f, _g, _h;
  return {
    width: (_d = (_c2 = (_b3 = (_a3 = node.measured) == null ? void 0 : _a3.width) != null ? _b3 : node.width) != null ? _c2 : node.initialWidth) != null ? _d : 0,
    height: (_h = (_g = (_f = (_e = node.measured) == null ? void 0 : _e.height) != null ? _f : node.height) != null ? _g : node.initialHeight) != null ? _h : 0
  };
}
function nodeHasDimensions(node) {
  var _a3, _b3, _c2, _d, _e, _f;
  return ((_c2 = (_b3 = (_a3 = node.measured) == null ? void 0 : _a3.width) != null ? _b3 : node.width) != null ? _c2 : node.initialWidth) !== void 0 && ((_f = (_e = (_d = node.measured) == null ? void 0 : _d.height) != null ? _e : node.height) != null ? _f : node.initialHeight) !== void 0;
}
function evaluateAbsolutePosition(position, dimensions = { width: 0, height: 0 }, parentId, nodeLookup, nodeOrigin) {
  var _a3, _b3;
  const positionAbsolute = { ...position };
  const parent = nodeLookup.get(parentId);
  if (parent) {
    const origin = parent.origin || nodeOrigin;
    positionAbsolute.x += parent.internals.positionAbsolute.x - ((_a3 = dimensions.width) != null ? _a3 : 0) * origin[0];
    positionAbsolute.y += parent.internals.positionAbsolute.y - ((_b3 = dimensions.height) != null ? _b3 : 0) * origin[1];
  }
  return positionAbsolute;
}
function mergeAriaLabelConfig(partial) {
  return { ...defaultAriaLabelConfig, ...partial || {} };
}
function getPointerPosition(event2, { snapGrid = [0, 0], snapToGrid = false, transform: transform2, containerBounds }) {
  var _a3, _b3;
  const { x, y } = getEventPosition(event2);
  const pointerPos = pointToRendererPoint({ x: x - ((_a3 = containerBounds == null ? void 0 : containerBounds.left) != null ? _a3 : 0), y: y - ((_b3 = containerBounds == null ? void 0 : containerBounds.top) != null ? _b3 : 0) }, transform2);
  const { x: xSnapped, y: ySnapped } = snapToGrid ? snapPosition(pointerPos, snapGrid) : pointerPos;
  return {
    xSnapped,
    ySnapped,
    ...pointerPos
  };
}
var getDimensions = (node) => ({
  width: node.offsetWidth,
  height: node.offsetHeight
});
var getHostForElement = (element2) => {
  var _a3;
  return ((_a3 = element2 == null ? void 0 : element2.getRootNode) == null ? void 0 : _a3.call(element2)) || (window == null ? void 0 : window.document);
};
var inputTags = ["INPUT", "SELECT", "TEXTAREA"];
function isInputDOMNode(event2) {
  var _a3, _b3;
  const target = ((_b3 = (_a3 = event2.composedPath) == null ? void 0 : _a3.call(event2)) == null ? void 0 : _b3[0]) || event2.target;
  if ((target == null ? void 0 : target.nodeType) !== 1)
    return false;
  const isInput = inputTags.includes(target.nodeName) || target.hasAttribute("contenteditable");
  return isInput || !!target.closest(".nokey");
}
var isMouseEvent = (event2) => "clientX" in event2;
var getEventPosition = (event2, bounds) => {
  var _a3, _b3, _c2, _d;
  const isMouse = isMouseEvent(event2);
  const evtX = isMouse ? event2.clientX : (_a3 = event2.touches) == null ? void 0 : _a3[0].clientX;
  const evtY = isMouse ? event2.clientY : (_b3 = event2.touches) == null ? void 0 : _b3[0].clientY;
  return {
    x: evtX - ((_c2 = bounds == null ? void 0 : bounds.left) != null ? _c2 : 0),
    y: evtY - ((_d = bounds == null ? void 0 : bounds.top) != null ? _d : 0)
  };
};
var getHandleBounds = (type, nodeElement, nodeBounds, zoom2, nodeId) => {
  const handles = nodeElement.querySelectorAll(`.${type}`);
  if (!handles || !handles.length) {
    return null;
  }
  return Array.from(handles).map((handle) => {
    const handleBounds = handle.getBoundingClientRect();
    return {
      id: handle.getAttribute("data-handleid"),
      type,
      nodeId,
      position: handle.getAttribute("data-handlepos"),
      x: (handleBounds.left - nodeBounds.left) / zoom2,
      y: (handleBounds.top - nodeBounds.top) / zoom2,
      ...getDimensions(handle)
    };
  });
};
function getBezierEdgeCenter({ sourceX, sourceY, targetX, targetY, sourceControlX, sourceControlY, targetControlX, targetControlY }) {
  const centerX = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125;
  const centerY = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125;
  const offsetX = Math.abs(centerX - sourceX);
  const offsetY = Math.abs(centerY - sourceY);
  return [centerX, centerY, offsetX, offsetY];
}
function calculateControlOffset(distance2, curvature) {
  if (distance2 >= 0) {
    return 0.5 * distance2;
  }
  return curvature * 25 * Math.sqrt(-distance2);
}
function getControlWithCurvature({ pos, x1, y1, x2, y2, c }) {
  switch (pos) {
    case Position.Left:
      return [x1 - calculateControlOffset(x1 - x2, c), y1];
    case Position.Right:
      return [x1 + calculateControlOffset(x2 - x1, c), y1];
    case Position.Top:
      return [x1, y1 - calculateControlOffset(y1 - y2, c)];
    case Position.Bottom:
      return [x1, y1 + calculateControlOffset(y2 - y1, c)];
  }
}
function getBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, curvature = 0.25 }) {
  const [sourceControlX, sourceControlY] = getControlWithCurvature({
    pos: sourcePosition,
    x1: sourceX,
    y1: sourceY,
    x2: targetX,
    y2: targetY,
    c: curvature
  });
  const [targetControlX, targetControlY] = getControlWithCurvature({
    pos: targetPosition,
    x1: targetX,
    y1: targetY,
    x2: sourceX,
    y2: sourceY,
    c: curvature
  });
  const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourceControlX,
    sourceControlY,
    targetControlX,
    targetControlY
  });
  return [
    `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,
    labelX,
    labelY,
    offsetX,
    offsetY
  ];
}
function getEdgeCenter({ sourceX, sourceY, targetX, targetY }) {
  const xOffset = Math.abs(targetX - sourceX) / 2;
  const centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;
  const yOffset = Math.abs(targetY - sourceY) / 2;
  const centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;
  return [centerX, centerY, xOffset, yOffset];
}
function getElevatedEdgeZIndex({ sourceNode, targetNode, selected = false, zIndex, elevateOnSelect = false }) {
  if (zIndex !== void 0) {
    return zIndex;
  }
  const edgeZ = elevateOnSelect && selected ? 1e3 : 0;
  const nodeZ = Math.max(sourceNode.parentId || elevateOnSelect && sourceNode.selected ? sourceNode.internals.z : 0, targetNode.parentId || elevateOnSelect && targetNode.selected ? targetNode.internals.z : 0);
  return edgeZ + nodeZ;
}
function isEdgeVisible({ sourceNode, targetNode, width, height, transform: transform2 }) {
  const edgeBox = getBoundsOfBoxes(nodeToBox(sourceNode), nodeToBox(targetNode));
  if (edgeBox.x === edgeBox.x2) {
    edgeBox.x2 += 1;
  }
  if (edgeBox.y === edgeBox.y2) {
    edgeBox.y2 += 1;
  }
  const viewRect = {
    x: -transform2[0] / transform2[2],
    y: -transform2[1] / transform2[2],
    width: width / transform2[2],
    height: height / transform2[2]
  };
  return getOverlappingArea(viewRect, boxToRect(edgeBox)) > 0;
}
var getEdgeId = ({ source: source2, sourceHandle, target, targetHandle }) => `xy-edge__${source2}${sourceHandle || ""}-${target}${targetHandle || ""}`;
var connectionExists = (edge, edges) => {
  return edges.some((el) => el.source === edge.source && el.target === edge.target && (el.sourceHandle === edge.sourceHandle || !el.sourceHandle && !edge.sourceHandle) && (el.targetHandle === edge.targetHandle || !el.targetHandle && !edge.targetHandle));
};
var addEdge = (edgeParams, edges) => {
  if (!edgeParams.source || !edgeParams.target) {
    devWarn("006", errorMessages["error006"]());
    return edges;
  }
  let edge;
  if (isEdgeBase(edgeParams)) {
    edge = { ...edgeParams };
  } else {
    edge = {
      ...edgeParams,
      id: getEdgeId(edgeParams)
    };
  }
  if (connectionExists(edge, edges)) {
    return edges;
  }
  if (edge.sourceHandle === null) {
    delete edge.sourceHandle;
  }
  if (edge.targetHandle === null) {
    delete edge.targetHandle;
  }
  return edges.concat(edge);
};
function getStraightPath({ sourceX, sourceY, targetX, targetY }) {
  const [labelX, labelY, offsetX, offsetY] = getEdgeCenter({
    sourceX,
    sourceY,
    targetX,
    targetY
  });
  return [`M ${sourceX},${sourceY}L ${targetX},${targetY}`, labelX, labelY, offsetX, offsetY];
}
var handleDirections = {
  [Position.Left]: { x: -1, y: 0 },
  [Position.Right]: { x: 1, y: 0 },
  [Position.Top]: { x: 0, y: -1 },
  [Position.Bottom]: { x: 0, y: 1 }
};
var getDirection = ({ source: source2, sourcePosition = Position.Bottom, target }) => {
  if (sourcePosition === Position.Left || sourcePosition === Position.Right) {
    return source2.x < target.x ? { x: 1, y: 0 } : { x: -1, y: 0 };
  }
  return source2.y < target.y ? { x: 0, y: 1 } : { x: 0, y: -1 };
};
var distance = (a, b) => Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
function getPoints({ source: source2, sourcePosition = Position.Bottom, target, targetPosition = Position.Top, center, offset, stepPosition }) {
  var _a3, _b3, _c2, _d;
  const sourceDir = handleDirections[sourcePosition];
  const targetDir = handleDirections[targetPosition];
  const sourceGapped = { x: source2.x + sourceDir.x * offset, y: source2.y + sourceDir.y * offset };
  const targetGapped = { x: target.x + targetDir.x * offset, y: target.y + targetDir.y * offset };
  const dir = getDirection({
    source: sourceGapped,
    sourcePosition,
    target: targetGapped
  });
  const dirAccessor = dir.x !== 0 ? "x" : "y";
  const currDir = dir[dirAccessor];
  let points = [];
  let centerX, centerY;
  const sourceGapOffset = { x: 0, y: 0 };
  const targetGapOffset = { x: 0, y: 0 };
  const [, , defaultOffsetX, defaultOffsetY] = getEdgeCenter({
    sourceX: source2.x,
    sourceY: source2.y,
    targetX: target.x,
    targetY: target.y
  });
  if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {
    if (dirAccessor === "x") {
      centerX = (_a3 = center.x) != null ? _a3 : sourceGapped.x + (targetGapped.x - sourceGapped.x) * stepPosition;
      centerY = (_b3 = center.y) != null ? _b3 : (sourceGapped.y + targetGapped.y) / 2;
    } else {
      centerX = (_c2 = center.x) != null ? _c2 : (sourceGapped.x + targetGapped.x) / 2;
      centerY = (_d = center.y) != null ? _d : sourceGapped.y + (targetGapped.y - sourceGapped.y) * stepPosition;
    }
    const verticalSplit = [
      { x: centerX, y: sourceGapped.y },
      { x: centerX, y: targetGapped.y }
    ];
    const horizontalSplit = [
      { x: sourceGapped.x, y: centerY },
      { x: targetGapped.x, y: centerY }
    ];
    if (sourceDir[dirAccessor] === currDir) {
      points = dirAccessor === "x" ? verticalSplit : horizontalSplit;
    } else {
      points = dirAccessor === "x" ? horizontalSplit : verticalSplit;
    }
  } else {
    const sourceTarget = [{ x: sourceGapped.x, y: targetGapped.y }];
    const targetSource = [{ x: targetGapped.x, y: sourceGapped.y }];
    if (dirAccessor === "x") {
      points = sourceDir.x === currDir ? targetSource : sourceTarget;
    } else {
      points = sourceDir.y === currDir ? sourceTarget : targetSource;
    }
    if (sourcePosition === targetPosition) {
      const diff = Math.abs(source2[dirAccessor] - target[dirAccessor]);
      if (diff <= offset) {
        const gapOffset = Math.min(offset - 1, offset - diff);
        if (sourceDir[dirAccessor] === currDir) {
          sourceGapOffset[dirAccessor] = (sourceGapped[dirAccessor] > source2[dirAccessor] ? -1 : 1) * gapOffset;
        } else {
          targetGapOffset[dirAccessor] = (targetGapped[dirAccessor] > target[dirAccessor] ? -1 : 1) * gapOffset;
        }
      }
    }
    if (sourcePosition !== targetPosition) {
      const dirAccessorOpposite = dirAccessor === "x" ? "y" : "x";
      const isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite];
      const sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite];
      const sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];
      const flipSourceTarget = sourceDir[dirAccessor] === 1 && (!isSameDir && sourceGtTargetOppo || isSameDir && sourceLtTargetOppo) || sourceDir[dirAccessor] !== 1 && (!isSameDir && sourceLtTargetOppo || isSameDir && sourceGtTargetOppo);
      if (flipSourceTarget) {
        points = dirAccessor === "x" ? sourceTarget : targetSource;
      }
    }
    const sourceGapPoint = { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y };
    const targetGapPoint = { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y };
    const maxXDistance = Math.max(Math.abs(sourceGapPoint.x - points[0].x), Math.abs(targetGapPoint.x - points[0].x));
    const maxYDistance = Math.max(Math.abs(sourceGapPoint.y - points[0].y), Math.abs(targetGapPoint.y - points[0].y));
    if (maxXDistance >= maxYDistance) {
      centerX = (sourceGapPoint.x + targetGapPoint.x) / 2;
      centerY = points[0].y;
    } else {
      centerX = points[0].x;
      centerY = (sourceGapPoint.y + targetGapPoint.y) / 2;
    }
  }
  const pathPoints = [
    source2,
    { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y },
    ...points,
    { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y },
    target
  ];
  return [pathPoints, centerX, centerY, defaultOffsetX, defaultOffsetY];
}
function getBend(a, b, c, size) {
  const bendSize = Math.min(distance(a, b) / 2, distance(b, c) / 2, size);
  const { x, y } = b;
  if (a.x === x && x === c.x || a.y === y && y === c.y) {
    return `L${x} ${y}`;
  }
  if (a.y === y) {
    const xDir2 = a.x < c.x ? -1 : 1;
    const yDir2 = a.y < c.y ? 1 : -1;
    return `L ${x + bendSize * xDir2},${y}Q ${x},${y} ${x},${y + bendSize * yDir2}`;
  }
  const xDir = a.x < c.x ? 1 : -1;
  const yDir = a.y < c.y ? -1 : 1;
  return `L ${x},${y + bendSize * yDir}Q ${x},${y} ${x + bendSize * xDir},${y}`;
}
function getSmoothStepPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, borderRadius = 5, centerX, centerY, offset = 20, stepPosition = 0.5 }) {
  const [points, labelX, labelY, offsetX, offsetY] = getPoints({
    source: { x: sourceX, y: sourceY },
    sourcePosition,
    target: { x: targetX, y: targetY },
    targetPosition,
    center: { x: centerX, y: centerY },
    offset,
    stepPosition
  });
  const path = points.reduce((res, p, i) => {
    let segment = "";
    if (i > 0 && i < points.length - 1) {
      segment = getBend(points[i - 1], p, points[i + 1], borderRadius);
    } else {
      segment = `${i === 0 ? "M" : "L"}${p.x} ${p.y}`;
    }
    res += segment;
    return res;
  }, "");
  return [path, labelX, labelY, offsetX, offsetY];
}
function isNodeInitialized(node) {
  var _a3;
  return node && !!(node.internals.handleBounds || ((_a3 = node.handles) == null ? void 0 : _a3.length)) && !!(node.measured.width || node.width || node.initialWidth);
}
function getEdgePosition(params) {
  var _a3, _b3, _c2, _d, _e;
  const { sourceNode, targetNode } = params;
  if (!isNodeInitialized(sourceNode) || !isNodeInitialized(targetNode)) {
    return null;
  }
  const sourceHandleBounds = sourceNode.internals.handleBounds || toHandleBounds(sourceNode.handles);
  const targetHandleBounds = targetNode.internals.handleBounds || toHandleBounds(targetNode.handles);
  const sourceHandle = getHandle$1((_a3 = sourceHandleBounds == null ? void 0 : sourceHandleBounds.source) != null ? _a3 : [], params.sourceHandle);
  const targetHandle = getHandle$1(
    // when connection type is loose we can define all handles as sources and connect source -> source
    params.connectionMode === ConnectionMode.Strict ? (_b3 = targetHandleBounds == null ? void 0 : targetHandleBounds.target) != null ? _b3 : [] : ((_c2 = targetHandleBounds == null ? void 0 : targetHandleBounds.target) != null ? _c2 : []).concat((_d = targetHandleBounds == null ? void 0 : targetHandleBounds.source) != null ? _d : []),
    params.targetHandle
  );
  if (!sourceHandle || !targetHandle) {
    (_e = params.onError) == null ? void 0 : _e.call(params, "008", errorMessages["error008"](!sourceHandle ? "source" : "target", {
      id: params.id,
      sourceHandle: params.sourceHandle,
      targetHandle: params.targetHandle
    }));
    return null;
  }
  const sourcePosition = (sourceHandle == null ? void 0 : sourceHandle.position) || Position.Bottom;
  const targetPosition = (targetHandle == null ? void 0 : targetHandle.position) || Position.Top;
  const source2 = getHandlePosition(sourceNode, sourceHandle, sourcePosition);
  const target = getHandlePosition(targetNode, targetHandle, targetPosition);
  return {
    sourceX: source2.x,
    sourceY: source2.y,
    targetX: target.x,
    targetY: target.y,
    sourcePosition,
    targetPosition
  };
}
function toHandleBounds(handles) {
  var _a3, _b3;
  if (!handles) {
    return null;
  }
  const source2 = [];
  const target = [];
  for (const handle of handles) {
    handle.width = (_a3 = handle.width) != null ? _a3 : 1;
    handle.height = (_b3 = handle.height) != null ? _b3 : 1;
    if (handle.type === "source") {
      source2.push(handle);
    } else if (handle.type === "target") {
      target.push(handle);
    }
  }
  return {
    source: source2,
    target
  };
}
function getHandlePosition(node, handle, fallbackPosition = Position.Left, center = false) {
  var _a3, _b3, _c2;
  const x = ((_a3 = handle == null ? void 0 : handle.x) != null ? _a3 : 0) + node.internals.positionAbsolute.x;
  const y = ((_b3 = handle == null ? void 0 : handle.y) != null ? _b3 : 0) + node.internals.positionAbsolute.y;
  const { width, height } = handle != null ? handle : getNodeDimensions(node);
  if (center) {
    return { x: x + width / 2, y: y + height / 2 };
  }
  const position = (_c2 = handle == null ? void 0 : handle.position) != null ? _c2 : fallbackPosition;
  switch (position) {
    case Position.Top:
      return { x: x + width / 2, y };
    case Position.Right:
      return { x: x + width, y: y + height / 2 };
    case Position.Bottom:
      return { x: x + width / 2, y: y + height };
    case Position.Left:
      return { x, y: y + height / 2 };
  }
}
function getHandle$1(bounds, handleId) {
  if (!bounds) {
    return null;
  }
  return (!handleId ? bounds[0] : bounds.find((d) => d.id === handleId)) || null;
}
function getMarkerId(marker, id2) {
  if (!marker) {
    return "";
  }
  if (typeof marker === "string") {
    return marker;
  }
  const idPrefix = id2 ? `${id2}__` : "";
  return `${idPrefix}${Object.keys(marker).sort().map((key3) => `${key3}=${marker[key3]}`).join("&")}`;
}
function createMarkerIds(edges, { id: id2, defaultColor, defaultMarkerStart, defaultMarkerEnd }) {
  const ids = /* @__PURE__ */ new Set();
  return edges.reduce((markers, edge) => {
    [edge.markerStart || defaultMarkerStart, edge.markerEnd || defaultMarkerEnd].forEach((marker) => {
      if (marker && typeof marker === "object") {
        const markerId = getMarkerId(marker, id2);
        if (!ids.has(markerId)) {
          markers.push({ id: markerId, color: marker.color || defaultColor, ...marker });
          ids.add(markerId);
        }
      }
    });
    return markers;
  }, []).sort((a, b) => a.id.localeCompare(b.id));
}
var defaultOptions = {
  nodeOrigin: [0, 0],
  nodeExtent: infiniteExtent,
  elevateNodesOnSelect: true,
  defaults: {}
};
var adoptUserNodesDefaultOptions = {
  ...defaultOptions,
  checkEquality: true
};
function mergeObjects(base, incoming) {
  const result = { ...base };
  for (const key3 in incoming) {
    if (incoming[key3] !== void 0) {
      result[key3] = incoming[key3];
    }
  }
  return result;
}
function updateAbsolutePositions(nodeLookup, parentLookup, options) {
  const _options2 = mergeObjects(defaultOptions, options);
  for (const node of nodeLookup.values()) {
    if (node.parentId) {
      updateChildNode(node, nodeLookup, parentLookup, _options2);
    } else {
      const positionWithOrigin = getNodePositionWithOrigin(node, _options2.nodeOrigin);
      const extent = isCoordinateExtent(node.extent) ? node.extent : _options2.nodeExtent;
      const clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(node));
      node.internals.positionAbsolute = clampedPosition;
    }
  }
}
function parseHandles(userNode, internalNode) {
  var _a3, _b3;
  if (!userNode.handles) {
    return !userNode.measured ? void 0 : internalNode == null ? void 0 : internalNode.internals.handleBounds;
  }
  const source2 = [];
  const target = [];
  for (const handle of userNode.handles) {
    const handleBounds = {
      id: handle.id,
      width: (_a3 = handle.width) != null ? _a3 : 1,
      height: (_b3 = handle.height) != null ? _b3 : 1,
      nodeId: userNode.id,
      x: handle.x,
      y: handle.y,
      position: handle.position,
      type: handle.type
    };
    if (handle.type === "source") {
      source2.push(handleBounds);
    } else if (handle.type === "target") {
      target.push(handleBounds);
    }
  }
  return {
    source: source2,
    target
  };
}
function adoptUserNodes(nodes, nodeLookup, parentLookup, options) {
  var _a3, _b3;
  const _options2 = mergeObjects(adoptUserNodesDefaultOptions, options);
  let nodesInitialized = nodes.length > 0;
  const tmpLookup = new Map(nodeLookup);
  const selectedNodeZ = (_options2 == null ? void 0 : _options2.elevateNodesOnSelect) ? 1e3 : 0;
  nodeLookup.clear();
  parentLookup.clear();
  for (const userNode of nodes) {
    let internalNode = tmpLookup.get(userNode.id);
    if (_options2.checkEquality && userNode === (internalNode == null ? void 0 : internalNode.internals.userNode)) {
      nodeLookup.set(userNode.id, internalNode);
    } else {
      const positionWithOrigin = getNodePositionWithOrigin(userNode, _options2.nodeOrigin);
      const extent = isCoordinateExtent(userNode.extent) ? userNode.extent : _options2.nodeExtent;
      const clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(userNode));
      internalNode = {
        ..._options2.defaults,
        ...userNode,
        measured: {
          width: (_a3 = userNode.measured) == null ? void 0 : _a3.width,
          height: (_b3 = userNode.measured) == null ? void 0 : _b3.height
        },
        internals: {
          positionAbsolute: clampedPosition,
          // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured
          handleBounds: parseHandles(userNode, internalNode),
          z: calculateZ(userNode, selectedNodeZ),
          userNode
        }
      };
      nodeLookup.set(userNode.id, internalNode);
    }
    if ((internalNode.measured === void 0 || internalNode.measured.width === void 0 || internalNode.measured.height === void 0) && !internalNode.hidden) {
      nodesInitialized = false;
    }
    if (userNode.parentId) {
      updateChildNode(internalNode, nodeLookup, parentLookup, options);
    }
  }
  return nodesInitialized;
}
function updateParentLookup(node, parentLookup) {
  if (!node.parentId) {
    return;
  }
  const childNodes = parentLookup.get(node.parentId);
  if (childNodes) {
    childNodes.set(node.id, node);
  } else {
    parentLookup.set(node.parentId, /* @__PURE__ */ new Map([[node.id, node]]));
  }
}
function updateChildNode(node, nodeLookup, parentLookup, options) {
  const { elevateNodesOnSelect, nodeOrigin, nodeExtent } = mergeObjects(defaultOptions, options);
  const parentId = node.parentId;
  const parentNode = nodeLookup.get(parentId);
  if (!parentNode) {
    console.warn(`Parent node ${parentId} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);
    return;
  }
  updateParentLookup(node, parentLookup);
  const selectedNodeZ = elevateNodesOnSelect ? 1e3 : 0;
  const { x, y, z } = calculateChildXYZ(node, parentNode, nodeOrigin, nodeExtent, selectedNodeZ);
  const { positionAbsolute } = node.internals;
  const positionChanged = x !== positionAbsolute.x || y !== positionAbsolute.y;
  if (positionChanged || z !== node.internals.z) {
    nodeLookup.set(node.id, {
      ...node,
      internals: {
        ...node.internals,
        positionAbsolute: positionChanged ? { x, y } : positionAbsolute,
        z
      }
    });
  }
}
function calculateZ(node, selectedNodeZ) {
  return (isNumeric(node.zIndex) ? node.zIndex : 0) + (node.selected ? selectedNodeZ : 0);
}
function calculateChildXYZ(childNode, parentNode, nodeOrigin, nodeExtent, selectedNodeZ) {
  var _a3;
  const { x: parentX, y: parentY } = parentNode.internals.positionAbsolute;
  const childDimensions = getNodeDimensions(childNode);
  const positionWithOrigin = getNodePositionWithOrigin(childNode, nodeOrigin);
  const clampedPosition = isCoordinateExtent(childNode.extent) ? clampPosition(positionWithOrigin, childNode.extent, childDimensions) : positionWithOrigin;
  let absolutePosition = clampPosition({ x: parentX + clampedPosition.x, y: parentY + clampedPosition.y }, nodeExtent, childDimensions);
  if (childNode.extent === "parent") {
    absolutePosition = clampPositionToParent(absolutePosition, childDimensions, parentNode);
  }
  const childZ = calculateZ(childNode, selectedNodeZ);
  const parentZ = (_a3 = parentNode.internals.z) != null ? _a3 : 0;
  return {
    x: absolutePosition.x,
    y: absolutePosition.y,
    z: parentZ >= childZ ? parentZ + 1 : childZ
  };
}
function handleExpandParent(children2, nodeLookup, parentLookup, nodeOrigin = [0, 0]) {
  var _a3, _b3;
  const changes = [];
  const parentExpansions = /* @__PURE__ */ new Map();
  for (const child2 of children2) {
    const parent = nodeLookup.get(child2.parentId);
    if (!parent) {
      continue;
    }
    const parentRect = (_b3 = (_a3 = parentExpansions.get(child2.parentId)) == null ? void 0 : _a3.expandedRect) != null ? _b3 : nodeToRect(parent);
    const expandedRect = getBoundsOfRects(parentRect, child2.rect);
    parentExpansions.set(child2.parentId, { expandedRect, parent });
  }
  if (parentExpansions.size > 0) {
    parentExpansions.forEach(({ expandedRect, parent }, parentId) => {
      var _a4, _b4;
      const positionAbsolute = parent.internals.positionAbsolute;
      const dimensions = getNodeDimensions(parent);
      const origin = (_a4 = parent.origin) != null ? _a4 : nodeOrigin;
      const xChange = expandedRect.x < positionAbsolute.x ? Math.round(Math.abs(positionAbsolute.x - expandedRect.x)) : 0;
      const yChange = expandedRect.y < positionAbsolute.y ? Math.round(Math.abs(positionAbsolute.y - expandedRect.y)) : 0;
      const newWidth = Math.max(dimensions.width, Math.round(expandedRect.width));
      const newHeight = Math.max(dimensions.height, Math.round(expandedRect.height));
      const widthChange = (newWidth - dimensions.width) * origin[0];
      const heightChange = (newHeight - dimensions.height) * origin[1];
      if (xChange > 0 || yChange > 0 || widthChange || heightChange) {
        changes.push({
          id: parentId,
          type: "position",
          position: {
            x: parent.position.x - xChange + widthChange,
            y: parent.position.y - yChange + heightChange
          }
        });
        (_b4 = parentLookup.get(parentId)) == null ? void 0 : _b4.forEach((childNode) => {
          if (!children2.some((child2) => child2.id === childNode.id)) {
            changes.push({
              id: childNode.id,
              type: "position",
              position: {
                x: childNode.position.x + xChange,
                y: childNode.position.y + yChange
              }
            });
          }
        });
      }
      if (dimensions.width < expandedRect.width || dimensions.height < expandedRect.height || xChange || yChange) {
        changes.push({
          id: parentId,
          type: "dimensions",
          setAttributes: true,
          dimensions: {
            width: newWidth + (xChange ? origin[0] * xChange - widthChange : 0),
            height: newHeight + (yChange ? origin[1] * yChange - heightChange : 0)
          }
        });
      }
    });
  }
  return changes;
}
function updateNodeInternals(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent) {
  const viewportNode = domNode == null ? void 0 : domNode.querySelector(".xyflow__viewport");
  let updatedInternals = false;
  if (!viewportNode) {
    return { changes: [], updatedInternals };
  }
  const changes = [];
  const style = window.getComputedStyle(viewportNode);
  const { m22: zoom2 } = new window.DOMMatrixReadOnly(style.transform);
  const parentExpandChildren = [];
  for (const update2 of updates.values()) {
    const node = nodeLookup.get(update2.id);
    if (!node) {
      continue;
    }
    if (node.hidden) {
      nodeLookup.set(node.id, {
        ...node,
        internals: {
          ...node.internals,
          handleBounds: void 0
        }
      });
      updatedInternals = true;
      continue;
    }
    const dimensions = getDimensions(update2.nodeElement);
    const dimensionChanged = node.measured.width !== dimensions.width || node.measured.height !== dimensions.height;
    const doUpdate = !!(dimensions.width && dimensions.height && (dimensionChanged || !node.internals.handleBounds || update2.force));
    if (doUpdate) {
      const nodeBounds = update2.nodeElement.getBoundingClientRect();
      const extent = isCoordinateExtent(node.extent) ? node.extent : nodeExtent;
      let { positionAbsolute } = node.internals;
      if (node.parentId && node.extent === "parent") {
        positionAbsolute = clampPositionToParent(positionAbsolute, dimensions, nodeLookup.get(node.parentId));
      } else if (extent) {
        positionAbsolute = clampPosition(positionAbsolute, extent, dimensions);
      }
      const newNode = {
        ...node,
        measured: dimensions,
        internals: {
          ...node.internals,
          positionAbsolute,
          handleBounds: {
            source: getHandleBounds("source", update2.nodeElement, nodeBounds, zoom2, node.id),
            target: getHandleBounds("target", update2.nodeElement, nodeBounds, zoom2, node.id)
          }
        }
      };
      nodeLookup.set(node.id, newNode);
      if (node.parentId) {
        updateChildNode(newNode, nodeLookup, parentLookup, { nodeOrigin });
      }
      updatedInternals = true;
      if (dimensionChanged) {
        changes.push({
          id: node.id,
          type: "dimensions",
          dimensions
        });
        if (node.expandParent && node.parentId) {
          parentExpandChildren.push({
            id: node.id,
            parentId: node.parentId,
            rect: nodeToRect(newNode, nodeOrigin)
          });
        }
      }
    }
  }
  if (parentExpandChildren.length > 0) {
    const parentExpandChanges = handleExpandParent(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);
    changes.push(...parentExpandChanges);
  }
  return { changes, updatedInternals };
}
async function panBy({ delta, panZoom, transform: transform2, translateExtent, width, height }) {
  if (!panZoom || !delta.x && !delta.y) {
    return Promise.resolve(false);
  }
  const nextViewport = await panZoom.setViewportConstrained({
    x: transform2[0] + delta.x,
    y: transform2[1] + delta.y,
    zoom: transform2[2]
  }, [
    [0, 0],
    [width, height]
  ], translateExtent);
  const transformChanged = !!nextViewport && (nextViewport.x !== transform2[0] || nextViewport.y !== transform2[1] || nextViewport.k !== transform2[2]);
  return Promise.resolve(transformChanged);
}
function addConnectionToLookup(type, connection, connectionKey, connectionLookup, nodeId, handleId) {
  let key3 = nodeId;
  const nodeMap = connectionLookup.get(key3) || /* @__PURE__ */ new Map();
  connectionLookup.set(key3, nodeMap.set(connectionKey, connection));
  key3 = `${nodeId}-${type}`;
  const typeMap = connectionLookup.get(key3) || /* @__PURE__ */ new Map();
  connectionLookup.set(key3, typeMap.set(connectionKey, connection));
  if (handleId) {
    key3 = `${nodeId}-${type}-${handleId}`;
    const handleMap = connectionLookup.get(key3) || /* @__PURE__ */ new Map();
    connectionLookup.set(key3, handleMap.set(connectionKey, connection));
  }
}
function updateConnectionLookup(connectionLookup, edgeLookup, edges) {
  connectionLookup.clear();
  edgeLookup.clear();
  for (const edge of edges) {
    const { source: sourceNode, target: targetNode, sourceHandle = null, targetHandle = null } = edge;
    const connection = { edgeId: edge.id, source: sourceNode, target: targetNode, sourceHandle, targetHandle };
    const sourceKey = `${sourceNode}-${sourceHandle}--${targetNode}-${targetHandle}`;
    const targetKey = `${targetNode}-${targetHandle}--${sourceNode}-${sourceHandle}`;
    addConnectionToLookup("source", connection, targetKey, connectionLookup, sourceNode, sourceHandle);
    addConnectionToLookup("target", connection, sourceKey, connectionLookup, targetNode, targetHandle);
    edgeLookup.set(edge.id, edge);
  }
}
function isParentSelected(node, nodeLookup) {
  if (!node.parentId) {
    return false;
  }
  const parentNode = nodeLookup.get(node.parentId);
  if (!parentNode) {
    return false;
  }
  if (parentNode.selected) {
    return true;
  }
  return isParentSelected(parentNode, nodeLookup);
}
function hasSelector(target, selector, domNode) {
  var _a3;
  let current = target;
  do {
    if ((_a3 = current == null ? void 0 : current.matches) == null ? void 0 : _a3.call(current, selector))
      return true;
    if (current === domNode)
      return false;
    current = current == null ? void 0 : current.parentElement;
  } while (current);
  return false;
}
function getDragItems(nodeLookup, nodesDraggable, mousePos, nodeId) {
  var _a3, _b3;
  const dragItems = /* @__PURE__ */ new Map();
  for (const [id2, node] of nodeLookup) {
    if ((node.selected || node.id === nodeId) && (!node.parentId || !isParentSelected(node, nodeLookup)) && (node.draggable || nodesDraggable && typeof node.draggable === "undefined")) {
      const internalNode = nodeLookup.get(id2);
      if (internalNode) {
        dragItems.set(id2, {
          id: id2,
          position: internalNode.position || { x: 0, y: 0 },
          distance: {
            x: mousePos.x - internalNode.internals.positionAbsolute.x,
            y: mousePos.y - internalNode.internals.positionAbsolute.y
          },
          extent: internalNode.extent,
          parentId: internalNode.parentId,
          origin: internalNode.origin,
          expandParent: internalNode.expandParent,
          internals: {
            positionAbsolute: internalNode.internals.positionAbsolute || { x: 0, y: 0 }
          },
          measured: {
            width: (_a3 = internalNode.measured.width) != null ? _a3 : 0,
            height: (_b3 = internalNode.measured.height) != null ? _b3 : 0
          }
        });
      }
    }
  }
  return dragItems;
}
function getEventHandlerParams({ nodeId, dragItems, nodeLookup, dragging = true }) {
  var _a3, _b3, _c2;
  const nodesFromDragItems = [];
  for (const [id2, dragItem] of dragItems) {
    const node2 = (_a3 = nodeLookup.get(id2)) == null ? void 0 : _a3.internals.userNode;
    if (node2) {
      nodesFromDragItems.push({
        ...node2,
        position: dragItem.position,
        dragging
      });
    }
  }
  if (!nodeId) {
    return [nodesFromDragItems[0], nodesFromDragItems];
  }
  const node = (_b3 = nodeLookup.get(nodeId)) == null ? void 0 : _b3.internals.userNode;
  return [
    !node ? nodesFromDragItems[0] : {
      ...node,
      position: ((_c2 = dragItems.get(nodeId)) == null ? void 0 : _c2.position) || node.position,
      dragging
    },
    nodesFromDragItems
  ];
}
function calculateSnapOffset({ dragItems, snapGrid, x, y }) {
  const refDragItem = dragItems.values().next().value;
  if (!refDragItem) {
    return null;
  }
  const refPos = {
    x: x - refDragItem.distance.x,
    y: y - refDragItem.distance.y
  };
  const refPosSnapped = snapPosition(refPos, snapGrid);
  return {
    x: refPosSnapped.x - refPos.x,
    y: refPosSnapped.y - refPos.y
  };
}
function XYDrag({ onNodeMouseDown, getStoreItems, onDragStart, onDrag, onDragStop }) {
  let lastPos = { x: null, y: null };
  let autoPanId = 0;
  let dragItems = /* @__PURE__ */ new Map();
  let autoPanStarted = false;
  let mousePosition = { x: 0, y: 0 };
  let containerBounds = null;
  let dragStarted = false;
  let d3Selection = null;
  let abortDrag = false;
  let nodePositionsChanged = false;
  let dragEvent = null;
  function update2({ noDragClassName, handleSelector, domNode, isSelectable, nodeId, nodeClickDistance = 0 }) {
    d3Selection = select_default2(domNode);
    function updateNodes({ x, y }) {
      const { nodeLookup, nodeExtent, snapGrid, snapToGrid, nodeOrigin, onNodeDrag, onSelectionDrag, onError, updateNodePositions } = getStoreItems();
      lastPos = { x, y };
      let hasChange = false;
      const isMultiDrag = dragItems.size > 1;
      const nodesBox = isMultiDrag && nodeExtent ? rectToBox(getInternalNodesBounds(dragItems)) : null;
      const multiDragSnapOffset = isMultiDrag && snapToGrid ? calculateSnapOffset({
        dragItems,
        snapGrid,
        x,
        y
      }) : null;
      for (const [id2, dragItem] of dragItems) {
        if (!nodeLookup.has(id2)) {
          continue;
        }
        let nextPosition = { x: x - dragItem.distance.x, y: y - dragItem.distance.y };
        if (snapToGrid) {
          nextPosition = multiDragSnapOffset ? {
            x: Math.round(nextPosition.x + multiDragSnapOffset.x),
            y: Math.round(nextPosition.y + multiDragSnapOffset.y)
          } : snapPosition(nextPosition, snapGrid);
        }
        let adjustedNodeExtent = null;
        if (isMultiDrag && nodeExtent && !dragItem.extent && nodesBox) {
          const { positionAbsolute: positionAbsolute2 } = dragItem.internals;
          const x1 = positionAbsolute2.x - nodesBox.x + nodeExtent[0][0];
          const x2 = positionAbsolute2.x + dragItem.measured.width - nodesBox.x2 + nodeExtent[1][0];
          const y1 = positionAbsolute2.y - nodesBox.y + nodeExtent[0][1];
          const y2 = positionAbsolute2.y + dragItem.measured.height - nodesBox.y2 + nodeExtent[1][1];
          adjustedNodeExtent = [
            [x1, y1],
            [x2, y2]
          ];
        }
        const { position, positionAbsolute } = calculateNodePosition({
          nodeId: id2,
          nextPosition,
          nodeLookup,
          nodeExtent: adjustedNodeExtent ? adjustedNodeExtent : nodeExtent,
          nodeOrigin,
          onError
        });
        hasChange = hasChange || dragItem.position.x !== position.x || dragItem.position.y !== position.y;
        dragItem.position = position;
        dragItem.internals.positionAbsolute = positionAbsolute;
      }
      nodePositionsChanged = nodePositionsChanged || hasChange;
      if (!hasChange) {
        return;
      }
      updateNodePositions(dragItems, true);
      if (dragEvent && (onDrag || onNodeDrag || !nodeId && onSelectionDrag)) {
        const [currentNode, currentNodes] = getEventHandlerParams({
          nodeId,
          dragItems,
          nodeLookup
        });
        onDrag == null ? void 0 : onDrag(dragEvent, dragItems, currentNode, currentNodes);
        onNodeDrag == null ? void 0 : onNodeDrag(dragEvent, currentNode, currentNodes);
        if (!nodeId) {
          onSelectionDrag == null ? void 0 : onSelectionDrag(dragEvent, currentNodes);
        }
      }
    }
    async function autoPan() {
      var _a3, _b3;
      if (!containerBounds) {
        return;
      }
      const { transform: transform2, panBy: panBy2, autoPanSpeed, autoPanOnNodeDrag } = getStoreItems();
      if (!autoPanOnNodeDrag) {
        autoPanStarted = false;
        cancelAnimationFrame(autoPanId);
        return;
      }
      const [xMovement, yMovement] = calcAutoPan(mousePosition, containerBounds, autoPanSpeed);
      if (xMovement !== 0 || yMovement !== 0) {
        lastPos.x = ((_a3 = lastPos.x) != null ? _a3 : 0) - xMovement / transform2[2];
        lastPos.y = ((_b3 = lastPos.y) != null ? _b3 : 0) - yMovement / transform2[2];
        if (await panBy2({ x: xMovement, y: yMovement })) {
          updateNodes(lastPos);
        }
      }
      autoPanId = requestAnimationFrame(autoPan);
    }
    function startDrag(event2) {
      var _a3;
      const { nodeLookup, multiSelectionActive, nodesDraggable, transform: transform2, snapGrid, snapToGrid, selectNodesOnDrag, onNodeDragStart, onSelectionDragStart, unselectNodesAndEdges } = getStoreItems();
      dragStarted = true;
      if ((!selectNodesOnDrag || !isSelectable) && !multiSelectionActive && nodeId) {
        if (!((_a3 = nodeLookup.get(nodeId)) == null ? void 0 : _a3.selected)) {
          unselectNodesAndEdges();
        }
      }
      if (isSelectable && selectNodesOnDrag && nodeId) {
        onNodeMouseDown == null ? void 0 : onNodeMouseDown(nodeId);
      }
      const pointerPos = getPointerPosition(event2.sourceEvent, { transform: transform2, snapGrid, snapToGrid, containerBounds });
      lastPos = pointerPos;
      dragItems = getDragItems(nodeLookup, nodesDraggable, pointerPos, nodeId);
      if (dragItems.size > 0 && (onDragStart || onNodeDragStart || !nodeId && onSelectionDragStart)) {
        const [currentNode, currentNodes] = getEventHandlerParams({
          nodeId,
          dragItems,
          nodeLookup
        });
        onDragStart == null ? void 0 : onDragStart(event2.sourceEvent, dragItems, currentNode, currentNodes);
        onNodeDragStart == null ? void 0 : onNodeDragStart(event2.sourceEvent, currentNode, currentNodes);
        if (!nodeId) {
          onSelectionDragStart == null ? void 0 : onSelectionDragStart(event2.sourceEvent, currentNodes);
        }
      }
    }
    const d3DragInstance = drag_default().clickDistance(nodeClickDistance).on("start", (event2) => {
      const { domNode: domNode2, nodeDragThreshold, transform: transform2, snapGrid, snapToGrid } = getStoreItems();
      containerBounds = (domNode2 == null ? void 0 : domNode2.getBoundingClientRect()) || null;
      abortDrag = false;
      nodePositionsChanged = false;
      dragEvent = event2.sourceEvent;
      if (nodeDragThreshold === 0) {
        startDrag(event2);
      }
      const pointerPos = getPointerPosition(event2.sourceEvent, { transform: transform2, snapGrid, snapToGrid, containerBounds });
      lastPos = pointerPos;
      mousePosition = getEventPosition(event2.sourceEvent, containerBounds);
    }).on("drag", (event2) => {
      const { autoPanOnNodeDrag, transform: transform2, snapGrid, snapToGrid, nodeDragThreshold, nodeLookup } = getStoreItems();
      const pointerPos = getPointerPosition(event2.sourceEvent, { transform: transform2, snapGrid, snapToGrid, containerBounds });
      dragEvent = event2.sourceEvent;
      if (event2.sourceEvent.type === "touchmove" && event2.sourceEvent.touches.length > 1 || // if user deletes a node while dragging, we need to abort the drag to prevent errors
      nodeId && !nodeLookup.has(nodeId)) {
        abortDrag = true;
      }
      if (abortDrag) {
        return;
      }
      if (!autoPanStarted && autoPanOnNodeDrag && dragStarted) {
        autoPanStarted = true;
        autoPan();
      }
      if (!dragStarted) {
        const currentMousePosition = getEventPosition(event2.sourceEvent, containerBounds);
        const x = currentMousePosition.x - mousePosition.x;
        const y = currentMousePosition.y - mousePosition.y;
        const distance2 = Math.sqrt(x * x + y * y);
        if (distance2 > nodeDragThreshold) {
          startDrag(event2);
        }
      }
      if ((lastPos.x !== pointerPos.xSnapped || lastPos.y !== pointerPos.ySnapped) && dragItems && dragStarted) {
        mousePosition = getEventPosition(event2.sourceEvent, containerBounds);
        updateNodes(pointerPos);
      }
    }).on("end", (event2) => {
      if (!dragStarted || abortDrag) {
        return;
      }
      autoPanStarted = false;
      dragStarted = false;
      cancelAnimationFrame(autoPanId);
      if (dragItems.size > 0) {
        const { nodeLookup, updateNodePositions, onNodeDragStop, onSelectionDragStop } = getStoreItems();
        if (nodePositionsChanged) {
          updateNodePositions(dragItems, false);
          nodePositionsChanged = false;
        }
        if (onDragStop || onNodeDragStop || !nodeId && onSelectionDragStop) {
          const [currentNode, currentNodes] = getEventHandlerParams({
            nodeId,
            dragItems,
            nodeLookup,
            dragging: false
          });
          onDragStop == null ? void 0 : onDragStop(event2.sourceEvent, dragItems, currentNode, currentNodes);
          onNodeDragStop == null ? void 0 : onNodeDragStop(event2.sourceEvent, currentNode, currentNodes);
          if (!nodeId) {
            onSelectionDragStop == null ? void 0 : onSelectionDragStop(event2.sourceEvent, currentNodes);
          }
        }
      }
    }).filter((event2) => {
      const target = event2.target;
      const isDraggable = !event2.button && (!noDragClassName || !hasSelector(target, `.${noDragClassName}`, domNode)) && (!handleSelector || hasSelector(target, handleSelector, domNode));
      return isDraggable;
    });
    d3Selection.call(d3DragInstance);
  }
  function destroy() {
    d3Selection == null ? void 0 : d3Selection.on(".drag", null);
  }
  return {
    update: update2,
    destroy
  };
}
function getNodesWithinDistance(position, nodeLookup, distance2) {
  const nodes = [];
  const rect = {
    x: position.x - distance2,
    y: position.y - distance2,
    width: distance2 * 2,
    height: distance2 * 2
  };
  for (const node of nodeLookup.values()) {
    if (getOverlappingArea(rect, nodeToRect(node)) > 0) {
      nodes.push(node);
    }
  }
  return nodes;
}
var ADDITIONAL_DISTANCE = 250;
function getClosestHandle(position, connectionRadius, nodeLookup, fromHandle) {
  var _a3, _b3, _c2, _d, _e;
  let closestHandles = [];
  let minDistance = Infinity;
  const closeNodes = getNodesWithinDistance(position, nodeLookup, connectionRadius + ADDITIONAL_DISTANCE);
  for (const node of closeNodes) {
    const allHandles = [...(_b3 = (_a3 = node.internals.handleBounds) == null ? void 0 : _a3.source) != null ? _b3 : [], ...(_d = (_c2 = node.internals.handleBounds) == null ? void 0 : _c2.target) != null ? _d : []];
    for (const handle of allHandles) {
      if (fromHandle.nodeId === handle.nodeId && fromHandle.type === handle.type && fromHandle.id === handle.id) {
        continue;
      }
      const { x, y } = getHandlePosition(node, handle, handle.position, true);
      const distance2 = Math.sqrt(Math.pow(x - position.x, 2) + Math.pow(y - position.y, 2));
      if (distance2 > connectionRadius) {
        continue;
      }
      if (distance2 < minDistance) {
        closestHandles = [{ ...handle, x, y }];
        minDistance = distance2;
      } else if (distance2 === minDistance) {
        closestHandles.push({ ...handle, x, y });
      }
    }
  }
  if (!closestHandles.length) {
    return null;
  }
  if (closestHandles.length > 1) {
    const oppositeHandleType = fromHandle.type === "source" ? "target" : "source";
    return (_e = closestHandles.find((handle) => handle.type === oppositeHandleType)) != null ? _e : closestHandles[0];
  }
  return closestHandles[0];
}
function getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode, withAbsolutePosition = false) {
  var _a3, _b3, _c2, _d, _e, _f;
  const node = nodeLookup.get(nodeId);
  if (!node) {
    return null;
  }
  const handles = connectionMode === "strict" ? (_a3 = node.internals.handleBounds) == null ? void 0 : _a3[handleType] : [...(_c2 = (_b3 = node.internals.handleBounds) == null ? void 0 : _b3.source) != null ? _c2 : [], ...(_e = (_d = node.internals.handleBounds) == null ? void 0 : _d.target) != null ? _e : []];
  const handle = (_f = handleId ? handles == null ? void 0 : handles.find((h) => h.id === handleId) : handles == null ? void 0 : handles[0]) != null ? _f : null;
  return handle && withAbsolutePosition ? { ...handle, ...getHandlePosition(node, handle, handle.position, true) } : handle;
}
function getHandleType(edgeUpdaterType, handleDomNode) {
  if (edgeUpdaterType) {
    return edgeUpdaterType;
  } else if (handleDomNode == null ? void 0 : handleDomNode.classList.contains("target")) {
    return "target";
  } else if (handleDomNode == null ? void 0 : handleDomNode.classList.contains("source")) {
    return "source";
  }
  return null;
}
function isConnectionValid(isInsideConnectionRadius, isHandleValid) {
  let isValid = null;
  if (isHandleValid) {
    isValid = true;
  } else if (isInsideConnectionRadius && !isHandleValid) {
    isValid = false;
  }
  return isValid;
}
var alwaysValid = () => true;
function onPointerDown(event2, { connectionMode, connectionRadius, handleId, nodeId, edgeUpdaterType, isTarget, domNode, nodeLookup, lib, autoPanOnConnect, flowId, panBy: panBy2, cancelConnection, onConnectStart, onConnect, onConnectEnd, isValidConnection = alwaysValid, onReconnectEnd, updateConnection, getTransform, getFromHandle, autoPanSpeed, dragThreshold = 1, handleDomNode }) {
  const doc = getHostForElement(event2.target);
  let autoPanId = 0;
  let closestHandle;
  const { x, y } = getEventPosition(event2);
  const handleType = getHandleType(edgeUpdaterType, handleDomNode);
  const containerBounds = domNode == null ? void 0 : domNode.getBoundingClientRect();
  let connectionStarted = false;
  if (!containerBounds || !handleType) {
    return;
  }
  const fromHandleInternal = getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode);
  if (!fromHandleInternal) {
    return;
  }
  let position = getEventPosition(event2, containerBounds);
  let autoPanStarted = false;
  let connection = null;
  let isValid = false;
  let resultHandleDomNode = null;
  function autoPan() {
    if (!autoPanOnConnect || !containerBounds) {
      return;
    }
    const [x2, y2] = calcAutoPan(position, containerBounds, autoPanSpeed);
    panBy2({ x: x2, y: y2 });
    autoPanId = requestAnimationFrame(autoPan);
  }
  const fromHandle = {
    ...fromHandleInternal,
    nodeId,
    type: handleType,
    position: fromHandleInternal.position
  };
  const fromNodeInternal = nodeLookup.get(nodeId);
  const from = getHandlePosition(fromNodeInternal, fromHandle, Position.Left, true);
  let previousConnection = {
    inProgress: true,
    isValid: null,
    from,
    fromHandle,
    fromPosition: fromHandle.position,
    fromNode: fromNodeInternal,
    to: position,
    toHandle: null,
    toPosition: oppositePosition[fromHandle.position],
    toNode: null
  };
  function startConnection() {
    connectionStarted = true;
    updateConnection(previousConnection);
    onConnectStart == null ? void 0 : onConnectStart(event2, { nodeId, handleId, handleType });
  }
  if (dragThreshold === 0) {
    startConnection();
  }
  function onPointerMove(event3) {
    if (!connectionStarted) {
      const { x: evtX, y: evtY } = getEventPosition(event3);
      const dx = evtX - x;
      const dy = evtY - y;
      const nextConnectionStarted = dx * dx + dy * dy > dragThreshold * dragThreshold;
      if (!nextConnectionStarted) {
        return;
      }
      startConnection();
    }
    if (!getFromHandle() || !fromHandle) {
      onPointerUp(event3);
      return;
    }
    const transform2 = getTransform();
    position = getEventPosition(event3, containerBounds);
    closestHandle = getClosestHandle(pointToRendererPoint(position, transform2, false, [1, 1]), connectionRadius, nodeLookup, fromHandle);
    if (!autoPanStarted) {
      autoPan();
      autoPanStarted = true;
    }
    const result = isValidHandle(event3, {
      handle: closestHandle,
      connectionMode,
      fromNodeId: nodeId,
      fromHandleId: handleId,
      fromType: isTarget ? "target" : "source",
      isValidConnection,
      doc,
      lib,
      flowId,
      nodeLookup
    });
    resultHandleDomNode = result.handleDomNode;
    connection = result.connection;
    isValid = isConnectionValid(!!closestHandle, result.isValid);
    const newConnection = {
      // from stays the same
      ...previousConnection,
      isValid,
      to: result.toHandle && isValid ? rendererPointToPoint({ x: result.toHandle.x, y: result.toHandle.y }, transform2) : position,
      toHandle: result.toHandle,
      toPosition: isValid && result.toHandle ? result.toHandle.position : oppositePosition[fromHandle.position],
      toNode: result.toHandle ? nodeLookup.get(result.toHandle.nodeId) : null
    };
    if (isValid && closestHandle && previousConnection.toHandle && newConnection.toHandle && previousConnection.toHandle.type === newConnection.toHandle.type && previousConnection.toHandle.nodeId === newConnection.toHandle.nodeId && previousConnection.toHandle.id === newConnection.toHandle.id && previousConnection.to.x === newConnection.to.x && previousConnection.to.y === newConnection.to.y) {
      return;
    }
    updateConnection(newConnection);
    previousConnection = newConnection;
  }
  function onPointerUp(event3) {
    if ("touches" in event3 && event3.touches.length > 0) {
      return;
    }
    if (connectionStarted) {
      if ((closestHandle || resultHandleDomNode) && connection && isValid) {
        onConnect == null ? void 0 : onConnect(connection);
      }
      const { inProgress, ...connectionState } = previousConnection;
      const finalConnectionState = {
        ...connectionState,
        toPosition: previousConnection.toHandle ? previousConnection.toPosition : null
      };
      onConnectEnd == null ? void 0 : onConnectEnd(event3, finalConnectionState);
      if (edgeUpdaterType) {
        onReconnectEnd == null ? void 0 : onReconnectEnd(event3, finalConnectionState);
      }
    }
    cancelConnection();
    cancelAnimationFrame(autoPanId);
    autoPanStarted = false;
    isValid = false;
    connection = null;
    resultHandleDomNode = null;
    doc.removeEventListener("mousemove", onPointerMove);
    doc.removeEventListener("mouseup", onPointerUp);
    doc.removeEventListener("touchmove", onPointerMove);
    doc.removeEventListener("touchend", onPointerUp);
  }
  doc.addEventListener("mousemove", onPointerMove);
  doc.addEventListener("mouseup", onPointerUp);
  doc.addEventListener("touchmove", onPointerMove);
  doc.addEventListener("touchend", onPointerUp);
}
function isValidHandle(event2, { handle, connectionMode, fromNodeId, fromHandleId, fromType, doc, lib, flowId, isValidConnection = alwaysValid, nodeLookup }) {
  const isTarget = fromType === "target";
  const handleDomNode = handle ? doc.querySelector(`.${lib}-flow__handle[data-id="${flowId}-${handle == null ? void 0 : handle.nodeId}-${handle == null ? void 0 : handle.id}-${handle == null ? void 0 : handle.type}"]`) : null;
  const { x, y } = getEventPosition(event2);
  const handleBelow = doc.elementFromPoint(x, y);
  const handleToCheck = (handleBelow == null ? void 0 : handleBelow.classList.contains(`${lib}-flow__handle`)) ? handleBelow : handleDomNode;
  const result = {
    handleDomNode: handleToCheck,
    isValid: false,
    connection: null,
    toHandle: null
  };
  if (handleToCheck) {
    const handleType = getHandleType(void 0, handleToCheck);
    const handleNodeId = handleToCheck.getAttribute("data-nodeid");
    const handleId = handleToCheck.getAttribute("data-handleid");
    const connectable = handleToCheck.classList.contains("connectable");
    const connectableEnd = handleToCheck.classList.contains("connectableend");
    if (!handleNodeId || !handleType) {
      return result;
    }
    const connection = {
      source: isTarget ? handleNodeId : fromNodeId,
      sourceHandle: isTarget ? handleId : fromHandleId,
      target: isTarget ? fromNodeId : handleNodeId,
      targetHandle: isTarget ? fromHandleId : handleId
    };
    result.connection = connection;
    const isConnectable = connectable && connectableEnd;
    const isValid = isConnectable && (connectionMode === ConnectionMode.Strict ? isTarget && handleType === "source" || !isTarget && handleType === "target" : handleNodeId !== fromNodeId || handleId !== fromHandleId);
    result.isValid = isValid && isValidConnection(connection);
    result.toHandle = getHandle(handleNodeId, handleType, handleId, nodeLookup, connectionMode, true);
  }
  return result;
}
var XYHandle = {
  onPointerDown,
  isValid: isValidHandle
};
function XYMinimap({ domNode, panZoom, getTransform, getViewScale }) {
  const selection2 = select_default2(domNode);
  function update2({ translateExtent, width, height, zoomStep = 1, pannable = true, zoomable = true, inversePan = false }) {
    const zoomHandler = (event2) => {
      if (event2.sourceEvent.type !== "wheel" || !panZoom) {
        return;
      }
      const transform2 = getTransform();
      const factor = event2.sourceEvent.ctrlKey && isMacOs() ? 10 : 1;
      const pinchDelta = -event2.sourceEvent.deltaY * (event2.sourceEvent.deltaMode === 1 ? 0.05 : event2.sourceEvent.deltaMode ? 1 : 2e-3) * zoomStep;
      const nextZoom = transform2[2] * Math.pow(2, pinchDelta * factor);
      panZoom.scaleTo(nextZoom);
    };
    let panStart = [0, 0];
    const panStartHandler = (event2) => {
      var _a3, _b3;
      if (event2.sourceEvent.type === "mousedown" || event2.sourceEvent.type === "touchstart") {
        panStart = [
          (_a3 = event2.sourceEvent.clientX) != null ? _a3 : event2.sourceEvent.touches[0].clientX,
          (_b3 = event2.sourceEvent.clientY) != null ? _b3 : event2.sourceEvent.touches[0].clientY
        ];
      }
    };
    const panHandler = (event2) => {
      var _a3, _b3;
      const transform2 = getTransform();
      if (event2.sourceEvent.type !== "mousemove" && event2.sourceEvent.type !== "touchmove" || !panZoom) {
        return;
      }
      const panCurrent = [
        (_a3 = event2.sourceEvent.clientX) != null ? _a3 : event2.sourceEvent.touches[0].clientX,
        (_b3 = event2.sourceEvent.clientY) != null ? _b3 : event2.sourceEvent.touches[0].clientY
      ];
      const panDelta = [panCurrent[0] - panStart[0], panCurrent[1] - panStart[1]];
      panStart = panCurrent;
      const moveScale = getViewScale() * Math.max(transform2[2], Math.log(transform2[2])) * (inversePan ? -1 : 1);
      const position = {
        x: transform2[0] - panDelta[0] * moveScale,
        y: transform2[1] - panDelta[1] * moveScale
      };
      const extent = [
        [0, 0],
        [width, height]
      ];
      panZoom.setViewportConstrained({
        x: position.x,
        y: position.y,
        zoom: transform2[2]
      }, extent, translateExtent);
    };
    const zoomAndPanHandler = zoom_default2().on("start", panStartHandler).on("zoom", pannable ? panHandler : null).on("zoom.wheel", zoomable ? zoomHandler : null);
    selection2.call(zoomAndPanHandler, {});
  }
  function destroy() {
    selection2.on("zoom", null);
  }
  return {
    update: update2,
    destroy,
    pointer: pointer_default
  };
}
var viewChanged = (prevViewport, eventViewport) => prevViewport.x !== eventViewport.x || prevViewport.y !== eventViewport.y || prevViewport.zoom !== eventViewport.k;
var transformToViewport = (transform2) => ({
  x: transform2.x,
  y: transform2.y,
  zoom: transform2.k
});
var viewportToTransform = ({ x, y, zoom: zoom2 }) => identity2.translate(x, y).scale(zoom2);
var isWrappedWithClass = (event2, className) => event2.target.closest(`.${className}`);
var isRightClickPan = (panOnDrag, usedButton) => usedButton === 2 && Array.isArray(panOnDrag) && panOnDrag.includes(2);
var defaultEase = (t) => ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
var getD3Transition = (selection2, duration = 0, ease = defaultEase, onEnd = () => {
}) => {
  const hasDuration = typeof duration === "number" && duration > 0;
  if (!hasDuration) {
    onEnd();
  }
  return hasDuration ? selection2.transition().duration(duration).ease(ease).on("end", onEnd) : selection2;
};
var wheelDelta = (event2) => {
  const factor = event2.ctrlKey && isMacOs() ? 10 : 1;
  return -event2.deltaY * (event2.deltaMode === 1 ? 0.05 : event2.deltaMode ? 1 : 2e-3) * factor;
};
function createPanOnScrollHandler({ zoomPanValues, noWheelClassName, d3Selection, d3Zoom, panOnScrollMode, panOnScrollSpeed, zoomOnPinch, onPanZoomStart, onPanZoom, onPanZoomEnd }) {
  return (event2) => {
    if (isWrappedWithClass(event2, noWheelClassName)) {
      if (event2.ctrlKey) {
        event2.preventDefault();
      }
      return false;
    }
    event2.preventDefault();
    event2.stopImmediatePropagation();
    const currentZoom = d3Selection.property("__zoom").k || 1;
    if (event2.ctrlKey && zoomOnPinch) {
      const point = pointer_default(event2);
      const pinchDelta = wheelDelta(event2);
      const zoom2 = currentZoom * Math.pow(2, pinchDelta);
      d3Zoom.scaleTo(d3Selection, zoom2, point, event2);
      return;
    }
    const deltaNormalize = event2.deltaMode === 1 ? 20 : 1;
    let deltaX = panOnScrollMode === PanOnScrollMode.Vertical ? 0 : event2.deltaX * deltaNormalize;
    let deltaY = panOnScrollMode === PanOnScrollMode.Horizontal ? 0 : event2.deltaY * deltaNormalize;
    if (!isMacOs() && event2.shiftKey && panOnScrollMode !== PanOnScrollMode.Vertical) {
      deltaX = event2.deltaY * deltaNormalize;
      deltaY = 0;
    }
    d3Zoom.translateBy(
      d3Selection,
      -(deltaX / currentZoom) * panOnScrollSpeed,
      -(deltaY / currentZoom) * panOnScrollSpeed,
      // @ts-ignore
      { internal: true }
    );
    const nextViewport = transformToViewport(d3Selection.property("__zoom"));
    clearTimeout(zoomPanValues.panScrollTimeout);
    if (!zoomPanValues.isPanScrolling) {
      zoomPanValues.isPanScrolling = true;
      onPanZoomStart == null ? void 0 : onPanZoomStart(event2, nextViewport);
    }
    if (zoomPanValues.isPanScrolling) {
      onPanZoom == null ? void 0 : onPanZoom(event2, nextViewport);
      zoomPanValues.panScrollTimeout = setTimeout(() => {
        onPanZoomEnd == null ? void 0 : onPanZoomEnd(event2, nextViewport);
        zoomPanValues.isPanScrolling = false;
      }, 150);
    }
  };
}
function createZoomOnScrollHandler({ noWheelClassName, preventScrolling, d3ZoomHandler }) {
  return function(event2, d) {
    const isWheel = event2.type === "wheel";
    const preventZoom = !preventScrolling && isWheel && !event2.ctrlKey;
    const hasNoWheelClass = isWrappedWithClass(event2, noWheelClassName);
    if (event2.ctrlKey && isWheel && hasNoWheelClass) {
      event2.preventDefault();
    }
    if (preventZoom || hasNoWheelClass) {
      return null;
    }
    event2.preventDefault();
    d3ZoomHandler.call(this, event2, d);
  };
}
function createPanZoomStartHandler({ zoomPanValues, onDraggingChange, onPanZoomStart }) {
  return (event2) => {
    var _a3, _b3, _c2;
    if ((_a3 = event2.sourceEvent) == null ? void 0 : _a3.internal) {
      return;
    }
    const viewport = transformToViewport(event2.transform);
    zoomPanValues.mouseButton = ((_b3 = event2.sourceEvent) == null ? void 0 : _b3.button) || 0;
    zoomPanValues.isZoomingOrPanning = true;
    zoomPanValues.prevViewport = viewport;
    if (((_c2 = event2.sourceEvent) == null ? void 0 : _c2.type) === "mousedown") {
      onDraggingChange(true);
    }
    if (onPanZoomStart) {
      onPanZoomStart == null ? void 0 : onPanZoomStart(event2.sourceEvent, viewport);
    }
  };
}
function createPanZoomHandler({ zoomPanValues, panOnDrag, onPaneContextMenu, onTransformChange, onPanZoom }) {
  return (event2) => {
    var _a3, _b3, _c2;
    zoomPanValues.usedRightMouseButton = !!(onPaneContextMenu && isRightClickPan(panOnDrag, (_a3 = zoomPanValues.mouseButton) != null ? _a3 : 0));
    if (!((_b3 = event2.sourceEvent) == null ? void 0 : _b3.sync)) {
      onTransformChange([event2.transform.x, event2.transform.y, event2.transform.k]);
    }
    if (onPanZoom && !((_c2 = event2.sourceEvent) == null ? void 0 : _c2.internal)) {
      onPanZoom == null ? void 0 : onPanZoom(event2.sourceEvent, transformToViewport(event2.transform));
    }
  };
}
function createPanZoomEndHandler({ zoomPanValues, panOnDrag, panOnScroll, onDraggingChange, onPanZoomEnd, onPaneContextMenu }) {
  return (event2) => {
    var _a3, _b3;
    if ((_a3 = event2.sourceEvent) == null ? void 0 : _a3.internal) {
      return;
    }
    zoomPanValues.isZoomingOrPanning = false;
    if (onPaneContextMenu && isRightClickPan(panOnDrag, (_b3 = zoomPanValues.mouseButton) != null ? _b3 : 0) && !zoomPanValues.usedRightMouseButton && event2.sourceEvent) {
      onPaneContextMenu(event2.sourceEvent);
    }
    zoomPanValues.usedRightMouseButton = false;
    onDraggingChange(false);
    if (onPanZoomEnd && viewChanged(zoomPanValues.prevViewport, event2.transform)) {
      const viewport = transformToViewport(event2.transform);
      zoomPanValues.prevViewport = viewport;
      clearTimeout(zoomPanValues.timerId);
      zoomPanValues.timerId = setTimeout(
        () => {
          onPanZoomEnd == null ? void 0 : onPanZoomEnd(event2.sourceEvent, viewport);
        },
        // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll
        panOnScroll ? 150 : 0
      );
    }
  };
}
function createFilter({ zoomActivationKeyPressed, zoomOnScroll, zoomOnPinch, panOnDrag, panOnScroll, zoomOnDoubleClick, userSelectionActive, noWheelClassName, noPanClassName, lib, connectionInProgress }) {
  return (event2) => {
    var _a3;
    const zoomScroll = zoomActivationKeyPressed || zoomOnScroll;
    const pinchZoom = zoomOnPinch && event2.ctrlKey;
    const isWheelEvent = event2.type === "wheel";
    if (event2.button === 1 && event2.type === "mousedown" && (isWrappedWithClass(event2, `${lib}-flow__node`) || isWrappedWithClass(event2, `${lib}-flow__edge`))) {
      return true;
    }
    if (!panOnDrag && !zoomScroll && !panOnScroll && !zoomOnDoubleClick && !zoomOnPinch) {
      return false;
    }
    if (userSelectionActive) {
      return false;
    }
    if (connectionInProgress && !isWheelEvent) {
      return false;
    }
    if (isWrappedWithClass(event2, noWheelClassName) && isWheelEvent) {
      return false;
    }
    if (isWrappedWithClass(event2, noPanClassName) && (!isWheelEvent || panOnScroll && isWheelEvent && !zoomActivationKeyPressed)) {
      return false;
    }
    if (!zoomOnPinch && event2.ctrlKey && isWheelEvent) {
      return false;
    }
    if (!zoomOnPinch && event2.type === "touchstart" && ((_a3 = event2.touches) == null ? void 0 : _a3.length) > 1) {
      event2.preventDefault();
      return false;
    }
    if (!zoomScroll && !panOnScroll && !pinchZoom && isWheelEvent) {
      return false;
    }
    if (!panOnDrag && (event2.type === "mousedown" || event2.type === "touchstart")) {
      return false;
    }
    if (Array.isArray(panOnDrag) && !panOnDrag.includes(event2.button) && event2.type === "mousedown") {
      return false;
    }
    const buttonAllowed = Array.isArray(panOnDrag) && panOnDrag.includes(event2.button) || !event2.button || event2.button <= 1;
    return (!event2.ctrlKey || isWheelEvent) && buttonAllowed;
  };
}
function XYPanZoom({ domNode, minZoom, maxZoom, paneClickDistance, translateExtent, viewport, onPanZoom, onPanZoomStart, onPanZoomEnd, onDraggingChange }) {
  const zoomPanValues = {
    isZoomingOrPanning: false,
    usedRightMouseButton: false,
    prevViewport: { x: 0, y: 0, zoom: 0 },
    mouseButton: 0,
    timerId: void 0,
    panScrollTimeout: void 0,
    isPanScrolling: false
  };
  const bbox = domNode.getBoundingClientRect();
  const d3ZoomInstance = zoom_default2().clickDistance(!isNumeric(paneClickDistance) || paneClickDistance < 0 ? 0 : paneClickDistance).scaleExtent([minZoom, maxZoom]).translateExtent(translateExtent);
  const d3Selection = select_default2(domNode).call(d3ZoomInstance);
  setViewportConstrained({
    x: viewport.x,
    y: viewport.y,
    zoom: clamp(viewport.zoom, minZoom, maxZoom)
  }, [
    [0, 0],
    [bbox.width, bbox.height]
  ], translateExtent);
  const d3ZoomHandler = d3Selection.on("wheel.zoom");
  const d3DblClickZoomHandler = d3Selection.on("dblclick.zoom");
  d3ZoomInstance.wheelDelta(wheelDelta);
  function setTransform(transform2, options) {
    if (d3Selection) {
      return new Promise((resolve) => {
        d3ZoomInstance == null ? void 0 : d3ZoomInstance.interpolate((options == null ? void 0 : options.interpolate) === "linear" ? value_default : zoom_default).transform(getD3Transition(d3Selection, options == null ? void 0 : options.duration, options == null ? void 0 : options.ease, () => resolve(true)), transform2);
      });
    }
    return Promise.resolve(false);
  }
  function update2({ noWheelClassName, noPanClassName, onPaneContextMenu, userSelectionActive, panOnScroll, panOnDrag, panOnScrollMode, panOnScrollSpeed, preventScrolling, zoomOnPinch, zoomOnScroll, zoomOnDoubleClick, zoomActivationKeyPressed, lib, onTransformChange, connectionInProgress }) {
    if (userSelectionActive && !zoomPanValues.isZoomingOrPanning) {
      destroy();
    }
    const isPanOnScroll = panOnScroll && !zoomActivationKeyPressed && !userSelectionActive;
    const wheelHandler = isPanOnScroll ? createPanOnScrollHandler({
      zoomPanValues,
      noWheelClassName,
      d3Selection,
      d3Zoom: d3ZoomInstance,
      panOnScrollMode,
      panOnScrollSpeed,
      zoomOnPinch,
      onPanZoomStart,
      onPanZoom,
      onPanZoomEnd
    }) : createZoomOnScrollHandler({
      noWheelClassName,
      preventScrolling,
      d3ZoomHandler
    });
    d3Selection.on("wheel.zoom", wheelHandler, { passive: false });
    if (!userSelectionActive) {
      const startHandler = createPanZoomStartHandler({
        zoomPanValues,
        onDraggingChange,
        onPanZoomStart
      });
      d3ZoomInstance.on("start", startHandler);
      const panZoomHandler = createPanZoomHandler({
        zoomPanValues,
        panOnDrag,
        onPaneContextMenu: !!onPaneContextMenu,
        onPanZoom,
        onTransformChange
      });
      d3ZoomInstance.on("zoom", panZoomHandler);
      const panZoomEndHandler = createPanZoomEndHandler({
        zoomPanValues,
        panOnDrag,
        panOnScroll,
        onPaneContextMenu,
        onPanZoomEnd,
        onDraggingChange
      });
      d3ZoomInstance.on("end", panZoomEndHandler);
    }
    const filter2 = createFilter({
      zoomActivationKeyPressed,
      panOnDrag,
      zoomOnScroll,
      panOnScroll,
      zoomOnDoubleClick,
      zoomOnPinch,
      userSelectionActive,
      noPanClassName,
      noWheelClassName,
      lib,
      connectionInProgress
    });
    d3ZoomInstance.filter(filter2);
    if (zoomOnDoubleClick) {
      d3Selection.on("dblclick.zoom", d3DblClickZoomHandler);
    } else {
      d3Selection.on("dblclick.zoom", null);
    }
  }
  function destroy() {
    d3ZoomInstance.on("zoom", null);
  }
  async function setViewportConstrained(viewport2, extent, translateExtent2) {
    const nextTransform = viewportToTransform(viewport2);
    const contrainedTransform = d3ZoomInstance == null ? void 0 : d3ZoomInstance.constrain()(nextTransform, extent, translateExtent2);
    if (contrainedTransform) {
      await setTransform(contrainedTransform);
    }
    return new Promise((resolve) => resolve(contrainedTransform));
  }
  async function setViewport(viewport2, options) {
    const nextTransform = viewportToTransform(viewport2);
    await setTransform(nextTransform, options);
    return new Promise((resolve) => resolve(nextTransform));
  }
  function syncViewport(viewport2) {
    if (d3Selection) {
      const nextTransform = viewportToTransform(viewport2);
      const currentTransform = d3Selection.property("__zoom");
      if (currentTransform.k !== viewport2.zoom || currentTransform.x !== viewport2.x || currentTransform.y !== viewport2.y) {
        d3ZoomInstance == null ? void 0 : d3ZoomInstance.transform(d3Selection, nextTransform, null, { sync: true });
      }
    }
  }
  function getViewport() {
    const transform2 = d3Selection ? transform(d3Selection.node()) : { x: 0, y: 0, k: 1 };
    return { x: transform2.x, y: transform2.y, zoom: transform2.k };
  }
  function scaleTo(zoom2, options) {
    if (d3Selection) {
      return new Promise((resolve) => {
        d3ZoomInstance == null ? void 0 : d3ZoomInstance.interpolate((options == null ? void 0 : options.interpolate) === "linear" ? value_default : zoom_default).scaleTo(getD3Transition(d3Selection, options == null ? void 0 : options.duration, options == null ? void 0 : options.ease, () => resolve(true)), zoom2);
      });
    }
    return Promise.resolve(false);
  }
  function scaleBy(factor, options) {
    if (d3Selection) {
      return new Promise((resolve) => {
        d3ZoomInstance == null ? void 0 : d3ZoomInstance.interpolate((options == null ? void 0 : options.interpolate) === "linear" ? value_default : zoom_default).scaleBy(getD3Transition(d3Selection, options == null ? void 0 : options.duration, options == null ? void 0 : options.ease, () => resolve(true)), factor);
      });
    }
    return Promise.resolve(false);
  }
  function setScaleExtent(scaleExtent) {
    d3ZoomInstance == null ? void 0 : d3ZoomInstance.scaleExtent(scaleExtent);
  }
  function setTranslateExtent(translateExtent2) {
    d3ZoomInstance == null ? void 0 : d3ZoomInstance.translateExtent(translateExtent2);
  }
  function setClickDistance(distance2) {
    const validDistance = !isNumeric(distance2) || distance2 < 0 ? 0 : distance2;
    d3ZoomInstance == null ? void 0 : d3ZoomInstance.clickDistance(validDistance);
  }
  return {
    update: update2,
    destroy,
    setViewport,
    setViewportConstrained,
    getViewport,
    scaleTo,
    scaleBy,
    setScaleExtent,
    setTranslateExtent,
    syncViewport,
    setClickDistance
  };
}
var ResizeControlVariant;
(function(ResizeControlVariant2) {
  ResizeControlVariant2["Line"] = "line";
  ResizeControlVariant2["Handle"] = "handle";
})(ResizeControlVariant || (ResizeControlVariant = {}));
var XY_RESIZER_HANDLE_POSITIONS = ["top-left", "top-right", "bottom-left", "bottom-right"];
var XY_RESIZER_LINE_POSITIONS = ["top", "right", "bottom", "left"];
function getResizeDirection({ width, prevWidth, height, prevHeight, affectsX, affectsY }) {
  const deltaWidth = width - prevWidth;
  const deltaHeight = height - prevHeight;
  const direction = [deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0, deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0];
  if (deltaWidth && affectsX) {
    direction[0] = direction[0] * -1;
  }
  if (deltaHeight && affectsY) {
    direction[1] = direction[1] * -1;
  }
  return direction;
}
function getControlDirection(controlPosition) {
  const isHorizontal = controlPosition.includes("right") || controlPosition.includes("left");
  const isVertical = controlPosition.includes("bottom") || controlPosition.includes("top");
  const affectsX = controlPosition.includes("left");
  const affectsY = controlPosition.includes("top");
  return {
    isHorizontal,
    isVertical,
    affectsX,
    affectsY
  };
}
function getLowerExtentClamp(lowerExtent, lowerBound) {
  return Math.max(0, lowerBound - lowerExtent);
}
function getUpperExtentClamp(upperExtent, upperBound) {
  return Math.max(0, upperExtent - upperBound);
}
function getSizeClamp(size, minSize, maxSize) {
  return Math.max(0, minSize - size, size - maxSize);
}
function xor(a, b) {
  return a ? !b : b;
}
function getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, extent, childExtent) {
  let { affectsX, affectsY } = controlDirection;
  const { isHorizontal, isVertical } = controlDirection;
  const isDiagonal = isHorizontal && isVertical;
  const { xSnapped, ySnapped } = pointerPosition;
  const { minWidth, maxWidth, minHeight, maxHeight } = boundaries;
  const { x: startX, y: startY, width: startWidth, height: startHeight, aspectRatio } = startValues;
  let distX = Math.floor(isHorizontal ? xSnapped - startValues.pointerX : 0);
  let distY = Math.floor(isVertical ? ySnapped - startValues.pointerY : 0);
  const newWidth = startWidth + (affectsX ? -distX : distX);
  const newHeight = startHeight + (affectsY ? -distY : distY);
  const originOffsetX = -nodeOrigin[0] * startWidth;
  const originOffsetY = -nodeOrigin[1] * startHeight;
  let clampX = getSizeClamp(newWidth, minWidth, maxWidth);
  let clampY = getSizeClamp(newHeight, minHeight, maxHeight);
  if (extent) {
    let xExtentClamp = 0;
    let yExtentClamp = 0;
    if (affectsX && distX < 0) {
      xExtentClamp = getLowerExtentClamp(startX + distX + originOffsetX, extent[0][0]);
    } else if (!affectsX && distX > 0) {
      xExtentClamp = getUpperExtentClamp(startX + newWidth + originOffsetX, extent[1][0]);
    }
    if (affectsY && distY < 0) {
      yExtentClamp = getLowerExtentClamp(startY + distY + originOffsetY, extent[0][1]);
    } else if (!affectsY && distY > 0) {
      yExtentClamp = getUpperExtentClamp(startY + newHeight + originOffsetY, extent[1][1]);
    }
    clampX = Math.max(clampX, xExtentClamp);
    clampY = Math.max(clampY, yExtentClamp);
  }
  if (childExtent) {
    let xExtentClamp = 0;
    let yExtentClamp = 0;
    if (affectsX && distX > 0) {
      xExtentClamp = getUpperExtentClamp(startX + distX, childExtent[0][0]);
    } else if (!affectsX && distX < 0) {
      xExtentClamp = getLowerExtentClamp(startX + newWidth, childExtent[1][0]);
    }
    if (affectsY && distY > 0) {
      yExtentClamp = getUpperExtentClamp(startY + distY, childExtent[0][1]);
    } else if (!affectsY && distY < 0) {
      yExtentClamp = getLowerExtentClamp(startY + newHeight, childExtent[1][1]);
    }
    clampX = Math.max(clampX, xExtentClamp);
    clampY = Math.max(clampY, yExtentClamp);
  }
  if (keepAspectRatio) {
    if (isHorizontal) {
      const aspectHeightClamp = getSizeClamp(newWidth / aspectRatio, minHeight, maxHeight) * aspectRatio;
      clampX = Math.max(clampX, aspectHeightClamp);
      if (extent) {
        let aspectExtentClamp = 0;
        if (!affectsX && !affectsY || affectsX && !affectsY && isDiagonal) {
          aspectExtentClamp = getUpperExtentClamp(startY + originOffsetY + newWidth / aspectRatio, extent[1][1]) * aspectRatio;
        } else {
          aspectExtentClamp = getLowerExtentClamp(startY + originOffsetY + (affectsX ? distX : -distX) / aspectRatio, extent[0][1]) * aspectRatio;
        }
        clampX = Math.max(clampX, aspectExtentClamp);
      }
      if (childExtent) {
        let aspectExtentClamp = 0;
        if (!affectsX && !affectsY || affectsX && !affectsY && isDiagonal) {
          aspectExtentClamp = getLowerExtentClamp(startY + newWidth / aspectRatio, childExtent[1][1]) * aspectRatio;
        } else {
          aspectExtentClamp = getUpperExtentClamp(startY + (affectsX ? distX : -distX) / aspectRatio, childExtent[0][1]) * aspectRatio;
        }
        clampX = Math.max(clampX, aspectExtentClamp);
      }
    }
    if (isVertical) {
      const aspectWidthClamp = getSizeClamp(newHeight * aspectRatio, minWidth, maxWidth) / aspectRatio;
      clampY = Math.max(clampY, aspectWidthClamp);
      if (extent) {
        let aspectExtentClamp = 0;
        if (!affectsX && !affectsY || affectsY && !affectsX && isDiagonal) {
          aspectExtentClamp = getUpperExtentClamp(startX + newHeight * aspectRatio + originOffsetX, extent[1][0]) / aspectRatio;
        } else {
          aspectExtentClamp = getLowerExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio + originOffsetX, extent[0][0]) / aspectRatio;
        }
        clampY = Math.max(clampY, aspectExtentClamp);
      }
      if (childExtent) {
        let aspectExtentClamp = 0;
        if (!affectsX && !affectsY || affectsY && !affectsX && isDiagonal) {
          aspectExtentClamp = getLowerExtentClamp(startX + newHeight * aspectRatio, childExtent[1][0]) / aspectRatio;
        } else {
          aspectExtentClamp = getUpperExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio, childExtent[0][0]) / aspectRatio;
        }
        clampY = Math.max(clampY, aspectExtentClamp);
      }
    }
  }
  distY = distY + (distY < 0 ? clampY : -clampY);
  distX = distX + (distX < 0 ? clampX : -clampX);
  if (keepAspectRatio) {
    if (isDiagonal) {
      if (newWidth > newHeight * aspectRatio) {
        distY = (xor(affectsX, affectsY) ? -distX : distX) / aspectRatio;
      } else {
        distX = (xor(affectsX, affectsY) ? -distY : distY) * aspectRatio;
      }
    } else {
      if (isHorizontal) {
        distY = distX / aspectRatio;
        affectsY = affectsX;
      } else {
        distX = distY * aspectRatio;
        affectsX = affectsY;
      }
    }
  }
  const x = affectsX ? startX + distX : startX;
  const y = affectsY ? startY + distY : startY;
  return {
    width: startWidth + (affectsX ? -distX : distX),
    height: startHeight + (affectsY ? -distY : distY),
    x: nodeOrigin[0] * distX * (!affectsX ? 1 : -1) + x,
    y: nodeOrigin[1] * distY * (!affectsY ? 1 : -1) + y
  };
}
var initPrevValues = { width: 0, height: 0, x: 0, y: 0 };
var initStartValues = {
  ...initPrevValues,
  pointerX: 0,
  pointerY: 0,
  aspectRatio: 1
};
function nodeToParentExtent(node) {
  return [
    [0, 0],
    [node.measured.width, node.measured.height]
  ];
}
function nodeToChildExtent(child2, parent, nodeOrigin) {
  var _a3, _b3;
  const x = parent.position.x + child2.position.x;
  const y = parent.position.y + child2.position.y;
  const width = (_a3 = child2.measured.width) != null ? _a3 : 0;
  const height = (_b3 = child2.measured.height) != null ? _b3 : 0;
  const originOffsetX = nodeOrigin[0] * width;
  const originOffsetY = nodeOrigin[1] * height;
  return [
    [x - originOffsetX, y - originOffsetY],
    [x + width - originOffsetX, y + height - originOffsetY]
  ];
}
function XYResizer({ domNode, nodeId, getStoreItems, onChange: onChange2, onEnd }) {
  const selection2 = select_default2(domNode);
  function update2({ controlPosition, boundaries, keepAspectRatio, resizeDirection, onResizeStart, onResize, onResizeEnd, shouldResize }) {
    let prevValues = { ...initPrevValues };
    let startValues = { ...initStartValues };
    const controlDirection = getControlDirection(controlPosition);
    let node = void 0;
    let containerBounds = null;
    let childNodes = [];
    let parentNode = void 0;
    let parentExtent = void 0;
    let childExtent = void 0;
    let resizeDetected = false;
    const dragHandler = drag_default().on("start", (event2) => {
      var _a3, _b3, _c2, _d, _e, _f;
      const { nodeLookup, transform: transform2, snapGrid, snapToGrid, nodeOrigin, paneDomNode } = getStoreItems();
      node = nodeLookup.get(nodeId);
      if (!node) {
        return;
      }
      containerBounds = (_a3 = paneDomNode == null ? void 0 : paneDomNode.getBoundingClientRect()) != null ? _a3 : null;
      const { xSnapped, ySnapped } = getPointerPosition(event2.sourceEvent, {
        transform: transform2,
        snapGrid,
        snapToGrid,
        containerBounds
      });
      prevValues = {
        width: (_b3 = node.measured.width) != null ? _b3 : 0,
        height: (_c2 = node.measured.height) != null ? _c2 : 0,
        x: (_d = node.position.x) != null ? _d : 0,
        y: (_e = node.position.y) != null ? _e : 0
      };
      startValues = {
        ...prevValues,
        pointerX: xSnapped,
        pointerY: ySnapped,
        aspectRatio: prevValues.width / prevValues.height
      };
      parentNode = void 0;
      if (node.parentId && (node.extent === "parent" || node.expandParent)) {
        parentNode = nodeLookup.get(node.parentId);
        parentExtent = parentNode && node.extent === "parent" ? nodeToParentExtent(parentNode) : void 0;
      }
      childNodes = [];
      childExtent = void 0;
      for (const [childId, child2] of nodeLookup) {
        if (child2.parentId === nodeId) {
          childNodes.push({
            id: childId,
            position: { ...child2.position },
            extent: child2.extent
          });
          if (child2.extent === "parent" || child2.expandParent) {
            const extent = nodeToChildExtent(child2, node, (_f = child2.origin) != null ? _f : nodeOrigin);
            if (childExtent) {
              childExtent = [
                [Math.min(extent[0][0], childExtent[0][0]), Math.min(extent[0][1], childExtent[0][1])],
                [Math.max(extent[1][0], childExtent[1][0]), Math.max(extent[1][1], childExtent[1][1])]
              ];
            } else {
              childExtent = extent;
            }
          }
        }
      }
      onResizeStart == null ? void 0 : onResizeStart(event2, { ...prevValues });
    }).on("drag", (event2) => {
      var _a3, _b3, _c2;
      const { transform: transform2, snapGrid, snapToGrid, nodeOrigin: storeNodeOrigin } = getStoreItems();
      const pointerPosition = getPointerPosition(event2.sourceEvent, {
        transform: transform2,
        snapGrid,
        snapToGrid,
        containerBounds
      });
      const childChanges = [];
      if (!node) {
        return;
      }
      const { x: prevX, y: prevY, width: prevWidth, height: prevHeight } = prevValues;
      const change = {};
      const nodeOrigin = (_a3 = node.origin) != null ? _a3 : storeNodeOrigin;
      const { width, height, x, y } = getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, parentExtent, childExtent);
      const isWidthChange = width !== prevWidth;
      const isHeightChange = height !== prevHeight;
      const isXPosChange = x !== prevX && isWidthChange;
      const isYPosChange = y !== prevY && isHeightChange;
      if (!isXPosChange && !isYPosChange && !isWidthChange && !isHeightChange) {
        return;
      }
      if (isXPosChange || isYPosChange || nodeOrigin[0] === 1 || nodeOrigin[1] === 1) {
        change.x = isXPosChange ? x : prevValues.x;
        change.y = isYPosChange ? y : prevValues.y;
        prevValues.x = change.x;
        prevValues.y = change.y;
        if (childNodes.length > 0) {
          const xChange = x - prevX;
          const yChange = y - prevY;
          for (const childNode of childNodes) {
            childNode.position = {
              x: childNode.position.x - xChange + nodeOrigin[0] * (width - prevWidth),
              y: childNode.position.y - yChange + nodeOrigin[1] * (height - prevHeight)
            };
            childChanges.push(childNode);
          }
        }
      }
      if (isWidthChange || isHeightChange) {
        change.width = isWidthChange && (!resizeDirection || resizeDirection === "horizontal") ? width : prevValues.width;
        change.height = isHeightChange && (!resizeDirection || resizeDirection === "vertical") ? height : prevValues.height;
        prevValues.width = change.width;
        prevValues.height = change.height;
      }
      if (parentNode && node.expandParent) {
        const xLimit = nodeOrigin[0] * ((_b3 = change.width) != null ? _b3 : 0);
        if (change.x && change.x < xLimit) {
          prevValues.x = xLimit;
          startValues.x = startValues.x - (change.x - xLimit);
        }
        const yLimit = nodeOrigin[1] * ((_c2 = change.height) != null ? _c2 : 0);
        if (change.y && change.y < yLimit) {
          prevValues.y = yLimit;
          startValues.y = startValues.y - (change.y - yLimit);
        }
      }
      const direction = getResizeDirection({
        width: prevValues.width,
        prevWidth,
        height: prevValues.height,
        prevHeight,
        affectsX: controlDirection.affectsX,
        affectsY: controlDirection.affectsY
      });
      const nextValues = { ...prevValues, direction };
      const callResize = shouldResize == null ? void 0 : shouldResize(event2, nextValues);
      if (callResize === false) {
        return;
      }
      resizeDetected = true;
      onResize == null ? void 0 : onResize(event2, nextValues);
      onChange2(change, childChanges);
    }).on("end", (event2) => {
      if (!resizeDetected) {
        return;
      }
      onResizeEnd == null ? void 0 : onResizeEnd(event2, { ...prevValues });
      onEnd == null ? void 0 : onEnd({ ...prevValues });
      resizeDetected = false;
    });
    selection2.call(dragHandler);
  }
  function destroy() {
    selection2.on(".drag", null);
  }
  return {
    update: update2,
    destroy
  };
}

// node_modules/@xyflow/svelte/dist/lib/components/Handle/Handle.svelte
var root2 = from_html(`<div><!></div>`);
function Handle($$anchor, $$props) {
  push($$props, true);
  let handleId = prop($$props, "id", 3, null), type = prop($$props, "type", 3, "source"), position = prop($$props, "position", 19, () => Position.Top), isConnectableStart = prop($$props, "isConnectableStart", 3, true), isConnectableEnd = prop($$props, "isConnectableEnd", 3, true), rest = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "type",
    "position",
    "style",
    "class",
    "isConnectable",
    "isConnectableStart",
    "isConnectableEnd",
    "isValidConnection",
    "onconnect",
    "ondisconnect",
    "children"
  ]);
  const nodeId = getContext("svelteflow__node_id");
  const isConnectableContext = getContext("svelteflow__node_connectable");
  let isTarget = user_derived(() => type() === "target");
  let isConnectable = user_derived(() => $$props.isConnectable !== void 0 ? $$props.isConnectable : isConnectableContext.value);
  let store = useStore();
  let ariaLabelConfig = user_derived(() => store.ariaLabelConfig);
  let prevConnections = null;
  user_pre_effect(() => {
    if ($$props.onconnect || $$props.ondisconnect) {
      store.edges;
      let connections = store.connectionLookup.get(`${nodeId}-${type()}${handleId() ? `-${handleId()}` : ""}`);
      if (prevConnections && !areConnectionMapsEqual(connections, prevConnections)) {
        const _connections = connections != null ? connections : /* @__PURE__ */ new Map();
        handleConnectionChange(prevConnections, _connections, $$props.ondisconnect);
        handleConnectionChange(_connections, prevConnections, $$props.onconnect);
      }
      prevConnections = new Map(connections);
    }
  });
  let $$d = user_derived(() => {
    if (!store.connection.inProgress) {
      return [false, false, false, false, null];
    }
    const { fromHandle, toHandle, isValid } = store.connection;
    const connectingFrom2 = fromHandle && fromHandle.nodeId === nodeId && fromHandle.type === type() && fromHandle.id === handleId();
    const connectingTo2 = toHandle && toHandle.nodeId === nodeId && toHandle.type === type() && toHandle.id === handleId();
    const isPossibleTargetHandle2 = store.connectionMode === ConnectionMode.Strict ? (fromHandle == null ? void 0 : fromHandle.type) !== type() : nodeId !== (fromHandle == null ? void 0 : fromHandle.nodeId) || handleId() !== (fromHandle == null ? void 0 : fromHandle.id);
    const valid2 = connectingTo2 && isValid;
    return [
      true,
      connectingFrom2,
      connectingTo2,
      isPossibleTargetHandle2,
      valid2
    ];
  }), $$array = user_derived(() => to_array(get($$d), 5)), connectionInProgress = user_derived(() => get($$array)[0]), connectingFrom = user_derived(() => get($$array)[1]), connectingTo = user_derived(() => get($$array)[2]), isPossibleTargetHandle = user_derived(() => get($$array)[3]), valid = user_derived(() => get($$array)[4]);
  function onConnectExtended(connection) {
    var _a3;
    const edge = store.onbeforeconnect ? store.onbeforeconnect(connection) : connection;
    if (!edge) {
      return;
    }
    store.addEdge(edge);
    (_a3 = store.onconnect) == null ? void 0 : _a3.call(store, connection);
  }
  function onpointerdown(event2) {
    var _a3;
    const isMouseTriggered = isMouseEvent(event2);
    if (event2.currentTarget && (isMouseTriggered && event2.button === 0 || !isMouseTriggered)) {
      XYHandle.onPointerDown(event2, {
        handleId: handleId(),
        nodeId,
        isTarget: get(isTarget),
        connectionRadius: store.connectionRadius,
        domNode: store.domNode,
        nodeLookup: store.nodeLookup,
        connectionMode: store.connectionMode,
        lib: "svelte",
        autoPanOnConnect: store.autoPanOnConnect,
        autoPanSpeed: store.autoPanSpeed,
        flowId: store.flowId,
        isValidConnection: (_a3 = $$props.isValidConnection) != null ? _a3 : store.isValidConnection,
        updateConnection: store.updateConnection,
        cancelConnection: store.cancelConnection,
        panBy: store.panBy,
        onConnect: onConnectExtended,
        onConnectStart: (event3, startParams) => {
          var _a4;
          (_a4 = store.onconnectstart) == null ? void 0 : _a4.call(store, event3, {
            nodeId: startParams.nodeId,
            handleId: startParams.handleId,
            handleType: startParams.handleType
          });
        },
        onConnectEnd: (event3, connectionState) => {
          var _a4;
          (_a4 = store.onconnectend) == null ? void 0 : _a4.call(store, event3, connectionState);
        },
        getTransform: () => [store.viewport.x, store.viewport.y, store.viewport.zoom],
        getFromHandle: () => store.connection.fromHandle,
        dragThreshold: store.connectionDragThreshold,
        handleDomNode: event2.currentTarget
      });
    }
  }
  function onclick2(event2) {
    var _a3, _b3, _c2, _d;
    if (!nodeId || !store.clickConnectStartHandle && !isConnectableStart()) {
      return;
    }
    if (!store.clickConnectStartHandle) {
      (_a3 = store.onclickconnectstart) == null ? void 0 : _a3.call(store, event2, { nodeId, handleId: handleId(), handleType: type() });
      store.clickConnectStartHandle = { nodeId, type: type(), id: handleId() };
      return;
    }
    const doc = getHostForElement(event2.target);
    const isValidConnectionHandler = (_b3 = $$props.isValidConnection) != null ? _b3 : store.isValidConnection;
    const { connectionMode, clickConnectStartHandle, flowId, nodeLookup } = store;
    const { connection, isValid } = XYHandle.isValid(event2, {
      handle: { nodeId, id: handleId(), type: type() },
      connectionMode,
      fromNodeId: clickConnectStartHandle.nodeId,
      fromHandleId: (_c2 = clickConnectStartHandle.id) != null ? _c2 : null,
      fromType: clickConnectStartHandle.type,
      isValidConnection: isValidConnectionHandler,
      flowId,
      doc,
      lib: "svelte",
      nodeLookup
    });
    if (isValid && connection) {
      onConnectExtended(connection);
    }
    const connectionClone = structuredClone(snapshot(store.connection));
    delete connectionClone.inProgress;
    connectionClone.toPosition = connectionClone.toHandle ? connectionClone.toHandle.position : null;
    (_d = store.onclickconnectend) == null ? void 0 : _d.call(store, event2, connectionClone);
    store.clickConnectStartHandle = null;
  }
  var div = root2();
  var event_handler = () => {
  };
  attribute_effect(
    div,
    ($0) => {
      var _a3, _b3, _c2, _d;
      return {
        "data-handleid": handleId(),
        "data-nodeid": nodeId,
        "data-handlepos": position(),
        "data-id": `${(_a3 = store.flowId) != null ? _a3 : ""}-${nodeId != null ? nodeId : ""}-${(_c2 = (_b3 = handleId()) != null ? _b3 : "null") != null ? _c2 : ""}-${(_d = type()) != null ? _d : ""}`,
        class: [
          "svelte-flow__handle",
          `svelte-flow__handle-${position()}`,
          store.noDragClass,
          store.noPanClass,
          position(),
          $$props.class
        ],
        onmousedown: onpointerdown,
        ontouchstart: onpointerdown,
        onclick: store.clickConnect ? onclick2 : void 0,
        onkeypress: event_handler,
        style: $$props.style,
        role: "button",
        "aria-label": get(ariaLabelConfig)[`handle.ariaLabel`],
        tabindex: "-1",
        ...rest,
        [CLASS]: $0
      };
    },
    [
      () => ({
        valid: get(valid),
        connectingto: get(connectingTo),
        connectingfrom: get(connectingFrom),
        source: !get(isTarget),
        target: get(isTarget),
        connectablestart: isConnectableStart(),
        connectableend: isConnectableEnd(),
        connectable: get(isConnectable),
        connectionindicator: get(isConnectable) && (!get(connectionInProgress) || get(isPossibleTargetHandle)) && (get(connectionInProgress) || store.clickConnectStartHandle ? isConnectableEnd() : isConnectableStart())
      })
    ]
  );
  var node = child(div);
  snippet(node, () => {
    var _a3;
    return (_a3 = $$props.children) != null ? _a3 : noop;
  });
  reset(div);
  append($$anchor, div);
  pop();
}

// node_modules/@xyflow/svelte/dist/lib/components/nodes/DefaultNode.svelte
var root3 = from_html(`<!> <!>`, 1);
function DefaultNode($$anchor, $$props) {
  push($$props, true);
  let targetPosition = prop($$props, "targetPosition", 19, () => Position.Top), sourcePosition = prop($$props, "sourcePosition", 19, () => Position.Bottom);
  var fragment = root3();
  var node = first_child(fragment);
  Handle(node, {
    type: "target",
    get position() {
      return targetPosition();
    }
  });
  var text2 = sibling(node);
  var node_1 = sibling(text2);
  Handle(node_1, {
    type: "source",
    get position() {
      return sourcePosition();
    }
  });
  template_effect(() => {
    var _a3, _b3;
    return set_text(text2, ` ${(_b3 = (_a3 = $$props.data) == null ? void 0 : _a3.label) != null ? _b3 : ""} `);
  });
  append($$anchor, fragment);
  pop();
}

// node_modules/@xyflow/svelte/dist/lib/components/nodes/InputNode.svelte
var root4 = from_html(` <!>`, 1);
function InputNode($$anchor, $$props) {
  push($$props, true);
  let data = prop($$props, "data", 19, () => ({ label: "Node" })), sourcePosition = prop($$props, "sourcePosition", 19, () => Position.Bottom);
  next();
  var fragment = root4();
  var text2 = first_child(fragment);
  var node = sibling(text2);
  Handle(node, {
    type: "source",
    get position() {
      return sourcePosition();
    }
  });
  template_effect(() => {
    var _a3, _b3;
    return set_text(text2, `${(_b3 = (_a3 = data()) == null ? void 0 : _a3.label) != null ? _b3 : ""} `);
  });
  append($$anchor, fragment);
  pop();
}

// node_modules/@xyflow/svelte/dist/lib/components/nodes/OutputNode.svelte
var root5 = from_html(` <!>`, 1);
function OutputNode($$anchor, $$props) {
  push($$props, true);
  let data = prop($$props, "data", 19, () => ({ label: "Node" })), targetPosition = prop($$props, "targetPosition", 19, () => Position.Top);
  next();
  var fragment = root5();
  var text2 = first_child(fragment);
  var node = sibling(text2);
  Handle(node, {
    type: "target",
    get position() {
      return targetPosition();
    }
  });
  template_effect(() => {
    var _a3, _b3;
    return set_text(text2, `${(_b3 = (_a3 = data()) == null ? void 0 : _a3.label) != null ? _b3 : ""} `);
  });
  append($$anchor, fragment);
  pop();
}

// node_modules/@xyflow/svelte/dist/lib/components/nodes/GroupNode.svelte
function GroupNode($$anchor, $$props) {
}

// node_modules/@xyflow/svelte/dist/lib/actions/portal/portal.svelte.js
function tryToMount(node, domNode, target) {
  if (!target || !domNode) {
    return;
  }
  const targetEl = target === "root" ? domNode : domNode.querySelector(`.svelte-flow__${target}`);
  if (targetEl) {
    targetEl.appendChild(node);
  }
}
function portal(node, target) {
  const $$d = user_derived(useStore), domNode = user_derived(() => get($$d).domNode);
  let destroyEffect;
  if (get(domNode)) {
    tryToMount(node, get(domNode), target);
  } else {
    destroyEffect = effect_root(() => {
      user_effect(() => {
        tryToMount(node, get(domNode), target);
        destroyEffect == null ? void 0 : destroyEffect();
      });
    });
  }
  return {
    async update(target2) {
      tryToMount(node, get(domNode), target2);
    },
    destroy() {
      if (node.parentNode) {
        node.parentNode.removeChild(node);
      }
      destroyEffect == null ? void 0 : destroyEffect();
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/actions/portal/utils.svelte.js
function hideOnSSR() {
  let hide = state(typeof window === "undefined");
  if (get(hide)) {
    const destroyEffect = effect_root(() => {
      user_effect(() => {
        set(hide, false);
        destroyEffect == null ? void 0 : destroyEffect();
      });
    });
  }
  return {
    get value() {
      return get(hide);
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/utils/index.js
var isNode = (element2) => isNodeBase(element2);
var isEdge = (element2) => isEdgeBase(element2);
function toPxString(value) {
  return value === void 0 ? void 0 : `${value}px`;
}
var arrowKeyDiffs = {
  ArrowUp: { x: 0, y: -1 },
  ArrowDown: { x: 0, y: 1 },
  ArrowLeft: { x: -1, y: 0 },
  ArrowRight: { x: 1, y: 0 }
};

// node_modules/@xyflow/svelte/dist/lib/components/EdgeLabel/EdgeLabel.svelte
var root6 = from_html(`<div><!></div>`);
var $$css = {
  hash: "svelte-1wg91mu",
  code: ".transparent.svelte-1wg91mu {background:transparent;}"
};
function EdgeLabel($$anchor, $$props) {
  push($$props, true);
  append_styles($$anchor, $$css);
  let x = prop($$props, "x", 3, 0), y = prop($$props, "y", 3, 0), selectEdgeOnClick = prop($$props, "selectEdgeOnClick", 3, false), transparent = prop($$props, "transparent", 3, false), rest = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "x",
    "y",
    "width",
    "height",
    "selectEdgeOnClick",
    "transparent",
    "class",
    "children"
  ]);
  const store = useStore();
  const id2 = getContext("svelteflow__edge_id");
  let z = user_derived(() => {
    var _a3;
    return (_a3 = store.visible.edges.get(id2)) == null ? void 0 : _a3.zIndex;
  });
  var div = root6();
  var event_handler = () => {
    if (selectEdgeOnClick() && id2) store.handleEdgeSelection(id2);
  };
  attribute_effect(
    div,
    ($0) => ({
      class: [
        "svelte-flow__edge-label",
        { transparent: transparent() },
        $$props.class
      ],
      tabindex: "-1",
      onclick: event_handler,
      ...rest,
      [STYLE]: $0
    }),
    [
      () => {
        var _a3, _b3;
        return {
          display: hideOnSSR().value ? "none" : void 0,
          cursor: selectEdgeOnClick() ? "pointer" : void 0,
          transform: `translate(-50%, -50%) translate(${(_a3 = x()) != null ? _a3 : ""}px,${(_b3 = y()) != null ? _b3 : ""}px)`,
          "pointer-events": "all",
          width: toPxString($$props.width),
          height: toPxString($$props.height),
          "z-index": get(z)
        };
      }
    ],
    void 0,
    "svelte-1wg91mu"
  );
  var node = child(div);
  snippet(node, () => {
    var _a3;
    return (_a3 = $$props.children) != null ? _a3 : noop;
  });
  reset(div);
  action(div, ($$node, $$action_arg) => {
    var _a3;
    return (_a3 = portal) == null ? void 0 : _a3($$node, $$action_arg);
  }, () => "edge-labels");
  append($$anchor, div);
  pop();
}

// node_modules/@xyflow/svelte/dist/lib/components/edges/BaseEdge.svelte
var root_1 = from_svg(`<path></path>`);
var root7 = from_svg(`<path fill="none"></path><!><!>`, 1);
function BaseEdge($$anchor, $$props) {
  let interactionWidth = prop($$props, "interactionWidth", 3, 20), rest = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "path",
    "label",
    "labelX",
    "labelY",
    "labelStyle",
    "markerStart",
    "markerEnd",
    "style",
    "interactionWidth",
    "class"
  ]);
  var fragment = root7();
  var path_1 = first_child(fragment);
  var node = sibling(path_1);
  {
    var consequent = ($$anchor2) => {
      var path_2 = root_1();
      attribute_effect(path_2, () => ({
        d: $$props.path,
        "stroke-opacity": 0,
        "stroke-width": interactionWidth(),
        fill: "none",
        class: "svelte-flow__edge-interaction",
        ...rest
      }));
      append($$anchor2, path_2);
    };
    if_block(node, ($$render) => {
      if (interactionWidth() > 0) $$render(consequent);
    });
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      EdgeLabel($$anchor2, {
        get x() {
          return $$props.labelX;
        },
        get y() {
          return $$props.labelY;
        },
        get style() {
          return $$props.labelStyle;
        },
        selectEdgeOnClick: true,
        children: ($$anchor3, $$slotProps) => {
          next();
          var text2 = text();
          template_effect(() => set_text(text2, $$props.label));
          append($$anchor3, text2);
        },
        $$slots: { default: true }
      });
    };
    if_block(node_1, ($$render) => {
      if ($$props.label) $$render(consequent_1);
    });
  }
  template_effect(() => {
    set_attribute2(path_1, "id", $$props.id);
    set_attribute2(path_1, "d", $$props.path);
    set_class(path_1, 0, clsx2(["svelte-flow__edge-path", $$props.class]));
    set_attribute2(path_1, "marker-start", $$props.markerStart);
    set_attribute2(path_1, "marker-end", $$props.markerEnd);
    set_style(path_1, $$props.style);
  });
  append($$anchor, fragment);
}

// node_modules/@xyflow/svelte/dist/lib/components/edges/BezierEdge.svelte
function BezierEdge($$anchor, $$props) {
  push($$props, true);
  let $$d = user_derived(() => {
    var _a3;
    return getBezierPath({
      sourceX: $$props.sourceX,
      sourceY: $$props.sourceY,
      targetX: $$props.targetX,
      targetY: $$props.targetY,
      sourcePosition: $$props.sourcePosition,
      targetPosition: $$props.targetPosition,
      curvature: (_a3 = $$props.pathOptions) == null ? void 0 : _a3.curvature
    });
  }), $$array = user_derived(() => to_array(get($$d), 3)), path = user_derived(() => get($$array)[0]), labelX = user_derived(() => get($$array)[1]), labelY = user_derived(() => get($$array)[2]);
  BaseEdge($$anchor, {
    get id() {
      return $$props.id;
    },
    get path() {
      return get(path);
    },
    get labelX() {
      return get(labelX);
    },
    get labelY() {
      return get(labelY);
    },
    get label() {
      return $$props.label;
    },
    get labelStyle() {
      return $$props.labelStyle;
    },
    get markerStart() {
      return $$props.markerStart;
    },
    get markerEnd() {
      return $$props.markerEnd;
    },
    get interactionWidth() {
      return $$props.interactionWidth;
    },
    get style() {
      return $$props.style;
    }
  });
  pop();
}

// node_modules/@xyflow/svelte/dist/lib/components/edges/SmoothStepEdgeInternal.svelte
function SmoothStepEdgeInternal($$anchor, $$props) {
  push($$props, true);
  let $$d = user_derived(() => getSmoothStepPath({
    sourceX: $$props.sourceX,
    sourceY: $$props.sourceY,
    targetX: $$props.targetX,
    targetY: $$props.targetY,
    sourcePosition: $$props.sourcePosition,
    targetPosition: $$props.targetPosition
  })), $$array = user_derived(() => to_array(get($$d), 3)), path = user_derived(() => get($$array)[0]), labelX = user_derived(() => get($$array)[1]), labelY = user_derived(() => get($$array)[2]);
  BaseEdge($$anchor, {
    get path() {
      return get(path);
    },
    get labelX() {
      return get(labelX);
    },
    get labelY() {
      return get(labelY);
    },
    get label() {
      return $$props.label;
    },
    get labelStyle() {
      return $$props.labelStyle;
    },
    get markerStart() {
      return $$props.markerStart;
    },
    get markerEnd() {
      return $$props.markerEnd;
    },
    get interactionWidth() {
      return $$props.interactionWidth;
    },
    get style() {
      return $$props.style;
    }
  });
  pop();
}

// node_modules/@xyflow/svelte/dist/lib/components/edges/StraightEdgeInternal.svelte
function StraightEdgeInternal($$anchor, $$props) {
  push($$props, true);
  let $$d = user_derived(() => getStraightPath({
    sourceX: $$props.sourceX,
    sourceY: $$props.sourceY,
    targetX: $$props.targetX,
    targetY: $$props.targetY
  })), $$array = user_derived(() => to_array(get($$d), 3)), path = user_derived(() => get($$array)[0]), labelX = user_derived(() => get($$array)[1]), labelY = user_derived(() => get($$array)[2]);
  BaseEdge($$anchor, {
    get path() {
      return get(path);
    },
    get labelX() {
      return get(labelX);
    },
    get labelY() {
      return get(labelY);
    },
    get label() {
      return $$props.label;
    },
    get labelStyle() {
      return $$props.labelStyle;
    },
    get markerStart() {
      return $$props.markerStart;
    },
    get markerEnd() {
      return $$props.markerEnd;
    },
    get interactionWidth() {
      return $$props.interactionWidth;
    },
    get style() {
      return $$props.style;
    }
  });
  pop();
}

// node_modules/@xyflow/svelte/dist/lib/components/edges/StepEdgeInternal.svelte
function StepEdgeInternal($$anchor, $$props) {
  push($$props, true);
  let $$d = user_derived(() => getSmoothStepPath({
    sourceX: $$props.sourceX,
    sourceY: $$props.sourceY,
    targetX: $$props.targetX,
    targetY: $$props.targetY,
    sourcePosition: $$props.sourcePosition,
    targetPosition: $$props.targetPosition,
    borderRadius: 0
  })), $$array = user_derived(() => to_array(get($$d), 3)), path = user_derived(() => get($$array)[0]), labelX = user_derived(() => get($$array)[1]), labelY = user_derived(() => get($$array)[2]);
  BaseEdge($$anchor, {
    get path() {
      return get(path);
    },
    get labelX() {
      return get(labelX);
    },
    get labelY() {
      return get(labelY);
    },
    get label() {
      return $$props.label;
    },
    get labelStyle() {
      return $$props.labelStyle;
    },
    get markerStart() {
      return $$props.markerStart;
    },
    get markerEnd() {
      return $$props.markerEnd;
    },
    get interactionWidth() {
      return $$props.interactionWidth;
    },
    get style() {
      return $$props.style;
    }
  });
  pop();
}

// node_modules/svelte/src/reactivity/url-search-params.js
var REPLACE = Symbol();
var _version, _url, _updating, _SvelteURLSearchParams_instances, update_url_fn;
var SvelteURLSearchParams = class extends URLSearchParams {
  constructor() {
    super(...arguments);
    __privateAdd(this, _SvelteURLSearchParams_instances);
    __privateAdd(this, _version, dev_fallback_default ? tag(state(0), "SvelteURLSearchParams version") : state(0));
    __privateAdd(this, _url, get_current_url());
    __privateAdd(this, _updating, false);
  }
  /**
   * @param {URLSearchParams} params
   * @internal
   */
  [REPLACE](params) {
    if (__privateGet(this, _updating)) return;
    __privateSet(this, _updating, true);
    for (const key3 of [...super.keys()]) {
      super.delete(key3);
    }
    for (const [key3, value] of params) {
      super.append(key3, value);
    }
    increment(__privateGet(this, _version));
    __privateSet(this, _updating, false);
  }
  /**
   * @param {string} name
   * @param {string} value
   * @returns {void}
   */
  append(name, value) {
    super.append(name, value);
    __privateMethod(this, _SvelteURLSearchParams_instances, update_url_fn).call(this);
    increment(__privateGet(this, _version));
  }
  /**
   * @param {string} name
   * @param {string=} value
   * @returns {void}
   */
  delete(name, value) {
    var has_value = super.has(name, value);
    super.delete(name, value);
    if (has_value) {
      __privateMethod(this, _SvelteURLSearchParams_instances, update_url_fn).call(this);
      increment(__privateGet(this, _version));
    }
  }
  /**
   * @param {string} name
   * @returns {string|null}
   */
  get(name) {
    get(__privateGet(this, _version));
    return super.get(name);
  }
  /**
   * @param {string} name
   * @returns {string[]}
   */
  getAll(name) {
    get(__privateGet(this, _version));
    return super.getAll(name);
  }
  /**
   * @param {string} name
   * @param {string=} value
   * @returns {boolean}
   */
  has(name, value) {
    get(__privateGet(this, _version));
    return super.has(name, value);
  }
  keys() {
    get(__privateGet(this, _version));
    return super.keys();
  }
  /**
   * @param {string} name
   * @param {string} value
   * @returns {void}
   */
  set(name, value) {
    var previous = super.getAll(name).join("");
    super.set(name, value);
    if (previous !== super.getAll(name).join("")) {
      __privateMethod(this, _SvelteURLSearchParams_instances, update_url_fn).call(this);
      increment(__privateGet(this, _version));
    }
  }
  sort() {
    super.sort();
    __privateMethod(this, _SvelteURLSearchParams_instances, update_url_fn).call(this);
    increment(__privateGet(this, _version));
  }
  toString() {
    get(__privateGet(this, _version));
    return super.toString();
  }
  values() {
    get(__privateGet(this, _version));
    return super.values();
  }
  entries() {
    get(__privateGet(this, _version));
    return super.entries();
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  get size() {
    get(__privateGet(this, _version));
    return super.size;
  }
};
_version = new WeakMap();
_url = new WeakMap();
_updating = new WeakMap();
_SvelteURLSearchParams_instances = new WeakSet();
update_url_fn = function() {
  if (!__privateGet(this, _url) || __privateGet(this, _updating)) return;
  __privateSet(this, _updating, true);
  const search = this.toString();
  __privateGet(this, _url).search = search && `?${search}`;
  __privateSet(this, _updating, false);
};

// node_modules/svelte/src/reactivity/url.js
var current_url = null;
function get_current_url() {
  return current_url;
}

// node_modules/svelte/src/reactivity/reactive-value.js
var _fn, _subscribe;
var ReactiveValue = class {
  /**
   *
   * @param {() => T} fn
   * @param {(update: () => void) => void} onsubscribe
   */
  constructor(fn, onsubscribe) {
    __privateAdd(this, _fn);
    __privateAdd(this, _subscribe);
    __privateSet(this, _fn, fn);
    __privateSet(this, _subscribe, createSubscriber(onsubscribe));
  }
  get current() {
    __privateGet(this, _subscribe).call(this);
    return __privateGet(this, _fn).call(this);
  }
};
_fn = new WeakMap();
_subscribe = new WeakMap();

// node_modules/svelte/src/reactivity/media-query.js
var parenthesis_regex = /\(.+\)/;
var non_parenthesized_keywords = /* @__PURE__ */ new Set(["all", "print", "screen", "and", "or", "not", "only"]);
var MediaQuery = class extends ReactiveValue {
  /**
   * @param {string} query A media query string
   * @param {boolean} [fallback] Fallback value for the server
   */
  constructor(query, fallback2) {
    let final_query = parenthesis_regex.test(query) || // we need to use `some` here because technically this `window.matchMedia('random,screen')` still returns true
    query.split(/[\s,]+/).some((keyword) => non_parenthesized_keywords.has(keyword.trim())) ? query : `(${query})`;
    const q = window.matchMedia(final_query);
    super(
      () => q.matches,
      (update2) => on(q, "change", update2)
    );
  }
};

// node_modules/@xyflow/svelte/dist/lib/store/visibleElements.js
function getVisibleNodes(nodeLookup, transform2, width, height) {
  const visibleNodes = /* @__PURE__ */ new Map();
  getNodesInside(nodeLookup, { x: 0, y: 0, width, height }, transform2, true).forEach((node) => {
    visibleNodes.set(node.id, node);
  });
  return visibleNodes;
}
function getLayoutedEdges(options) {
  var _a3;
  const { edges, defaultEdgeOptions, nodeLookup, previousEdges, connectionMode, onerror, onlyRenderVisible, elevateEdgesOnSelect } = options;
  const layoutedEdges = /* @__PURE__ */ new Map();
  for (const edge of edges) {
    const sourceNode = nodeLookup.get(edge.source);
    const targetNode = nodeLookup.get(edge.target);
    if (!sourceNode || !targetNode) {
      continue;
    }
    if (onlyRenderVisible) {
      const { visibleNodes, transform: transform2, width, height } = options;
      if (isEdgeVisible({
        sourceNode,
        targetNode,
        width,
        height,
        transform: transform2
      })) {
        visibleNodes.set(sourceNode.id, sourceNode);
        visibleNodes.set(targetNode.id, targetNode);
      } else {
        continue;
      }
    }
    const previous = previousEdges.get(edge.id);
    if (previous && edge === previous.edge && sourceNode == previous.sourceNode && targetNode == previous.targetNode) {
      layoutedEdges.set(edge.id, previous);
      continue;
    }
    const edgePosition = getEdgePosition({
      id: edge.id,
      sourceNode,
      targetNode,
      sourceHandle: edge.sourceHandle || null,
      targetHandle: edge.targetHandle || null,
      connectionMode,
      onError: onerror
    });
    if (edgePosition) {
      layoutedEdges.set(edge.id, {
        ...defaultEdgeOptions,
        ...edge,
        ...edgePosition,
        zIndex: getElevatedEdgeZIndex({
          selected: edge.selected,
          zIndex: (_a3 = edge.zIndex) != null ? _a3 : defaultEdgeOptions.zIndex,
          sourceNode,
          targetNode,
          elevateOnSelect: elevateEdgesOnSelect
        }),
        sourceNode,
        targetNode,
        edge
      });
    }
  }
  return layoutedEdges;
}

// node_modules/@xyflow/svelte/dist/lib/store/initial-store.svelte.js
var initialNodeTypes = {
  input: InputNode,
  output: OutputNode,
  default: DefaultNode,
  group: GroupNode
};
var initialEdgeTypes = {
  straight: StraightEdgeInternal,
  smoothstep: SmoothStepEdgeInternal,
  default: BezierEdge,
  step: StepEdgeInternal
};
function getInitialViewport(_nodesInitialized, fitView, initialViewport, width, height, nodeLookup) {
  if (fitView && !initialViewport && width && height) {
    const bounds = getInternalNodesBounds(nodeLookup, {
      filter: (node) => !!((node.width || node.initialWidth) && (node.height || node.initialHeight))
    });
    return getViewportForBounds(bounds, width, height, 0.5, 2, 0.1);
  } else {
    return initialViewport != null ? initialViewport : { x: 0, y: 0, zoom: 1 };
  }
}
function getInitialStore(signals) {
  var _a3, _b3, _c2, _flowId, _domNode, _panZoom, _width, _height, _nodesInitialized, _viewportInitialized, __edges, _selectedNodes, _selectedEdges, _visible, _nodesDraggable, _nodesConnectable, _elementsSelectable, _nodesFocusable, _edgesFocusable, _disableKeyboardA11y, _minZoom, _maxZoom, _nodeOrigin, _nodeExtent, _translateExtent, _defaultEdgeOptions, _nodeDragThreshold, _autoPanOnNodeDrag, _autoPanOnConnect, _autoPanOnNodeFocus, _autoPanSpeed, _connectionDragThreshold, _snapGrid, _dragging, _selectionRect, _selectionKeyPressed, _multiselectionKeyPressed, _deleteKeyPressed, _panActivationKeyPressed, _zoomActivationKeyPressed, _selectionRectMode, _ariaLiveMessage, _selectionMode, _nodeTypes, _edgeTypes, _noPanClass, _noDragClass, _noWheelClass, _ariaLabelConfig, __viewport, __connection, _connection, _connectionMode, _connectionRadius, _isValidConnection, _selectNodesOnDrag, _defaultMarkerColor, _markers, _onlyRenderVisibleElements, _onerror, _ondelete, _onbeforedelete, _onbeforeconnect, _onconnect, _onconnectstart, _onconnectend, _onbeforereconnect, _onreconnect, _onreconnectstart, _onreconnectend, _clickConnect, _onclickconnectstart, _onclickconnectend, _clickConnectStartHandle, _onselectiondrag, _onselectiondragstart, _onselectiondragstop, _colorMode;
  class SvelteFlowStore {
    constructor() {
      __privateAdd(this, _flowId, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.id) != null ? _a4 : "1";
      }));
      __privateAdd(this, _domNode, state(null));
      __privateAdd(this, _panZoom, state(null));
      __privateAdd(this, _width, state((_a3 = signals.width) != null ? _a3 : 0));
      __privateAdd(this, _height, state((_b3 = signals.height) != null ? _b3 : 0));
      __privateAdd(this, _nodesInitialized, user_derived(() => {
        var _a4, _b4;
        const nodesInitialized = adoptUserNodes(signals.nodes, this.nodeLookup, this.parentLookup, {
          nodeExtent: this.nodeExtent,
          nodeOrigin: this.nodeOrigin,
          elevateNodesOnSelect: (_a4 = signals.props.elevateNodesOnSelect) != null ? _a4 : true,
          checkEquality: true
        });
        if (this.fitViewQueued && nodesInitialized) {
          if ((_b4 = this.fitViewOptions) == null ? void 0 : _b4.duration) {
            this.resolveFitView();
          } else {
            queueMicrotask(() => {
              this.resolveFitView();
            });
          }
        }
        return nodesInitialized;
      }));
      __privateAdd(this, _viewportInitialized, user_derived(() => this.panZoom !== null));
      __privateAdd(this, __edges, user_derived(() => {
        updateConnectionLookup(this.connectionLookup, this.edgeLookup, signals.edges);
        return signals.edges;
      }));
      __publicField(this, "_prevSelectedNodes", []);
      __publicField(this, "_prevSelectedNodeIds", /* @__PURE__ */ new Set());
      __privateAdd(this, _selectedNodes, user_derived(() => {
        const selectedNodesCount = this._prevSelectedNodeIds.size;
        const selectedNodeIds = /* @__PURE__ */ new Set();
        const selectedNodes = this.nodes.filter((node) => {
          if (node.selected) {
            selectedNodeIds.add(node.id);
            this._prevSelectedNodeIds.delete(node.id);
          }
          return node.selected;
        });
        if (selectedNodesCount !== selectedNodeIds.size || this._prevSelectedNodeIds.size > 0) {
          this._prevSelectedNodes = selectedNodes;
        }
        this._prevSelectedNodeIds = selectedNodeIds;
        return this._prevSelectedNodes;
      }));
      __publicField(this, "_prevSelectedEdges", []);
      __publicField(this, "_prevSelectedEdgeIds", /* @__PURE__ */ new Set());
      __privateAdd(this, _selectedEdges, user_derived(() => {
        const selectedEdgesCount = this._prevSelectedEdgeIds.size;
        const selectedEdgeIds = /* @__PURE__ */ new Set();
        const selectedEdges = this.edges.filter((edge) => {
          if (edge.selected) {
            selectedEdgeIds.add(edge.id);
            this._prevSelectedEdgeIds.delete(edge.id);
          }
          return edge.selected;
        });
        if (selectedEdgesCount !== selectedEdgeIds.size || this._prevSelectedEdgeIds.size > 0) {
          this._prevSelectedEdges = selectedEdges;
        }
        this._prevSelectedEdgeIds = selectedEdgeIds;
        return this._prevSelectedEdges;
      }));
      __publicField(this, "selectionChangeHandlers", /* @__PURE__ */ new Map());
      __publicField(this, "nodeLookup", /* @__PURE__ */ new Map());
      __publicField(this, "parentLookup", /* @__PURE__ */ new Map());
      __publicField(this, "connectionLookup", /* @__PURE__ */ new Map());
      __publicField(this, "edgeLookup", /* @__PURE__ */ new Map());
      __publicField(this, "_prevVisibleEdges", /* @__PURE__ */ new Map());
      __privateAdd(this, _visible, user_derived(() => {
        var _a4;
        const {
          // We need to access this._nodes to trigger on changes
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          nodes,
          _edges: edges,
          _prevVisibleEdges: previousEdges,
          nodeLookup,
          connectionMode,
          onerror,
          onlyRenderVisibleElements,
          defaultEdgeOptions
        } = this;
        let visibleNodes;
        let visibleEdges;
        const options = {
          edges,
          defaultEdgeOptions,
          previousEdges,
          nodeLookup,
          connectionMode,
          elevateEdgesOnSelect: (_a4 = signals.props.elevateEdgesOnSelect) != null ? _a4 : true,
          onerror
        };
        if (onlyRenderVisibleElements) {
          const { viewport, width, height } = this;
          const transform2 = [viewport.x, viewport.y, viewport.zoom];
          visibleNodes = getVisibleNodes(nodeLookup, transform2, width, height);
          visibleEdges = getLayoutedEdges({
            ...options,
            onlyRenderVisible: true,
            visibleNodes,
            transform: transform2,
            width,
            height
          });
        } else {
          visibleNodes = this.nodeLookup;
          visibleEdges = getLayoutedEdges(options);
        }
        return { nodes: visibleNodes, edges: visibleEdges };
      }));
      __privateAdd(this, _nodesDraggable, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.nodesDraggable) != null ? _a4 : true;
      }));
      __privateAdd(this, _nodesConnectable, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.nodesConnectable) != null ? _a4 : true;
      }));
      __privateAdd(this, _elementsSelectable, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.elementsSelectable) != null ? _a4 : true;
      }));
      __privateAdd(this, _nodesFocusable, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.nodesFocusable) != null ? _a4 : true;
      }));
      __privateAdd(this, _edgesFocusable, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.edgesFocusable) != null ? _a4 : true;
      }));
      __privateAdd(this, _disableKeyboardA11y, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.disableKeyboardA11y) != null ? _a4 : false;
      }));
      __privateAdd(this, _minZoom, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.minZoom) != null ? _a4 : 0.5;
      }));
      __privateAdd(this, _maxZoom, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.maxZoom) != null ? _a4 : 2;
      }));
      __privateAdd(this, _nodeOrigin, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.nodeOrigin) != null ? _a4 : [0, 0];
      }));
      __privateAdd(this, _nodeExtent, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.nodeExtent) != null ? _a4 : infiniteExtent;
      }));
      __privateAdd(this, _translateExtent, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.translateExtent) != null ? _a4 : infiniteExtent;
      }));
      __privateAdd(this, _defaultEdgeOptions, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.defaultEdgeOptions) != null ? _a4 : {};
      }));
      __privateAdd(this, _nodeDragThreshold, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.nodeDragThreshold) != null ? _a4 : 1;
      }));
      __privateAdd(this, _autoPanOnNodeDrag, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.autoPanOnNodeDrag) != null ? _a4 : true;
      }));
      __privateAdd(this, _autoPanOnConnect, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.autoPanOnConnect) != null ? _a4 : true;
      }));
      __privateAdd(this, _autoPanOnNodeFocus, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.autoPanOnNodeFocus) != null ? _a4 : true;
      }));
      __privateAdd(this, _autoPanSpeed, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.autoPanSpeed) != null ? _a4 : 15;
      }));
      __privateAdd(this, _connectionDragThreshold, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.connectionDragThreshold) != null ? _a4 : 1;
      }));
      __publicField(this, "fitViewQueued", (_c2 = signals.props.fitView) != null ? _c2 : false);
      __publicField(this, "fitViewOptions", signals.props.fitViewOptions);
      __publicField(this, "fitViewResolver", null);
      __privateAdd(this, _snapGrid, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.snapGrid) != null ? _a4 : null;
      }));
      __privateAdd(this, _dragging, state(false));
      __privateAdd(this, _selectionRect, state(null));
      __privateAdd(this, _selectionKeyPressed, state(false));
      __privateAdd(this, _multiselectionKeyPressed, state(false));
      __privateAdd(this, _deleteKeyPressed, state(false));
      __privateAdd(this, _panActivationKeyPressed, state(false));
      __privateAdd(this, _zoomActivationKeyPressed, state(false));
      __privateAdd(this, _selectionRectMode, state(null));
      __privateAdd(this, _ariaLiveMessage, state(""));
      __privateAdd(this, _selectionMode, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.selectionMode) != null ? _a4 : SelectionMode.Partial;
      }));
      __privateAdd(this, _nodeTypes, user_derived(() => ({ ...initialNodeTypes, ...signals.props.nodeTypes })));
      __privateAdd(this, _edgeTypes, user_derived(() => ({ ...initialEdgeTypes, ...signals.props.edgeTypes })));
      __privateAdd(this, _noPanClass, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.noPanClass) != null ? _a4 : "nopan";
      }));
      __privateAdd(this, _noDragClass, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.noDragClass) != null ? _a4 : "nodrag";
      }));
      __privateAdd(this, _noWheelClass, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.noWheelClass) != null ? _a4 : "nowheel";
      }));
      __privateAdd(this, _ariaLabelConfig, user_derived(() => mergeAriaLabelConfig(signals.props.ariaLabelConfig)));
      __privateAdd(this, __viewport, state(getInitialViewport(this.nodesInitialized, signals.props.fitView, signals.props.initialViewport, this.width, this.height, this.nodeLookup)));
      __privateAdd(this, __connection, state(
        // _connection is viewport independent and originating from XYHandle
        initialConnection
      ));
      __privateAdd(this, _connection, user_derived(() => {
        if (!this._connection.inProgress) {
          return this._connection;
        }
        return {
          ...this._connection,
          to: pointToRendererPoint(this._connection.to, [this.viewport.x, this.viewport.y, this.viewport.zoom])
        };
      }));
      __privateAdd(this, _connectionMode, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.connectionMode) != null ? _a4 : ConnectionMode.Strict;
      }));
      __privateAdd(this, _connectionRadius, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.connectionRadius) != null ? _a4 : 20;
      }));
      __privateAdd(this, _isValidConnection, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.isValidConnection) != null ? _a4 : (() => true);
      }));
      __privateAdd(this, _selectNodesOnDrag, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.selectNodesOnDrag) != null ? _a4 : true;
      }));
      __privateAdd(this, _defaultMarkerColor, user_derived(() => signals.props.defaultMarkerColor === void 0 ? "#b1b1b7" : signals.props.defaultMarkerColor));
      __privateAdd(this, _markers, user_derived(() => {
        return createMarkerIds(signals.edges, {
          defaultColor: this.defaultMarkerColor,
          id: this.flowId,
          defaultMarkerStart: this.defaultEdgeOptions.markerStart,
          defaultMarkerEnd: this.defaultEdgeOptions.markerEnd
        });
      }));
      __privateAdd(this, _onlyRenderVisibleElements, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.onlyRenderVisibleElements) != null ? _a4 : false;
      }));
      __privateAdd(this, _onerror, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.onflowerror) != null ? _a4 : devWarn;
      }));
      __privateAdd(this, _ondelete, user_derived(() => signals.props.ondelete));
      __privateAdd(this, _onbeforedelete, user_derived(() => signals.props.onbeforedelete));
      __privateAdd(this, _onbeforeconnect, user_derived(() => signals.props.onbeforeconnect));
      __privateAdd(this, _onconnect, user_derived(() => signals.props.onconnect));
      __privateAdd(this, _onconnectstart, user_derived(() => signals.props.onconnectstart));
      __privateAdd(this, _onconnectend, user_derived(() => signals.props.onconnectend));
      __privateAdd(this, _onbeforereconnect, user_derived(() => signals.props.onbeforereconnect));
      __privateAdd(this, _onreconnect, user_derived(() => signals.props.onreconnect));
      __privateAdd(this, _onreconnectstart, user_derived(() => signals.props.onreconnectstart));
      __privateAdd(this, _onreconnectend, user_derived(() => signals.props.onreconnectend));
      __privateAdd(this, _clickConnect, user_derived(() => {
        var _a4;
        return (_a4 = signals.props.clickConnect) != null ? _a4 : true;
      }));
      __privateAdd(this, _onclickconnectstart, user_derived(() => signals.props.onclickconnectstart));
      __privateAdd(this, _onclickconnectend, user_derived(() => signals.props.onclickconnectend));
      __privateAdd(this, _clickConnectStartHandle, state(null));
      __privateAdd(this, _onselectiondrag, user_derived(() => signals.props.onselectiondrag));
      __privateAdd(this, _onselectiondragstart, user_derived(() => signals.props.onselectiondragstart));
      __privateAdd(this, _onselectiondragstop, user_derived(() => signals.props.onselectiondragstop));
      __publicField(this, "resolveFitView", async () => {
        var _a4;
        if (!this.panZoom) {
          return;
        }
        await fitViewport(
          {
            nodes: this.nodeLookup,
            width: this.width,
            height: this.height,
            panZoom: this.panZoom,
            minZoom: this.minZoom,
            maxZoom: this.maxZoom
          },
          this.fitViewOptions
        );
        (_a4 = this.fitViewResolver) == null ? void 0 : _a4.resolve(true);
        this.fitViewQueued = false;
        this.fitViewOptions = void 0;
        this.fitViewResolver = null;
      });
      __publicField(this, "_prefersDark", new MediaQuery("(prefers-color-scheme: dark)", signals.props.colorModeSSR === "dark"));
      __privateAdd(this, _colorMode, user_derived(() => {
        var _a4;
        return signals.props.colorMode === "system" ? this._prefersDark.current ? "dark" : "light" : (_a4 = signals.props.colorMode) != null ? _a4 : "light";
      }));
      if (true) {
        warnIfDeeplyReactive(signals.nodes, "nodes");
        warnIfDeeplyReactive(signals.edges, "edges");
      }
    }
    get flowId() {
      return get(__privateGet(this, _flowId));
    }
    set flowId(value) {
      set(__privateGet(this, _flowId), value);
    }
    get domNode() {
      return get(__privateGet(this, _domNode));
    }
    set domNode(value) {
      set(__privateGet(this, _domNode), value);
    }
    get panZoom() {
      return get(__privateGet(this, _panZoom));
    }
    set panZoom(value) {
      set(__privateGet(this, _panZoom), value);
    }
    get width() {
      return get(__privateGet(this, _width));
    }
    set width(value) {
      set(__privateGet(this, _width), value);
    }
    get height() {
      return get(__privateGet(this, _height));
    }
    set height(value) {
      set(__privateGet(this, _height), value);
    }
    get nodesInitialized() {
      return get(__privateGet(this, _nodesInitialized));
    }
    set nodesInitialized(value) {
      set(__privateGet(this, _nodesInitialized), value);
    }
    get viewportInitialized() {
      return get(__privateGet(this, _viewportInitialized));
    }
    set viewportInitialized(value) {
      set(__privateGet(this, _viewportInitialized), value);
    }
    get _edges() {
      return get(__privateGet(this, __edges));
    }
    set _edges(value) {
      set(__privateGet(this, __edges), value);
    }
    get nodes() {
      this.nodesInitialized;
      return signals.nodes;
    }
    set nodes(nodes) {
      signals.nodes = nodes;
    }
    get edges() {
      return this._edges;
    }
    set edges(edges) {
      signals.edges = edges;
    }
    get selectedNodes() {
      return get(__privateGet(this, _selectedNodes));
    }
    set selectedNodes(value) {
      set(__privateGet(this, _selectedNodes), value);
    }
    get selectedEdges() {
      return get(__privateGet(this, _selectedEdges));
    }
    set selectedEdges(value) {
      set(__privateGet(this, _selectedEdges), value);
    }
    get visible() {
      return get(__privateGet(this, _visible));
    }
    set visible(value) {
      set(__privateGet(this, _visible), value);
    }
    get nodesDraggable() {
      return get(__privateGet(this, _nodesDraggable));
    }
    set nodesDraggable(value) {
      set(__privateGet(this, _nodesDraggable), value);
    }
    get nodesConnectable() {
      return get(__privateGet(this, _nodesConnectable));
    }
    set nodesConnectable(value) {
      set(__privateGet(this, _nodesConnectable), value);
    }
    get elementsSelectable() {
      return get(__privateGet(this, _elementsSelectable));
    }
    set elementsSelectable(value) {
      set(__privateGet(this, _elementsSelectable), value);
    }
    get nodesFocusable() {
      return get(__privateGet(this, _nodesFocusable));
    }
    set nodesFocusable(value) {
      set(__privateGet(this, _nodesFocusable), value);
    }
    get edgesFocusable() {
      return get(__privateGet(this, _edgesFocusable));
    }
    set edgesFocusable(value) {
      set(__privateGet(this, _edgesFocusable), value);
    }
    get disableKeyboardA11y() {
      return get(__privateGet(this, _disableKeyboardA11y));
    }
    set disableKeyboardA11y(value) {
      set(__privateGet(this, _disableKeyboardA11y), value);
    }
    get minZoom() {
      return get(__privateGet(this, _minZoom));
    }
    set minZoom(value) {
      set(__privateGet(this, _minZoom), value);
    }
    get maxZoom() {
      return get(__privateGet(this, _maxZoom));
    }
    set maxZoom(value) {
      set(__privateGet(this, _maxZoom), value);
    }
    get nodeOrigin() {
      return get(__privateGet(this, _nodeOrigin));
    }
    set nodeOrigin(value) {
      set(__privateGet(this, _nodeOrigin), value);
    }
    get nodeExtent() {
      return get(__privateGet(this, _nodeExtent));
    }
    set nodeExtent(value) {
      set(__privateGet(this, _nodeExtent), value);
    }
    get translateExtent() {
      return get(__privateGet(this, _translateExtent));
    }
    set translateExtent(value) {
      set(__privateGet(this, _translateExtent), value);
    }
    get defaultEdgeOptions() {
      return get(__privateGet(this, _defaultEdgeOptions));
    }
    set defaultEdgeOptions(value) {
      set(__privateGet(this, _defaultEdgeOptions), value);
    }
    get nodeDragThreshold() {
      return get(__privateGet(this, _nodeDragThreshold));
    }
    set nodeDragThreshold(value) {
      set(__privateGet(this, _nodeDragThreshold), value);
    }
    get autoPanOnNodeDrag() {
      return get(__privateGet(this, _autoPanOnNodeDrag));
    }
    set autoPanOnNodeDrag(value) {
      set(__privateGet(this, _autoPanOnNodeDrag), value);
    }
    get autoPanOnConnect() {
      return get(__privateGet(this, _autoPanOnConnect));
    }
    set autoPanOnConnect(value) {
      set(__privateGet(this, _autoPanOnConnect), value);
    }
    get autoPanOnNodeFocus() {
      return get(__privateGet(this, _autoPanOnNodeFocus));
    }
    set autoPanOnNodeFocus(value) {
      set(__privateGet(this, _autoPanOnNodeFocus), value);
    }
    get autoPanSpeed() {
      return get(__privateGet(this, _autoPanSpeed));
    }
    set autoPanSpeed(value) {
      set(__privateGet(this, _autoPanSpeed), value);
    }
    get connectionDragThreshold() {
      return get(__privateGet(this, _connectionDragThreshold));
    }
    set connectionDragThreshold(value) {
      set(__privateGet(this, _connectionDragThreshold), value);
    }
    get snapGrid() {
      return get(__privateGet(this, _snapGrid));
    }
    set snapGrid(value) {
      set(__privateGet(this, _snapGrid), value);
    }
    get dragging() {
      return get(__privateGet(this, _dragging));
    }
    set dragging(value) {
      set(__privateGet(this, _dragging), value);
    }
    get selectionRect() {
      return get(__privateGet(this, _selectionRect));
    }
    set selectionRect(value) {
      set(__privateGet(this, _selectionRect), value);
    }
    get selectionKeyPressed() {
      return get(__privateGet(this, _selectionKeyPressed));
    }
    set selectionKeyPressed(value) {
      set(__privateGet(this, _selectionKeyPressed), value);
    }
    get multiselectionKeyPressed() {
      return get(__privateGet(this, _multiselectionKeyPressed));
    }
    set multiselectionKeyPressed(value) {
      set(__privateGet(this, _multiselectionKeyPressed), value);
    }
    get deleteKeyPressed() {
      return get(__privateGet(this, _deleteKeyPressed));
    }
    set deleteKeyPressed(value) {
      set(__privateGet(this, _deleteKeyPressed), value);
    }
    get panActivationKeyPressed() {
      return get(__privateGet(this, _panActivationKeyPressed));
    }
    set panActivationKeyPressed(value) {
      set(__privateGet(this, _panActivationKeyPressed), value);
    }
    get zoomActivationKeyPressed() {
      return get(__privateGet(this, _zoomActivationKeyPressed));
    }
    set zoomActivationKeyPressed(value) {
      set(__privateGet(this, _zoomActivationKeyPressed), value);
    }
    get selectionRectMode() {
      return get(__privateGet(this, _selectionRectMode));
    }
    set selectionRectMode(value) {
      set(__privateGet(this, _selectionRectMode), value);
    }
    get ariaLiveMessage() {
      return get(__privateGet(this, _ariaLiveMessage));
    }
    set ariaLiveMessage(value) {
      set(__privateGet(this, _ariaLiveMessage), value);
    }
    get selectionMode() {
      return get(__privateGet(this, _selectionMode));
    }
    set selectionMode(value) {
      set(__privateGet(this, _selectionMode), value);
    }
    get nodeTypes() {
      return get(__privateGet(this, _nodeTypes));
    }
    set nodeTypes(value) {
      set(__privateGet(this, _nodeTypes), value);
    }
    get edgeTypes() {
      return get(__privateGet(this, _edgeTypes));
    }
    set edgeTypes(value) {
      set(__privateGet(this, _edgeTypes), value);
    }
    get noPanClass() {
      return get(__privateGet(this, _noPanClass));
    }
    set noPanClass(value) {
      set(__privateGet(this, _noPanClass), value);
    }
    get noDragClass() {
      return get(__privateGet(this, _noDragClass));
    }
    set noDragClass(value) {
      set(__privateGet(this, _noDragClass), value);
    }
    get noWheelClass() {
      return get(__privateGet(this, _noWheelClass));
    }
    set noWheelClass(value) {
      set(__privateGet(this, _noWheelClass), value);
    }
    get ariaLabelConfig() {
      return get(__privateGet(this, _ariaLabelConfig));
    }
    set ariaLabelConfig(value) {
      set(__privateGet(this, _ariaLabelConfig), value);
    }
    get _viewport() {
      return get(__privateGet(this, __viewport));
    }
    set _viewport(value) {
      set(__privateGet(this, __viewport), value);
    }
    get viewport() {
      var _a4;
      return (_a4 = signals.viewport) != null ? _a4 : this._viewport;
    }
    set viewport(newViewport) {
      if (signals.viewport) {
        signals.viewport = newViewport;
      }
      this._viewport = newViewport;
    }
    get _connection() {
      return get(__privateGet(this, __connection));
    }
    set _connection(value) {
      set(__privateGet(this, __connection), value);
    }
    get connection() {
      return get(__privateGet(this, _connection));
    }
    set connection(value) {
      set(__privateGet(this, _connection), value);
    }
    get connectionMode() {
      return get(__privateGet(this, _connectionMode));
    }
    set connectionMode(value) {
      set(__privateGet(this, _connectionMode), value);
    }
    get connectionRadius() {
      return get(__privateGet(this, _connectionRadius));
    }
    set connectionRadius(value) {
      set(__privateGet(this, _connectionRadius), value);
    }
    get isValidConnection() {
      return get(__privateGet(this, _isValidConnection));
    }
    set isValidConnection(value) {
      set(__privateGet(this, _isValidConnection), value);
    }
    get selectNodesOnDrag() {
      return get(__privateGet(this, _selectNodesOnDrag));
    }
    set selectNodesOnDrag(value) {
      set(__privateGet(this, _selectNodesOnDrag), value);
    }
    get defaultMarkerColor() {
      return get(__privateGet(this, _defaultMarkerColor));
    }
    set defaultMarkerColor(value) {
      set(__privateGet(this, _defaultMarkerColor), value);
    }
    get markers() {
      return get(__privateGet(this, _markers));
    }
    set markers(value) {
      set(__privateGet(this, _markers), value);
    }
    get onlyRenderVisibleElements() {
      return get(__privateGet(this, _onlyRenderVisibleElements));
    }
    set onlyRenderVisibleElements(value) {
      set(__privateGet(this, _onlyRenderVisibleElements), value);
    }
    get onerror() {
      return get(__privateGet(this, _onerror));
    }
    set onerror(value) {
      set(__privateGet(this, _onerror), value);
    }
    get ondelete() {
      return get(__privateGet(this, _ondelete));
    }
    set ondelete(value) {
      set(__privateGet(this, _ondelete), value);
    }
    get onbeforedelete() {
      return get(__privateGet(this, _onbeforedelete));
    }
    set onbeforedelete(value) {
      set(__privateGet(this, _onbeforedelete), value);
    }
    get onbeforeconnect() {
      return get(__privateGet(this, _onbeforeconnect));
    }
    set onbeforeconnect(value) {
      set(__privateGet(this, _onbeforeconnect), value);
    }
    get onconnect() {
      return get(__privateGet(this, _onconnect));
    }
    set onconnect(value) {
      set(__privateGet(this, _onconnect), value);
    }
    get onconnectstart() {
      return get(__privateGet(this, _onconnectstart));
    }
    set onconnectstart(value) {
      set(__privateGet(this, _onconnectstart), value);
    }
    get onconnectend() {
      return get(__privateGet(this, _onconnectend));
    }
    set onconnectend(value) {
      set(__privateGet(this, _onconnectend), value);
    }
    get onbeforereconnect() {
      return get(__privateGet(this, _onbeforereconnect));
    }
    set onbeforereconnect(value) {
      set(__privateGet(this, _onbeforereconnect), value);
    }
    get onreconnect() {
      return get(__privateGet(this, _onreconnect));
    }
    set onreconnect(value) {
      set(__privateGet(this, _onreconnect), value);
    }
    get onreconnectstart() {
      return get(__privateGet(this, _onreconnectstart));
    }
    set onreconnectstart(value) {
      set(__privateGet(this, _onreconnectstart), value);
    }
    get onreconnectend() {
      return get(__privateGet(this, _onreconnectend));
    }
    set onreconnectend(value) {
      set(__privateGet(this, _onreconnectend), value);
    }
    get clickConnect() {
      return get(__privateGet(this, _clickConnect));
    }
    set clickConnect(value) {
      set(__privateGet(this, _clickConnect), value);
    }
    get onclickconnectstart() {
      return get(__privateGet(this, _onclickconnectstart));
    }
    set onclickconnectstart(value) {
      set(__privateGet(this, _onclickconnectstart), value);
    }
    get onclickconnectend() {
      return get(__privateGet(this, _onclickconnectend));
    }
    set onclickconnectend(value) {
      set(__privateGet(this, _onclickconnectend), value);
    }
    get clickConnectStartHandle() {
      return get(__privateGet(this, _clickConnectStartHandle));
    }
    set clickConnectStartHandle(value) {
      set(__privateGet(this, _clickConnectStartHandle), value);
    }
    get onselectiondrag() {
      return get(__privateGet(this, _onselectiondrag));
    }
    set onselectiondrag(value) {
      set(__privateGet(this, _onselectiondrag), value);
    }
    get onselectiondragstart() {
      return get(__privateGet(this, _onselectiondragstart));
    }
    set onselectiondragstart(value) {
      set(__privateGet(this, _onselectiondragstart), value);
    }
    get onselectiondragstop() {
      return get(__privateGet(this, _onselectiondragstop));
    }
    set onselectiondragstop(value) {
      set(__privateGet(this, _onselectiondragstop), value);
    }
    get colorMode() {
      return get(__privateGet(this, _colorMode));
    }
    set colorMode(value) {
      set(__privateGet(this, _colorMode), value);
    }
    resetStoreValues() {
      var _a4;
      this.dragging = false;
      this.selectionRect = null;
      this.selectionRectMode = null;
      this.selectionKeyPressed = false;
      this.multiselectionKeyPressed = false;
      this.deleteKeyPressed = false;
      this.panActivationKeyPressed = false;
      this.zoomActivationKeyPressed = false;
      this._connection = initialConnection;
      this.clickConnectStartHandle = null;
      this.viewport = (_a4 = signals.props.initialViewport) != null ? _a4 : { x: 0, y: 0, zoom: 1 };
      this.ariaLiveMessage = "";
    }
  }
  _flowId = new WeakMap();
  _domNode = new WeakMap();
  _panZoom = new WeakMap();
  _width = new WeakMap();
  _height = new WeakMap();
  _nodesInitialized = new WeakMap();
  _viewportInitialized = new WeakMap();
  __edges = new WeakMap();
  _selectedNodes = new WeakMap();
  _selectedEdges = new WeakMap();
  _visible = new WeakMap();
  _nodesDraggable = new WeakMap();
  _nodesConnectable = new WeakMap();
  _elementsSelectable = new WeakMap();
  _nodesFocusable = new WeakMap();
  _edgesFocusable = new WeakMap();
  _disableKeyboardA11y = new WeakMap();
  _minZoom = new WeakMap();
  _maxZoom = new WeakMap();
  _nodeOrigin = new WeakMap();
  _nodeExtent = new WeakMap();
  _translateExtent = new WeakMap();
  _defaultEdgeOptions = new WeakMap();
  _nodeDragThreshold = new WeakMap();
  _autoPanOnNodeDrag = new WeakMap();
  _autoPanOnConnect = new WeakMap();
  _autoPanOnNodeFocus = new WeakMap();
  _autoPanSpeed = new WeakMap();
  _connectionDragThreshold = new WeakMap();
  _snapGrid = new WeakMap();
  _dragging = new WeakMap();
  _selectionRect = new WeakMap();
  _selectionKeyPressed = new WeakMap();
  _multiselectionKeyPressed = new WeakMap();
  _deleteKeyPressed = new WeakMap();
  _panActivationKeyPressed = new WeakMap();
  _zoomActivationKeyPressed = new WeakMap();
  _selectionRectMode = new WeakMap();
  _ariaLiveMessage = new WeakMap();
  _selectionMode = new WeakMap();
  _nodeTypes = new WeakMap();
  _edgeTypes = new WeakMap();
  _noPanClass = new WeakMap();
  _noDragClass = new WeakMap();
  _noWheelClass = new WeakMap();
  _ariaLabelConfig = new WeakMap();
  __viewport = new WeakMap();
  __connection = new WeakMap();
  _connection = new WeakMap();
  _connectionMode = new WeakMap();
  _connectionRadius = new WeakMap();
  _isValidConnection = new WeakMap();
  _selectNodesOnDrag = new WeakMap();
  _defaultMarkerColor = new WeakMap();
  _markers = new WeakMap();
  _onlyRenderVisibleElements = new WeakMap();
  _onerror = new WeakMap();
  _ondelete = new WeakMap();
  _onbeforedelete = new WeakMap();
  _onbeforeconnect = new WeakMap();
  _onconnect = new WeakMap();
  _onconnectstart = new WeakMap();
  _onconnectend = new WeakMap();
  _onbeforereconnect = new WeakMap();
  _onreconnect = new WeakMap();
  _onreconnectstart = new WeakMap();
  _onreconnectend = new WeakMap();
  _clickConnect = new WeakMap();
  _onclickconnectstart = new WeakMap();
  _onclickconnectend = new WeakMap();
  _clickConnectStartHandle = new WeakMap();
  _onselectiondrag = new WeakMap();
  _onselectiondragstart = new WeakMap();
  _onselectiondragstop = new WeakMap();
  _colorMode = new WeakMap();
  return new SvelteFlowStore();
}
function warnIfDeeplyReactive(array2, name) {
  try {
    if (array2 && array2.length > 0) {
      structuredClone(array2[0]);
    }
  } catch (e) {
    console.warn(`Use $state.raw for ${name} to prevent performance issues.`);
  }
}

// node_modules/@xyflow/svelte/dist/lib/hooks/derivedWarning.svelte.js
function derivedWarning(functionName) {
  const storeContext = getContext(key2);
  if (!storeContext) {
    throw new Error(`In order to use ${functionName}() you need to wrap your component in a <SvelteFlowProvider />`);
  }
  if (storeContext.provider && typeof window === "object" && !effect_tracking()) {
    throw new Error(`Use $derived(${functionName}()) to receive updates when values change.`);
  }
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useStore.js
function useStore() {
  const storeContext = getContext(key2);
  if (!storeContext) {
    throw new Error("To call useStore outside of <SvelteFlow /> you need to wrap your component in a <SvelteFlowProvider />");
  }
  if (true) {
    derivedWarning("useStore");
  }
  return storeContext.getStore();
}

// node_modules/@xyflow/svelte/dist/lib/store/index.js
var key2 = Symbol();
function createStore(signals) {
  const store = getInitialStore(signals);
  function setNodeTypes(nodeTypes) {
    store.nodeTypes = {
      ...initialNodeTypes,
      ...nodeTypes
    };
  }
  function setEdgeTypes(edgeTypes) {
    store.edgeTypes = {
      ...initialEdgeTypes,
      ...edgeTypes
    };
  }
  function addEdge2(edgeParams) {
    store.edges = addEdge(edgeParams, store.edges);
  }
  const updateNodePositions = (nodeDragItems, dragging = false) => {
    store.nodes = store.nodes.map((node) => {
      const dragItem = nodeDragItems.get(node.id);
      return dragItem ? { ...node, position: dragItem.position, dragging } : node;
    });
  };
  function updateNodeInternals2(updates) {
    var _a3, _b3, _c2, _d, _e, _f;
    const { changes, updatedInternals } = updateNodeInternals(updates, store.nodeLookup, store.parentLookup, store.domNode, store.nodeOrigin);
    if (!updatedInternals) {
      return;
    }
    updateAbsolutePositions(store.nodeLookup, store.parentLookup, {
      nodeOrigin: store.nodeOrigin,
      nodeExtent: store.nodeExtent
    });
    if (store.fitViewQueued) {
      store.resolveFitView();
    }
    const newNodes = /* @__PURE__ */ new Map();
    for (const change of changes) {
      const userNode = (_a3 = store.nodeLookup.get(change.id)) == null ? void 0 : _a3.internals.userNode;
      if (!userNode) {
        continue;
      }
      const node = { ...userNode };
      switch (change.type) {
        case "dimensions": {
          const measured = { ...node.measured, ...change.dimensions };
          if (change.setAttributes) {
            node.width = (_c2 = (_b3 = change.dimensions) == null ? void 0 : _b3.width) != null ? _c2 : node.width;
            node.height = (_e = (_d = change.dimensions) == null ? void 0 : _d.height) != null ? _e : node.height;
          }
          node.measured = measured;
          break;
        }
        case "position":
          node.position = (_f = change.position) != null ? _f : node.position;
          break;
      }
      newNodes.set(change.id, node);
    }
    store.nodes = store.nodes.map((node) => {
      var _a4;
      return (_a4 = newNodes.get(node.id)) != null ? _a4 : node;
    });
  }
  function fitView(options) {
    var _a3;
    const fitViewResolver = (_a3 = store.fitViewResolver) != null ? _a3 : Promise.withResolvers();
    store.fitViewQueued = true;
    store.fitViewOptions = options;
    store.fitViewResolver = fitViewResolver;
    store.nodes = [...store.nodes];
    return fitViewResolver.promise;
  }
  async function setCenter(x, y, options) {
    const nextZoom = typeof (options == null ? void 0 : options.zoom) !== "undefined" ? options.zoom : store.maxZoom;
    const currentPanZoom = store.panZoom;
    if (!currentPanZoom) {
      return Promise.resolve(false);
    }
    await currentPanZoom.setViewport({
      x: store.width / 2 - x * nextZoom,
      y: store.height / 2 - y * nextZoom,
      zoom: nextZoom
    }, { duration: options == null ? void 0 : options.duration, ease: options == null ? void 0 : options.ease, interpolate: options == null ? void 0 : options.interpolate });
    return Promise.resolve(true);
  }
  function zoomBy(factor, options) {
    const panZoom = store.panZoom;
    if (!panZoom) {
      return Promise.resolve(false);
    }
    return panZoom.scaleBy(factor, options);
  }
  function zoomIn(options) {
    return zoomBy(1.2, options);
  }
  function zoomOut(options) {
    return zoomBy(1 / 1.2, options);
  }
  function setMinZoom(minZoom) {
    const panZoom = store.panZoom;
    if (panZoom) {
      panZoom.setScaleExtent([minZoom, store.maxZoom]);
      store.minZoom = minZoom;
    }
  }
  function setMaxZoom(maxZoom) {
    const panZoom = store.panZoom;
    if (panZoom) {
      panZoom.setScaleExtent([store.minZoom, maxZoom]);
      store.maxZoom = maxZoom;
    }
  }
  function setTranslateExtent(extent) {
    const panZoom = store.panZoom;
    if (panZoom) {
      panZoom.setTranslateExtent(extent);
      store.translateExtent = extent;
    }
  }
  function setPaneClickDistance(distance2) {
    var _a3;
    (_a3 = store.panZoom) == null ? void 0 : _a3.setClickDistance(distance2);
  }
  function deselect(elements, elementsToDeselect = null) {
    let deselected = false;
    const newElements = elements.map((element2) => {
      const shouldDeselect = elementsToDeselect ? elementsToDeselect.has(element2.id) : true;
      if (shouldDeselect && element2.selected) {
        deselected = true;
        return { ...element2, selected: false };
      }
      return element2;
    });
    return [deselected, newElements];
  }
  function unselectNodesAndEdges(params) {
    const nodesToDeselect = (params == null ? void 0 : params.nodes) ? new Set(params.nodes.map((node) => node.id)) : null;
    const [nodesDeselected, newNodes] = deselect(store.nodes, nodesToDeselect);
    if (nodesDeselected) {
      store.nodes = newNodes;
    }
    const edgesToDeselect = (params == null ? void 0 : params.edges) ? new Set(params.edges.map((node) => node.id)) : null;
    const [edgesDeselected, newEdges] = deselect(store.edges, edgesToDeselect);
    if (edgesDeselected) {
      store.edges = newEdges;
    }
  }
  function addSelectedNodes(ids) {
    const isMultiSelection = store.multiselectionKeyPressed;
    store.nodes = store.nodes.map((node) => {
      const nodeWillBeSelected = ids.includes(node.id);
      const selected = isMultiSelection ? node.selected || nodeWillBeSelected : nodeWillBeSelected;
      if (node.selected !== selected) {
        const internalNode = store.nodeLookup.get(node.id);
        if (internalNode)
          internalNode.selected = selected;
        node.selected = selected;
        return { ...node };
      }
      return node;
    });
    if (!isMultiSelection) {
      unselectNodesAndEdges({ nodes: [] });
    }
  }
  function addSelectedEdges(ids) {
    const isMultiSelection = store.multiselectionKeyPressed;
    store.edges = store.edges.map((edge) => {
      const edgeWillBeSelected = ids.includes(edge.id);
      const selected = isMultiSelection ? edge.selected || edgeWillBeSelected : edgeWillBeSelected;
      if (edge.selected !== selected) {
        return { ...edge, selected };
      }
      return edge;
    });
    if (!isMultiSelection) {
      unselectNodesAndEdges({ edges: [] });
    }
  }
  function handleNodeSelection(id2, unselect, nodeRef) {
    const node = store.nodeLookup.get(id2);
    if (!node) {
      console.warn("012", errorMessages["error012"](id2));
      return;
    }
    store.selectionRect = null;
    store.selectionRectMode = null;
    if (!node.selected) {
      addSelectedNodes([id2]);
    } else if (unselect || node.selected && store.multiselectionKeyPressed) {
      unselectNodesAndEdges({ nodes: [node], edges: [] });
      requestAnimationFrame(() => nodeRef == null ? void 0 : nodeRef.blur());
    }
  }
  function handleEdgeSelection(id2) {
    const edge = store.edgeLookup.get(id2);
    if (!edge) {
      console.warn("012", errorMessages["error012"](id2));
      return;
    }
    const selectable = edge.selectable || store.elementsSelectable && typeof edge.selectable === "undefined";
    if (selectable) {
      store.selectionRect = null;
      store.selectionRectMode = null;
      if (!edge.selected) {
        addSelectedEdges([id2]);
      } else if (edge.selected && store.multiselectionKeyPressed) {
        unselectNodesAndEdges({ nodes: [], edges: [edge] });
      }
    }
  }
  function moveSelectedNodes(direction, factor) {
    var _a3, _b3;
    const { nodeExtent, snapGrid, nodeOrigin, nodeLookup, nodesDraggable, onerror } = store;
    const nodeUpdates = /* @__PURE__ */ new Map();
    const xVelo = (_a3 = snapGrid == null ? void 0 : snapGrid[0]) != null ? _a3 : 5;
    const yVelo = (_b3 = snapGrid == null ? void 0 : snapGrid[1]) != null ? _b3 : 5;
    const xDiff = direction.x * xVelo * factor;
    const yDiff = direction.y * yVelo * factor;
    for (const node of nodeLookup.values()) {
      const isSelected = node.selected && (node.draggable || nodesDraggable && typeof node.draggable === "undefined");
      if (!isSelected) {
        continue;
      }
      let nextPosition = {
        x: node.internals.positionAbsolute.x + xDiff,
        y: node.internals.positionAbsolute.y + yDiff
      };
      if (snapGrid) {
        nextPosition = snapPosition(nextPosition, snapGrid);
      }
      const { position, positionAbsolute } = calculateNodePosition({
        nodeId: node.id,
        nextPosition,
        nodeLookup,
        nodeExtent,
        nodeOrigin,
        onError: onerror
      });
      node.position = position;
      node.internals.positionAbsolute = positionAbsolute;
      nodeUpdates.set(node.id, node);
    }
    updateNodePositions(nodeUpdates);
  }
  function panBy2(delta) {
    return panBy({
      delta,
      panZoom: store.panZoom,
      transform: [store.viewport.x, store.viewport.y, store.viewport.zoom],
      translateExtent: store.translateExtent,
      width: store.width,
      height: store.height
    });
  }
  const updateConnection = (newConnection) => {
    store._connection = { ...newConnection };
  };
  function cancelConnection() {
    store._connection = initialConnection;
  }
  function reset2() {
    store.resetStoreValues();
    unselectNodesAndEdges();
  }
  const storeWithActions = Object.assign(store, {
    setNodeTypes,
    setEdgeTypes,
    addEdge: addEdge2,
    updateNodePositions,
    updateNodeInternals: updateNodeInternals2,
    zoomIn,
    zoomOut,
    fitView,
    setCenter,
    setMinZoom,
    setMaxZoom,
    setTranslateExtent,
    setPaneClickDistance,
    unselectNodesAndEdges,
    addSelectedNodes,
    addSelectedEdges,
    handleNodeSelection,
    handleEdgeSelection,
    moveSelectedNodes,
    panBy: panBy2,
    updateConnection,
    cancelConnection,
    reset: reset2
  });
  return storeWithActions;
}

// node_modules/@xyflow/svelte/dist/lib/actions/zoom/index.js
function zoom(domNode, params) {
  const { minZoom, maxZoom, initialViewport, onPanZoomStart, onPanZoom, onPanZoomEnd, translateExtent, paneClickDistance, setPanZoomInstance, onDraggingChange, onTransformChange } = params;
  const panZoomInstance = XYPanZoom({
    domNode,
    minZoom,
    maxZoom,
    translateExtent,
    viewport: initialViewport,
    paneClickDistance,
    onPanZoom,
    onPanZoomStart,
    onPanZoomEnd,
    onDraggingChange
  });
  const viewport = panZoomInstance.getViewport();
  if (initialViewport.x !== viewport.x || initialViewport.y !== viewport.y || initialViewport.zoom !== viewport.zoom) {
    onTransformChange([viewport.x, viewport.y, viewport.zoom]);
  }
  setPanZoomInstance(panZoomInstance);
  panZoomInstance.update(params);
  return {
    update(params2) {
      panZoomInstance.update(params2);
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/container/Zoom/Zoom.svelte
var root8 = from_html(`<div class="svelte-flow__zoom svelte-flow__container"><!></div>`);
function Zoom($$anchor, $$props) {
  push($$props, true);
  let store = prop($$props, "store", 15);
  let panOnDragActive = user_derived(() => store().panActivationKeyPressed || $$props.panOnDrag);
  let panOnScrollActive = user_derived(() => store().panActivationKeyPressed || $$props.panOnScroll);
  const { viewport: initialViewport } = store();
  let onInitCalled = false;
  user_effect(() => {
    var _a3;
    if (!onInitCalled && store().viewportInitialized) {
      (_a3 = $$props.oninit) == null ? void 0 : _a3.call($$props);
      onInitCalled = true;
    }
  });
  var div = root8();
  var node = child(div);
  snippet(node, () => $$props.children);
  reset(div);
  action(div, ($$node, $$action_arg) => {
    var _a3;
    return (_a3 = zoom) == null ? void 0 : _a3($$node, $$action_arg);
  }, () => ({
    viewport: store().viewport,
    minZoom: store().minZoom,
    maxZoom: store().maxZoom,
    initialViewport,
    onDraggingChange: (dragging) => {
      store(store().dragging = dragging, true);
    },
    setPanZoomInstance: (instance) => {
      store(store().panZoom = instance, true);
    },
    onPanZoomStart: $$props.onmovestart,
    onPanZoom: $$props.onmove,
    onPanZoomEnd: $$props.onmoveend,
    zoomOnScroll: $$props.zoomOnScroll,
    zoomOnDoubleClick: $$props.zoomOnDoubleClick,
    zoomOnPinch: $$props.zoomOnPinch,
    panOnScroll: get(panOnScrollActive),
    panOnDrag: get(panOnDragActive),
    panOnScrollSpeed: $$props.panOnScrollSpeed,
    panOnScrollMode: $$props.panOnScrollMode,
    zoomActivationKeyPressed: store().zoomActivationKeyPressed,
    preventScrolling: typeof $$props.preventScrolling === "boolean" ? $$props.preventScrolling : true,
    noPanClassName: store().noPanClass,
    noWheelClassName: store().noWheelClass,
    userSelectionActive: !!store().selectionRect,
    translateExtent: store().translateExtent,
    lib: "svelte",
    paneClickDistance: $$props.paneClickDistance,
    onTransformChange: (transform2) => {
      store(store().viewport = { x: transform2[0], y: transform2[1], zoom: transform2[2] }, true);
    },
    connectionInProgress: store().connection.inProgress
  }));
  append($$anchor, div);
  pop();
}

// node_modules/@xyflow/svelte/dist/lib/container/Pane/Pane.svelte
function wrapHandler(handler, container) {
  return (event2) => {
    if (event2.target !== container) {
      return;
    }
    handler == null ? void 0 : handler(event2);
  };
}
function toggleSelected(ids) {
  return (item) => {
    const isSelected = ids.has(item.id);
    if (!!item.selected !== isSelected) {
      return { ...item, selected: isSelected };
    }
    return item;
  };
}
function isSetEqual(a, b) {
  if (a.size !== b.size) {
    return false;
  }
  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
}
var root9 = from_html(`<div><!></div>`);
function Pane($$anchor, $$props) {
  push($$props, true);
  let store = prop($$props, "store", 15), panOnDrag = prop($$props, "panOnDrag", 3, true);
  let container;
  let containerBounds = null;
  let selectedNodeIds = /* @__PURE__ */ new Set();
  let selectedEdgeIds = /* @__PURE__ */ new Set();
  let panOnDragActive = user_derived(() => store().panActivationKeyPressed || panOnDrag());
  let isSelecting = user_derived(() => store().selectionKeyPressed || store().selectionRect || $$props.selectionOnDrag && get(panOnDragActive) !== true);
  let hasActiveSelection = user_derived(() => store().elementsSelectable && (get(isSelecting) || store().selectionRectMode === "user"));
  let selectionInProgress = false;
  function onClick(event2) {
    var _a3;
    if (selectionInProgress || store().connection.inProgress) {
      selectionInProgress = false;
      return;
    }
    (_a3 = $$props.onpaneclick) == null ? void 0 : _a3.call($$props, { event: event2 });
    store().unselectNodesAndEdges();
    store(store().selectionRectMode = null, true);
  }
  function onPointerDown2(event2) {
    var _a3, _b3, _c2;
    containerBounds = container == null ? void 0 : container.getBoundingClientRect();
    if (!store().elementsSelectable || !get(isSelecting) || event2.button !== 0 || event2.target !== container || !containerBounds) {
      return;
    }
    (_b3 = (_a3 = event2.target) == null ? void 0 : _a3.setPointerCapture) == null ? void 0 : _b3.call(_a3, event2.pointerId);
    const { x, y } = getEventPosition(event2, containerBounds);
    store().unselectNodesAndEdges();
    store(store().selectionRect = { width: 0, height: 0, startX: x, startY: y, x, y }, true);
    (_c2 = $$props.onselectionstart) == null ? void 0 : _c2.call($$props, event2);
  }
  function onPointerMove(event2) {
    var _a3, _b3;
    if (!get(isSelecting) || !containerBounds || !store().selectionRect) {
      return;
    }
    selectionInProgress = true;
    const mousePos = getEventPosition(event2, containerBounds);
    const { startX = 0, startY = 0 } = store().selectionRect;
    const nextUserSelectRect = {
      ...store().selectionRect,
      x: mousePos.x < startX ? mousePos.x : startX,
      y: mousePos.y < startY ? mousePos.y : startY,
      width: Math.abs(mousePos.x - startX),
      height: Math.abs(mousePos.y - startY)
    };
    const prevSelectedNodeIds = selectedNodeIds;
    const prevSelectedEdgeIds = selectedEdgeIds;
    selectedNodeIds = new Set(getNodesInside(
      store().nodeLookup,
      nextUserSelectRect,
      [
        store().viewport.x,
        store().viewport.y,
        store().viewport.zoom
      ],
      store().selectionMode === SelectionMode.Partial,
      true
    ).map((n) => n.id));
    const edgesSelectable = (_a3 = store().defaultEdgeOptions.selectable) != null ? _a3 : true;
    selectedEdgeIds = /* @__PURE__ */ new Set();
    for (const nodeId of selectedNodeIds) {
      const connections = store().connectionLookup.get(nodeId);
      if (!connections) continue;
      for (const { edgeId } of connections.values()) {
        const edge = store().edgeLookup.get(edgeId);
        if (edge && ((_b3 = edge.selectable) != null ? _b3 : edgesSelectable)) {
          selectedEdgeIds.add(edgeId);
        }
      }
    }
    if (!isSetEqual(prevSelectedNodeIds, selectedNodeIds)) {
      store(store().nodes = store().nodes.map(toggleSelected(selectedNodeIds)), true);
    }
    if (!isSetEqual(prevSelectedEdgeIds, selectedEdgeIds)) {
      store(store().edges = store().edges.map(toggleSelected(selectedEdgeIds)), true);
    }
    store(store().selectionRectMode = "user", true);
    store(store().selectionRect = nextUserSelectRect, true);
  }
  function onPointerUp(event2) {
    var _a3, _b3, _c2;
    if (event2.button !== 0) {
      return;
    }
    (_b3 = (_a3 = event2.target) == null ? void 0 : _a3.releasePointerCapture) == null ? void 0 : _b3.call(_a3, event2.pointerId);
    if (!get(isSelecting) && store().selectionRectMode === "user" && event2.target === container) {
      onClick == null ? void 0 : onClick(event2);
    }
    store(store().selectionRect = null, true);
    if (selectedNodeIds.size > 0) {
      store(store().selectionRectMode = "nodes", true);
    }
    if (store().selectionKeyPressed) {
      selectionInProgress = false;
    }
    (_c2 = $$props.onselectionend) == null ? void 0 : _c2.call($$props, event2);
  }
  const onContextMenu = (event2) => {
    var _a3;
    if (Array.isArray(get(panOnDragActive)) && get(panOnDragActive).includes(2)) {
      event2.preventDefault();
      return;
    }
    (_a3 = $$props.onpanecontextmenu) == null ? void 0 : _a3.call($$props, { event: event2 });
  };
  var div = root9();
  let classes;
  var event_handler = user_derived(() => get(hasActiveSelection) ? void 0 : wrapHandler(onClick, container));
  div.__click = function(...$$args) {
    var _a3;
    (_a3 = get(event_handler)) == null ? void 0 : _a3.apply(this, $$args);
  };
  div.__pointerdown = function(...$$args) {
    var _a3;
    (_a3 = get(hasActiveSelection) ? onPointerDown2 : void 0) == null ? void 0 : _a3.apply(this, $$args);
  };
  div.__pointermove = function(...$$args) {
    var _a3;
    (_a3 = get(hasActiveSelection) ? onPointerMove : void 0) == null ? void 0 : _a3.apply(this, $$args);
  };
  div.__pointerup = function(...$$args) {
    var _a3;
    (_a3 = get(hasActiveSelection) ? onPointerUp : void 0) == null ? void 0 : _a3.apply(this, $$args);
  };
  var event_handler_1 = user_derived(() => wrapHandler(onContextMenu, container));
  div.__contextmenu = function(...$$args) {
    var _a3;
    (_a3 = get(event_handler_1)) == null ? void 0 : _a3.apply(this, $$args);
  };
  var node = child(div);
  snippet(node, () => $$props.children);
  reset(div);
  bind_this(div, ($$value) => container = $$value, () => container);
  template_effect(($0) => classes = set_class(div, 1, "svelte-flow__pane svelte-flow__container", null, classes, $0), [
    () => ({
      draggable: panOnDrag() === true || Array.isArray(panOnDrag()) && panOnDrag().includes(0),
      dragging: store().dragging,
      selection: get(isSelecting)
    })
  ]);
  append($$anchor, div);
  pop();
}
delegate([
  "click",
  "pointerdown",
  "pointermove",
  "pointerup",
  "contextmenu"
]);

// node_modules/@xyflow/svelte/dist/lib/container/Viewport/Viewport.svelte
var root10 = from_html(`<div class="svelte-flow__viewport xyflow__viewport svelte-flow__container"><!></div>`);
function Viewport($$anchor, $$props) {
  push($$props, true);
  var div = root10();
  let styles;
  var node = child(div);
  snippet(node, () => $$props.children);
  reset(div);
  template_effect(($0) => styles = set_style(div, "", styles, $0), [
    () => {
      var _a3, _b3, _c2;
      return {
        transform: `translate(${(_a3 = $$props.store.viewport.x) != null ? _a3 : ""}px, ${(_b3 = $$props.store.viewport.y) != null ? _b3 : ""}px) scale(${(_c2 = $$props.store.viewport.zoom) != null ? _c2 : ""})`
      };
    }
  ]);
  append($$anchor, div);
  pop();
}

// node_modules/@xyflow/svelte/dist/lib/actions/drag/index.js
function drag(domNode, params) {
  const { store, onDrag, onDragStart, onDragStop, onNodeMouseDown } = params;
  const dragInstance = XYDrag({
    onDrag,
    onDragStart,
    onDragStop,
    onNodeMouseDown,
    getStoreItems: () => {
      const { snapGrid, viewport } = store;
      return {
        nodes: store.nodes,
        nodeLookup: store.nodeLookup,
        edges: store.edges,
        nodeExtent: store.nodeExtent,
        snapGrid: snapGrid ? snapGrid : [0, 0],
        snapToGrid: !!snapGrid,
        nodeOrigin: store.nodeOrigin,
        multiSelectionActive: store.multiselectionKeyPressed,
        domNode: store.domNode,
        transform: [viewport.x, viewport.y, viewport.zoom],
        autoPanOnNodeDrag: store.autoPanOnNodeDrag,
        nodesDraggable: store.nodesDraggable,
        selectNodesOnDrag: store.selectNodesOnDrag,
        nodeDragThreshold: store.nodeDragThreshold,
        unselectNodesAndEdges: store.unselectNodesAndEdges,
        updateNodePositions: store.updateNodePositions,
        onSelectionDrag: store.onselectiondrag,
        onSelectionDragStart: store.onselectiondragstart,
        onSelectionDragStop: store.onselectiondragstop,
        panBy: store.panBy
      };
    }
  });
  function updateDrag(domNode2, params2) {
    if (params2.disabled) {
      dragInstance.destroy();
      return;
    }
    dragInstance.update({
      domNode: domNode2,
      noDragClassName: params2.noDragClass,
      handleSelector: params2.handleSelector,
      nodeId: params2.nodeId,
      isSelectable: params2.isSelectable,
      nodeClickDistance: params2.nodeClickDistance
    });
  }
  updateDrag(domNode, params);
  return {
    update(params2) {
      updateDrag(domNode, params2);
    },
    destroy() {
      dragInstance.destroy();
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/components/A11yDescriptions/A11yDescriptions.svelte
var root_12 = from_html(`<div aria-live="assertive" aria-atomic="true" class="a11y-live-msg svelte-13pq11u"> </div>`);
var root11 = from_html(`<div class="a11y-hidden svelte-13pq11u"> </div> <div class="a11y-hidden svelte-13pq11u"> </div> <!>`, 1);
var $$css2 = {
  hash: "svelte-13pq11u",
  code: ".a11y-hidden.svelte-13pq11u {display:none;}.a11y-live-msg.svelte-13pq11u {position:absolute;width:1px;height:1px;margin:-1px;border:0;padding:0;overflow:hidden;clip:rect(0px, 0px, 0px, 0px);clip-path:inset(100%);}"
};
function A11yDescriptions($$anchor, $$props) {
  push($$props, true);
  append_styles($$anchor, $$css2);
  var fragment = root11();
  var div = first_child(fragment);
  var text2 = child(div, true);
  reset(div);
  var div_1 = sibling(div, 2);
  var text_1 = child(div_1, true);
  reset(div_1);
  var node = sibling(div_1, 2);
  {
    var consequent = ($$anchor2) => {
      var div_2 = root_12();
      var text_2 = child(div_2, true);
      reset(div_2);
      template_effect(() => {
        set_attribute2(div_2, "id", `${ARIA_LIVE_MESSAGE}-${$$props.store.flowId}`);
        set_text(text_2, $$props.store.ariaLiveMessage);
      });
      append($$anchor2, div_2);
    };
    if_block(node, ($$render) => {
      if (!$$props.store.disableKeyboardA11y) $$render(consequent);
    });
  }
  template_effect(() => {
    set_attribute2(div, "id", `${ARIA_NODE_DESC_KEY}-${$$props.store.flowId}`);
    set_text(text2, $$props.store.disableKeyboardA11y ? $$props.store.ariaLabelConfig["node.a11yDescription.default"] : $$props.store.ariaLabelConfig["node.a11yDescription.keyboardDisabled"]);
    set_attribute2(div_1, "id", `${ARIA_EDGE_DESC_KEY}-${$$props.store.flowId}`);
    set_text(text_1, $$props.store.ariaLabelConfig["edge.a11yDescription.default"]);
  });
  append($$anchor, fragment);
  pop();
}

// node_modules/@xyflow/svelte/dist/lib/components/A11yDescriptions/index.js
var ARIA_NODE_DESC_KEY = "svelte-flow__node-desc";
var ARIA_EDGE_DESC_KEY = "svelte-flow__edge-desc";
var ARIA_LIVE_MESSAGE = "svelte-flow__aria-live";

// node_modules/@xyflow/svelte/dist/lib/components/NodeWrapper/NodeWrapper.svelte
var root_13 = from_html(`<div><!></div>`);
function NodeWrapper($$anchor, $$props) {
  push($$props, true);
  let store = prop($$props, "store", 15);
  let data = user_derived(() => fallback($$props.node.data, () => ({}), true)), selected = user_derived(() => fallback($$props.node.selected, false)), _draggable = user_derived(() => $$props.node.draggable), _selectable = user_derived(() => $$props.node.selectable), deletable = user_derived(() => fallback($$props.node.deletable, true)), _connectable = user_derived(() => $$props.node.connectable), _focusable = user_derived(() => $$props.node.focusable), hidden = user_derived(() => fallback($$props.node.hidden, false)), dragging = user_derived(() => fallback($$props.node.dragging, false)), style = user_derived(() => fallback($$props.node.style, "")), className = user_derived(() => $$props.node.class), type = user_derived(() => fallback($$props.node.type, "default")), parentId = user_derived(() => $$props.node.parentId), sourcePosition = user_derived(() => $$props.node.sourcePosition), targetPosition = user_derived(() => $$props.node.targetPosition), measuredWidth = user_derived(() => fallback($$props.node.measured, () => ({ width: 0, height: 0 }), true).width), measuredHeight = user_derived(() => fallback($$props.node.measured, () => ({ width: 0, height: 0 }), true).height), initialWidth = user_derived(() => $$props.node.initialWidth), initialHeight = user_derived(() => $$props.node.initialHeight), width = user_derived(() => $$props.node.width), height = user_derived(() => $$props.node.height), dragHandle = user_derived(() => $$props.node.dragHandle), zIndex = user_derived(() => fallback($$props.node.internals.z, 0)), positionX = user_derived(() => $$props.node.internals.positionAbsolute.x), positionY = user_derived(() => $$props.node.internals.positionAbsolute.y), userNode = user_derived(() => $$props.node.internals.userNode);
  let { id: id2 } = $$props.node;
  let draggable = user_derived(() => {
    var _a3;
    return (_a3 = get(_draggable)) != null ? _a3 : store().nodesDraggable;
  });
  let selectable = user_derived(() => {
    var _a3;
    return (_a3 = get(_selectable)) != null ? _a3 : store().elementsSelectable;
  });
  let connectable = user_derived(() => {
    var _a3;
    return (_a3 = get(_connectable)) != null ? _a3 : store().nodesConnectable;
  });
  let hasDimensions = user_derived(() => nodeHasDimensions($$props.node));
  let hasHandleBounds = user_derived(() => !!$$props.node.internals.handleBounds);
  let isInitialized = user_derived(() => get(hasDimensions) && get(hasHandleBounds));
  let focusable = user_derived(() => {
    var _a3;
    return (_a3 = get(_focusable)) != null ? _a3 : store().nodesFocusable;
  });
  function isInParentLookup(id3) {
    return store().parentLookup.has(id3);
  }
  let isParent = user_derived(() => isInParentLookup(id2));
  let nodeRef = state(null);
  let prevNodeRef = null;
  let prevType = get(type);
  let prevSourcePosition = get(sourcePosition);
  let prevTargetPosition = get(targetPosition);
  let NodeComponent = user_derived(() => {
    var _a3;
    return (_a3 = store().nodeTypes[get(type)]) != null ? _a3 : DefaultNode;
  });
  let ariaLabelConfig = user_derived(() => store().ariaLabelConfig);
  let connectableContext = {
    get value() {
      return get(connectable);
    }
  };
  setContext("svelteflow__node_connectable", connectableContext);
  setContext("svelteflow__node_id", id2);
  if (true) {
    user_effect(() => {
      const valid = !!store().nodeTypes[get(type)];
      if (!valid) {
        console.warn("003", errorMessages["error003"](get(type)));
      }
    });
  }
  let nodeStyle = user_derived(() => {
    var _a3, _b3;
    const w = get(measuredWidth) === void 0 ? (_a3 = get(width)) != null ? _a3 : get(initialWidth) : get(width);
    const h = get(measuredHeight) === void 0 ? (_b3 = get(height)) != null ? _b3 : get(initialHeight) : get(height);
    if (w === void 0 && h === void 0 && get(style) === void 0) {
      return void 0;
    }
    return `${get(style)};${w ? `width:${toPxString(w)};` : ""}${h ? `height:${toPxString(h)};` : ""}`;
  });
  user_effect(() => {
    const doUpdate = get(type) !== prevType || get(sourcePosition) !== prevSourcePosition || get(targetPosition) !== prevTargetPosition;
    if (doUpdate && get(nodeRef) !== null) {
      requestAnimationFrame(() => {
        if (get(nodeRef) !== null) {
          store().updateNodeInternals(/* @__PURE__ */ new Map([[id2, { id: id2, nodeElement: get(nodeRef), force: true }]]));
        }
      });
    }
    prevType = get(type);
    prevSourcePosition = get(sourcePosition);
    prevTargetPosition = get(targetPosition);
  });
  user_effect(() => {
    if ($$props.resizeObserver && (!get(isInitialized) || get(nodeRef) !== prevNodeRef)) {
      prevNodeRef && $$props.resizeObserver.unobserve(prevNodeRef);
      get(nodeRef) && $$props.resizeObserver.observe(get(nodeRef));
      prevNodeRef = get(nodeRef);
    }
  });
  onDestroy(() => {
    var _a3;
    if (prevNodeRef) {
      (_a3 = $$props.resizeObserver) == null ? void 0 : _a3.unobserve(prevNodeRef);
    }
  });
  function onSelectNodeHandler(event2) {
    var _a3;
    if (get(selectable) && (!store().selectNodesOnDrag || !get(draggable) || store().nodeDragThreshold > 0)) {
      store().handleNodeSelection(id2);
    }
    (_a3 = $$props.onnodeclick) == null ? void 0 : _a3.call($$props, { node: get(userNode), event: event2 });
  }
  function onKeyDown(event2) {
    if (isInputDOMNode(event2) || store().disableKeyboardA11y) {
      return;
    }
    if (elementSelectionKeys.includes(event2.key) && get(selectable)) {
      const unselect = event2.key === "Escape";
      store().handleNodeSelection(id2, unselect, get(nodeRef));
    } else if (get(draggable) && $$props.node.selected && Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event2.key)) {
      event2.preventDefault();
      store(
        store().ariaLiveMessage = get(ariaLabelConfig)["node.a11yDescription.ariaLiveMessage"]({
          direction: event2.key.replace("Arrow", "").toLowerCase(),
          x: ~~$$props.node.internals.positionAbsolute.x,
          y: ~~$$props.node.internals.positionAbsolute.y
        }),
        true
      );
      store().moveSelectedNodes(arrowKeyDiffs[event2.key], event2.shiftKey ? 4 : 1);
    }
  }
  const onFocus = () => {
    var _a3, _b3, _c2;
    if (store().disableKeyboardA11y || !store().autoPanOnNodeFocus || !((_a3 = get(nodeRef)) == null ? void 0 : _a3.matches(":focus-visible"))) {
      return;
    }
    const { width: width2, height: height2, viewport } = store();
    const withinViewport = getNodesInside(/* @__PURE__ */ new Map([[id2, $$props.node]]), { x: 0, y: 0, width: width2, height: height2 }, [viewport.x, viewport.y, viewport.zoom], true).length > 0;
    if (!withinViewport) {
      store().setCenter($$props.node.position.x + ((_b3 = $$props.node.measured.width) != null ? _b3 : 0) / 2, $$props.node.position.y + ((_c2 = $$props.node.measured.height) != null ? _c2 : 0) / 2, { zoom: viewport.zoom });
    }
  };
  var fragment = comment();
  var node_1 = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var div = root_13();
      attribute_effect(
        div,
        ($0, $1) => {
          var _a3;
          return {
            "data-id": id2,
            class: [
              "svelte-flow__node",
              `svelte-flow__node-${get(type)}`,
              get(className)
            ],
            style: get(nodeStyle),
            onclick: onSelectNodeHandler,
            onpointerenter: $$props.onnodepointerenter ? (event2) => $$props.onnodepointerenter({ node: get(userNode), event: event2 }) : void 0,
            onpointerleave: $$props.onnodepointerleave ? (event2) => $$props.onnodepointerleave({ node: get(userNode), event: event2 }) : void 0,
            onpointermove: $$props.onnodepointermove ? (event2) => $$props.onnodepointermove({ node: get(userNode), event: event2 }) : void 0,
            oncontextmenu: $$props.onnodecontextmenu ? (event2) => $$props.onnodecontextmenu({ node: get(userNode), event: event2 }) : void 0,
            onkeydown: get(focusable) ? onKeyDown : void 0,
            onfocus: get(focusable) ? onFocus : void 0,
            tabIndex: get(focusable) ? 0 : void 0,
            role: (_a3 = $$props.node.ariaRole) != null ? _a3 : get(focusable) ? "group" : void 0,
            "aria-roledescription": "node",
            "aria-describedby": store().disableKeyboardA11y ? void 0 : `${ARIA_NODE_DESC_KEY}-${store().flowId}`,
            ...$$props.node.domAttributes,
            [CLASS]: $0,
            [STYLE]: $1
          };
        },
        [
          () => ({
            dragging: get(dragging),
            selected: get(selected),
            draggable: get(draggable),
            connectable: get(connectable),
            selectable: get(selectable),
            nopan: get(draggable),
            parent: get(isParent)
          }),
          () => {
            var _a3, _b3;
            return {
              "z-index": get(zIndex),
              transform: `translate(${(_a3 = get(positionX)) != null ? _a3 : ""}px, ${(_b3 = get(positionY)) != null ? _b3 : ""}px)`,
              visibility: get(hasDimensions) ? "visible" : "hidden"
            };
          }
        ]
      );
      var node_2 = child(div);
      component(node_2, () => get(NodeComponent), ($$anchor3, NodeComponent_1) => {
        NodeComponent_1($$anchor3, {
          get data() {
            return get(data);
          },
          get id() {
            return id2;
          },
          get selected() {
            return get(selected);
          },
          get selectable() {
            return get(selectable);
          },
          get deletable() {
            return get(deletable);
          },
          get sourcePosition() {
            return get(sourcePosition);
          },
          get targetPosition() {
            return get(targetPosition);
          },
          get zIndex() {
            return get(zIndex);
          },
          get dragging() {
            return get(dragging);
          },
          get draggable() {
            return get(draggable);
          },
          get dragHandle() {
            return get(dragHandle);
          },
          get parentId() {
            return get(parentId);
          },
          get type() {
            return get(type);
          },
          get isConnectable() {
            return get(connectable);
          },
          get positionAbsoluteX() {
            return get(positionX);
          },
          get positionAbsoluteY() {
            return get(positionY);
          },
          get width() {
            return get(width);
          },
          get height() {
            return get(height);
          }
        });
      });
      reset(div);
      action(div, ($$node, $$action_arg) => {
        var _a3;
        return (_a3 = drag) == null ? void 0 : _a3($$node, $$action_arg);
      }, () => ({
        nodeId: id2,
        isSelectable: get(selectable),
        disabled: !get(draggable),
        handleSelector: get(dragHandle),
        noDragClass: store().noDragClass,
        nodeClickDistance: $$props.nodeClickDistance,
        onNodeMouseDown: store().handleNodeSelection,
        onDrag: (event2, _, targetNode, nodes) => {
          var _a3;
          (_a3 = $$props.onnodedrag) == null ? void 0 : _a3.call($$props, { event: event2, targetNode, nodes });
        },
        onDragStart: (event2, _, targetNode, nodes) => {
          var _a3;
          (_a3 = $$props.onnodedragstart) == null ? void 0 : _a3.call($$props, { event: event2, targetNode, nodes });
        },
        onDragStop: (event2, _, targetNode, nodes) => {
          var _a3;
          (_a3 = $$props.onnodedragstop) == null ? void 0 : _a3.call($$props, { event: event2, targetNode, nodes });
        },
        store: store()
      }));
      bind_this(div, ($$value) => set(nodeRef, $$value), () => get(nodeRef));
      append($$anchor2, div);
    };
    if_block(node_1, ($$render) => {
      if (!get(hidden)) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/@xyflow/svelte/dist/lib/container/NodeRenderer/NodeRenderer.svelte
var root12 = from_html(`<div class="svelte-flow__nodes"></div>`);
function NodeRenderer($$anchor, $$props) {
  push($$props, true);
  let store = prop($$props, "store", 15);
  const resizeObserver = typeof ResizeObserver === "undefined" ? null : new ResizeObserver((entries) => {
    const updates = /* @__PURE__ */ new Map();
    entries.forEach((entry) => {
      const id2 = entry.target.getAttribute("data-id");
      updates.set(id2, { id: id2, nodeElement: entry.target, force: true });
    });
    store().updateNodeInternals(updates);
  });
  onDestroy(() => {
    resizeObserver == null ? void 0 : resizeObserver.disconnect();
  });
  var div = root12();
  each(div, 21, () => store().visible.nodes.values(), (node) => node.id, ($$anchor2, node) => {
    NodeWrapper($$anchor2, {
      get node() {
        return get(node);
      },
      get resizeObserver() {
        return resizeObserver;
      },
      get nodeClickDistance() {
        return $$props.nodeClickDistance;
      },
      get onnodeclick() {
        return $$props.onnodeclick;
      },
      get onnodepointerenter() {
        return $$props.onnodepointerenter;
      },
      get onnodepointermove() {
        return $$props.onnodepointermove;
      },
      get onnodepointerleave() {
        return $$props.onnodepointerleave;
      },
      get onnodedrag() {
        return $$props.onnodedrag;
      },
      get onnodedragstart() {
        return $$props.onnodedragstart;
      },
      get onnodedragstop() {
        return $$props.onnodedragstop;
      },
      get onnodecontextmenu() {
        return $$props.onnodecontextmenu;
      },
      get store() {
        return store();
      },
      set store($$value) {
        store($$value);
      }
    });
  });
  reset(div);
  append($$anchor, div);
  pop();
}

// node_modules/@xyflow/svelte/dist/lib/components/EdgeWrapper/EdgeWrapper.svelte
var root_14 = from_svg(`<svg class="svelte-flow__edge-wrapper"><g><!></g></svg>`);
function EdgeWrapper($$anchor, $$props) {
  push($$props, true);
  let source2 = user_derived(() => $$props.edge.source), target = user_derived(() => $$props.edge.target), sourceX = user_derived(() => $$props.edge.sourceX), sourceY = user_derived(() => $$props.edge.sourceY), targetX = user_derived(() => $$props.edge.targetX), targetY = user_derived(() => $$props.edge.targetY), sourcePosition = user_derived(() => $$props.edge.sourcePosition), targetPosition = user_derived(() => $$props.edge.targetPosition), animated = user_derived(() => fallback($$props.edge.animated, false)), selected = user_derived(() => fallback($$props.edge.selected, false)), label2 = user_derived(() => $$props.edge.label), labelStyle = user_derived(() => $$props.edge.labelStyle), data = user_derived(() => fallback($$props.edge.data, () => ({}), true)), style = user_derived(() => $$props.edge.style), interactionWidth = user_derived(() => $$props.edge.interactionWidth), type = user_derived(() => fallback($$props.edge.type, "default")), sourceHandle = user_derived(() => $$props.edge.sourceHandle), targetHandle = user_derived(() => $$props.edge.targetHandle), markerStart = user_derived(() => $$props.edge.markerStart), markerEnd = user_derived(() => $$props.edge.markerEnd), _selectable = user_derived(() => $$props.edge.selectable), _focusable = user_derived(() => $$props.edge.focusable), deletable = user_derived(() => fallback($$props.edge.deletable, true)), hidden = user_derived(() => $$props.edge.hidden), zIndex = user_derived(() => $$props.edge.zIndex), className = user_derived(() => $$props.edge.class), ariaLabel = user_derived(() => $$props.edge.ariaLabel);
  let edgeRef = null;
  const { id: id2 } = $$props.edge;
  setContext("svelteflow__edge_id", id2);
  let selectable = user_derived(() => {
    var _a3;
    return (_a3 = get(_selectable)) != null ? _a3 : $$props.store.elementsSelectable;
  });
  let focusable = user_derived(() => {
    var _a3;
    return (_a3 = get(_focusable)) != null ? _a3 : $$props.store.edgesFocusable;
  });
  let EdgeComponent = user_derived(() => {
    var _a3;
    return (_a3 = $$props.store.edgeTypes[get(type)]) != null ? _a3 : BezierEdge;
  });
  let markerStartUrl = user_derived(() => get(markerStart) ? `url('#${getMarkerId(get(markerStart), $$props.store.flowId)}')` : void 0);
  let markerEndUrl = user_derived(() => get(markerEnd) ? `url('#${getMarkerId(get(markerEnd), $$props.store.flowId)}')` : void 0);
  function onclick2(event2) {
    var _a3;
    const edge = $$props.store.edgeLookup.get(id2);
    if (edge) {
      if (get(selectable)) $$props.store.handleEdgeSelection(id2);
      (_a3 = $$props.onedgeclick) == null ? void 0 : _a3.call($$props, { event: event2, edge });
    }
  }
  function onmouseevent(event2, callback) {
    const edge = $$props.store.edgeLookup.get(id2);
    if (edge) {
      callback({ event: event2, edge });
    }
  }
  function onkeydown(event2) {
    if (!$$props.store.disableKeyboardA11y && elementSelectionKeys.includes(event2.key) && get(selectable)) {
      const { unselectNodesAndEdges, addSelectedEdges } = $$props.store;
      const unselect = event2.key === "Escape";
      if (unselect) {
        edgeRef == null ? void 0 : edgeRef.blur();
        unselectNodesAndEdges({ edges: [$$props.edge] });
      } else {
        addSelectedEdges([id2]);
      }
    }
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var svg = root_14();
      let styles;
      var g = child(svg);
      attribute_effect(
        g,
        ($0) => {
          var _a3;
          return {
            class: ["svelte-flow__edge", get(className)],
            "data-id": id2,
            onclick: onclick2,
            oncontextmenu: $$props.onedgecontextmenu ? (e) => {
              onmouseevent(e, $$props.onedgecontextmenu);
            } : void 0,
            onpointerenter: $$props.onedgepointerenter ? (e) => {
              onmouseevent(e, $$props.onedgepointerenter);
            } : void 0,
            onpointerleave: $$props.onedgepointerleave ? (e) => {
              onmouseevent(e, $$props.onedgepointerleave);
            } : void 0,
            "aria-label": get(ariaLabel) === null ? void 0 : get(ariaLabel) ? get(ariaLabel) : `Edge from ${get(source2)} to ${get(target)}`,
            "aria-describedby": get(focusable) ? `${ARIA_EDGE_DESC_KEY}-${$$props.store.flowId}` : void 0,
            role: (_a3 = $$props.edge.ariaRole) != null ? _a3 : get(focusable) ? "group" : "img",
            "aria-roledescription": "edge",
            onkeydown: get(focusable) ? onkeydown : void 0,
            tabindex: get(focusable) ? 0 : void 0,
            ...$$props.edge.domAttributes,
            [CLASS]: $0
          };
        },
        [
          () => ({
            animated: get(animated),
            selected: get(selected),
            selectable: get(selectable)
          })
        ]
      );
      var node_1 = child(g);
      component(node_1, () => get(EdgeComponent), ($$anchor3, EdgeComponent_1) => {
        EdgeComponent_1($$anchor3, {
          get id() {
            return id2;
          },
          get source() {
            return get(source2);
          },
          get target() {
            return get(target);
          },
          get sourceX() {
            return get(sourceX);
          },
          get sourceY() {
            return get(sourceY);
          },
          get targetX() {
            return get(targetX);
          },
          get targetY() {
            return get(targetY);
          },
          get sourcePosition() {
            return get(sourcePosition);
          },
          get targetPosition() {
            return get(targetPosition);
          },
          get animated() {
            return get(animated);
          },
          get selected() {
            return get(selected);
          },
          get label() {
            return get(label2);
          },
          get labelStyle() {
            return get(labelStyle);
          },
          get data() {
            return get(data);
          },
          get style() {
            return get(style);
          },
          get interactionWidth() {
            return get(interactionWidth);
          },
          get selectable() {
            return get(selectable);
          },
          get deletable() {
            return get(deletable);
          },
          get type() {
            return get(type);
          },
          get sourceHandleId() {
            return get(sourceHandle);
          },
          get targetHandleId() {
            return get(targetHandle);
          },
          get markerStart() {
            return get(markerStartUrl);
          },
          get markerEnd() {
            return get(markerEndUrl);
          }
        });
      });
      reset(g);
      bind_this(g, ($$value) => edgeRef = $$value, () => edgeRef);
      reset(svg);
      template_effect(($0) => styles = set_style(svg, "", styles, $0), [() => ({ "z-index": get(zIndex) })]);
      append($$anchor2, svg);
    };
    if_block(node, ($$render) => {
      if (!get(hidden)) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/svelte/src/internal/flags/legacy.js
enable_legacy_mode_flag();

// node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/MarkerDefinition/MarkerDefinition.svelte
var root13 = from_svg(`<defs></defs>`);
function MarkerDefinition($$anchor, $$props) {
  push($$props, false);
  const store = useStore();
  init();
  var defs = root13();
  each(defs, 5, () => store.markers, (marker) => marker.id, ($$anchor2, marker) => {
    Marker($$anchor2, spread_props(() => get(marker)));
  });
  reset(defs);
  append($$anchor, defs);
  pop();
}

// node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/MarkerDefinition/Marker.svelte
var root_15 = from_svg(`<polyline class="arrow" fill="none" stroke-linecap="round" stroke-linejoin="round" points="-5,-4 0,0 -5,4"></polyline>`);
var root_3 = from_svg(`<polyline class="arrowclosed" stroke-linecap="round" stroke-linejoin="round" points="-5,-4 0,0 -5,4 -5,-4"></polyline>`);
var root14 = from_svg(`<marker class="svelte-flow__arrowhead" viewBox="-10 -10 20 20" refX="0" refY="0"><!></marker>`);
function Marker($$anchor, $$props) {
  push($$props, true);
  let width = prop($$props, "width", 3, 12.5), height = prop($$props, "height", 3, 12.5), markerUnits = prop($$props, "markerUnits", 3, "strokeWidth"), orient = prop($$props, "orient", 3, "auto-start-reverse"), color2 = prop($$props, "color", 3, "none");
  var marker = root14();
  var node = child(marker);
  {
    var consequent = ($$anchor2) => {
      var polyline = root_15();
      let styles;
      template_effect(
        ($0) => {
          set_attribute2(polyline, "stroke-width", $$props.strokeWidth);
          styles = set_style(polyline, "", styles, $0);
        },
        [() => ({ stroke: color2() })]
      );
      append($$anchor2, polyline);
    };
    var alternate = ($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      {
        var consequent_1 = ($$anchor3) => {
          var polyline_1 = root_3();
          let styles_1;
          template_effect(
            ($0) => {
              set_attribute2(polyline_1, "stroke-width", $$props.strokeWidth);
              styles_1 = set_style(polyline_1, "", styles_1, $0);
            },
            [() => ({ stroke: color2(), fill: color2() })]
          );
          append($$anchor3, polyline_1);
        };
        if_block(
          node_1,
          ($$render) => {
            if ($$props.type === MarkerType.ArrowClosed) $$render(consequent_1);
          },
          true
        );
      }
      append($$anchor2, fragment);
    };
    if_block(node, ($$render) => {
      if ($$props.type === MarkerType.Arrow) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  reset(marker);
  template_effect(() => {
    set_attribute2(marker, "id", $$props.id);
    set_attribute2(marker, "markerWidth", `${width()}`);
    set_attribute2(marker, "markerHeight", `${height()}`);
    set_attribute2(marker, "markerUnits", markerUnits());
    set_attribute2(marker, "orient", orient());
  });
  append($$anchor, marker);
  pop();
}

// node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/EdgeRenderer.svelte
var root15 = from_html(`<div class="svelte-flow__edges"><svg class="svelte-flow__marker"><!></svg> <!></div>`);
function EdgeRenderer($$anchor, $$props) {
  push($$props, true);
  let store = prop($$props, "store", 15);
  var div = root15();
  var svg = child(div);
  var node = child(svg);
  MarkerDefinition(node, {});
  reset(svg);
  var node_1 = sibling(svg, 2);
  each(node_1, 17, () => store().visible.edges.values(), (edge) => edge.id, ($$anchor2, edge) => {
    EdgeWrapper($$anchor2, {
      get edge() {
        return get(edge);
      },
      get onedgeclick() {
        return $$props.onedgeclick;
      },
      get onedgecontextmenu() {
        return $$props.onedgecontextmenu;
      },
      get onedgepointerenter() {
        return $$props.onedgepointerenter;
      },
      get onedgepointerleave() {
        return $$props.onedgepointerleave;
      },
      get store() {
        return store();
      },
      set store($$value) {
        store($$value);
      }
    });
  });
  reset(div);
  append($$anchor, div);
  pop();
}

// node_modules/@xyflow/svelte/dist/lib/components/Selection/Selection.svelte
var root_16 = from_html(`<div class="svelte-flow__selection svelte-1vr3gfi"></div>`);
var $$css3 = {
  hash: "svelte-1vr3gfi",
  code: ".svelte-flow__selection.svelte-1vr3gfi {position:absolute;top:0;left:0;}"
};
function Selection3($$anchor, $$props) {
  push($$props, true);
  append_styles($$anchor, $$css3);
  let x = prop($$props, "x", 3, 0), y = prop($$props, "y", 3, 0), width = prop($$props, "width", 3, 0), height = prop($$props, "height", 3, 0), isVisible = prop($$props, "isVisible", 3, true);
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var div = root_16();
      let styles;
      template_effect(($0) => styles = set_style(div, "", styles, $0), [
        () => ({
          width: typeof width() === "string" ? width() : toPxString(width()),
          height: typeof height() === "string" ? height() : toPxString(height()),
          transform: `translate(${x()}px, ${y()}px)`
        })
      ]);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if (isVisible()) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/@xyflow/svelte/dist/lib/components/NodeSelection/NodeSelection.svelte
function oncontextmenu(event2, $$props) {
  var _a3;
  const selectedNodes = $$props.store.nodes.filter((n) => n.selected);
  (_a3 = $$props.onselectioncontextmenu) == null ? void 0 : _a3.call($$props, { nodes: selectedNodes, event: event2 });
}
function onclick(event2, $$props) {
  var _a3;
  const selectedNodes = $$props.store.nodes.filter((n) => n.selected);
  (_a3 = $$props.onselectionclick) == null ? void 0 : _a3.call($$props, { nodes: selectedNodes, event: event2 });
}
var root_17 = from_html(`<div><!></div>`);
var $$css4 = {
  hash: "svelte-sf2y5e",
  code: ".svelte-flow__selection-wrapper.svelte-sf2y5e {position:absolute;top:0;left:0;z-index:2000;pointer-events:all;}"
};
function NodeSelection($$anchor, $$props) {
  push($$props, true);
  append_styles($$anchor, $$css4);
  let ref = state(void 0);
  user_effect(() => {
    var _a3;
    if (!$$props.store.disableKeyboardA11y) {
      (_a3 = get(ref)) == null ? void 0 : _a3.focus({ preventScroll: true });
    }
  });
  let bounds = user_derived(() => {
    if ($$props.store.selectionRectMode === "nodes") {
      $$props.store.nodes;
      return getInternalNodesBounds($$props.store.nodeLookup, { filter: (node) => !!node.selected });
    }
    return null;
  });
  function onkeydown(event2) {
    if (Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event2.key)) {
      event2.preventDefault();
      $$props.store.moveSelectedNodes(arrowKeyDiffs[event2.key], event2.shiftKey ? 4 : 1);
    }
  }
  var fragment = comment();
  var node_1 = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var div = root_17();
      div.__contextmenu = [oncontextmenu, $$props];
      div.__click = [onclick, $$props];
      div.__keydown = function(...$$args) {
        var _a3;
        (_a3 = $$props.store.disableKeyboardA11y ? void 0 : onkeydown) == null ? void 0 : _a3.apply(this, $$args);
      };
      let styles;
      var node_2 = child(div);
      Selection3(node_2, { width: "100%", height: "100%", x: 0, y: 0 });
      reset(div);
      action(div, ($$node, $$action_arg) => {
        var _a3;
        return (_a3 = drag) == null ? void 0 : _a3($$node, $$action_arg);
      }, () => ({
        disabled: false,
        store: $$props.store,
        onDrag: (event2, _, __, nodes) => {
          var _a3;
          (_a3 = $$props.onnodedrag) == null ? void 0 : _a3.call($$props, { event: event2, targetNode: null, nodes });
        },
        onDragStart: (event2, _, __, nodes) => {
          var _a3;
          (_a3 = $$props.onnodedragstart) == null ? void 0 : _a3.call($$props, { event: event2, targetNode: null, nodes });
        },
        onDragStop: (event2, _, __, nodes) => {
          var _a3;
          (_a3 = $$props.onnodedragstop) == null ? void 0 : _a3.call($$props, { event: event2, targetNode: null, nodes });
        }
      }));
      bind_this(div, ($$value) => set(ref, $$value), () => get(ref));
      template_effect(
        ($0) => {
          set_class(div, 1, clsx2(["svelte-flow__selection-wrapper", $$props.store.noPanClass]), "svelte-sf2y5e");
          set_attribute2(div, "role", $$props.store.disableKeyboardA11y ? void 0 : "button");
          set_attribute2(div, "tabindex", $$props.store.disableKeyboardA11y ? void 0 : -1);
          styles = set_style(div, "", styles, $0);
        },
        [
          () => {
            var _a3, _b3;
            return {
              width: toPxString(get(bounds).width),
              height: toPxString(get(bounds).height),
              transform: `translate(${(_a3 = get(bounds).x) != null ? _a3 : ""}px, ${(_b3 = get(bounds).y) != null ? _b3 : ""}px)`
            };
          }
        ]
      );
      append($$anchor2, div);
    };
    if_block(node_1, ($$render) => {
      if ($$props.store.selectionRectMode === "nodes" && get(bounds) && isNumeric(get(bounds).x) && isNumeric(get(bounds).y)) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  pop();
}
delegate(["contextmenu", "click", "keydown"]);

// node_modules/@svelte-put/shortcut/src/shortcut.js
function mapModifierToBitMask(def) {
  switch (def) {
    case "ctrl":
      return 8;
    case "shift":
      return 4;
    case "alt":
      return 2;
    case "meta":
      return 1;
  }
}
function shortcut(node, param) {
  let { enabled = true, trigger, type = "keydown" } = param;
  function handler(event2) {
    var _a3;
    const normalizedTriggers = Array.isArray(trigger) ? trigger : [trigger];
    const modifierMask = [event2.metaKey, event2.altKey, event2.shiftKey, event2.ctrlKey].reduce(
      (acc, value, index2) => {
        if (value) {
          return acc | 1 << index2;
        }
        return acc;
      },
      0
    );
    for (const trigger2 of normalizedTriggers) {
      const mergedTrigger = {
        preventDefault: false,
        enabled: true,
        ...trigger2
      };
      const { modifier, key: key3, callback, preventDefault: preventDefault2, enabled: triggerEnabled } = mergedTrigger;
      if (triggerEnabled) {
        if (event2.key !== key3) continue;
        if (modifier === null || modifier === false) {
          if (modifierMask !== 0) continue;
        } else if (modifier !== void 0 && ((_a3 = modifier == null ? void 0 : modifier[0]) == null ? void 0 : _a3.length) > 0) {
          const orDefs = Array.isArray(modifier) ? modifier : [modifier];
          let modified = false;
          for (const orDef of orDefs) {
            const mask = (Array.isArray(orDef) ? orDef : [orDef]).reduce(
              (acc, def) => acc | mapModifierToBitMask(def),
              0
            );
            if (mask === modifierMask) {
              modified = true;
              break;
            }
          }
          if (!modified) continue;
        }
        if (preventDefault2) event2.preventDefault();
        const detail = {
          node,
          trigger: mergedTrigger,
          originalEvent: event2
        };
        node.dispatchEvent(new CustomEvent("shortcut", { detail }));
        callback == null ? void 0 : callback(detail);
      }
    }
  }
  let off;
  if (enabled) {
    off = on(node, type, handler);
  }
  return {
    update: (update2) => {
      const { enabled: newEnabled = true, type: newType = "keydown" } = update2;
      if (enabled && (!newEnabled || type !== newType)) {
        off == null ? void 0 : off();
      } else if (!enabled && newEnabled) {
        off = on(node, newType, handler);
      }
      enabled = newEnabled;
      type = newType;
      trigger = update2.trigger;
    },
    destroy: () => {
      off == null ? void 0 : off();
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useSvelteFlow.svelte.js
function useSvelteFlow() {
  const store = user_derived(useStore);
  const getNodeRect = (node) => {
    var _a3, _b3, _c2, _d;
    const nodeToUse = isNode(node) ? node : get(store).nodeLookup.get(node.id);
    const position = nodeToUse.parentId ? evaluateAbsolutePosition(nodeToUse.position, nodeToUse.measured, nodeToUse.parentId, get(store).nodeLookup, get(store).nodeOrigin) : nodeToUse.position;
    const nodeWithPosition = {
      ...nodeToUse,
      position,
      width: (_b3 = (_a3 = nodeToUse.measured) == null ? void 0 : _a3.width) != null ? _b3 : nodeToUse.width,
      height: (_d = (_c2 = nodeToUse.measured) == null ? void 0 : _c2.height) != null ? _d : nodeToUse.height
    };
    return nodeToRect(nodeWithPosition);
  };
  function updateNode(id2, nodeUpdate, options = { replace: false }) {
    get(store).nodes = untrack(() => get(store).nodes).map((node) => {
      if (node.id === id2) {
        const nextNode = typeof nodeUpdate === "function" ? nodeUpdate(node) : nodeUpdate;
        return (options == null ? void 0 : options.replace) && isNode(nextNode) ? nextNode : { ...node, ...nextNode };
      }
      return node;
    });
  }
  function updateEdge(id2, edgeUpdate, options = { replace: false }) {
    get(store).edges = untrack(() => get(store).edges).map((edge) => {
      if (edge.id === id2) {
        const nextEdge = typeof edgeUpdate === "function" ? edgeUpdate(edge) : edgeUpdate;
        return options.replace && isEdge(nextEdge) ? nextEdge : { ...edge, ...nextEdge };
      }
      return edge;
    });
  }
  const getInternalNode = (id2) => get(store).nodeLookup.get(id2);
  return {
    zoomIn: get(store).zoomIn,
    zoomOut: get(store).zoomOut,
    getInternalNode,
    getNode: (id2) => {
      var _a3;
      return (_a3 = getInternalNode(id2)) == null ? void 0 : _a3.internals.userNode;
    },
    getNodes: (ids) => ids === void 0 ? get(store).nodes : getElements(get(store).nodeLookup, ids),
    getEdge: (id2) => get(store).edgeLookup.get(id2),
    getEdges: (ids) => ids === void 0 ? get(store).edges : getElements(get(store).edgeLookup, ids),
    setZoom: (zoomLevel, options) => {
      const panZoom = get(store).panZoom;
      return panZoom ? panZoom.scaleTo(zoomLevel, { duration: options == null ? void 0 : options.duration }) : Promise.resolve(false);
    },
    getZoom: () => get(store).viewport.zoom,
    setViewport: async (nextViewport, options) => {
      var _a3, _b3, _c2;
      const currentViewport = get(store).viewport;
      if (!get(store).panZoom) {
        return Promise.resolve(false);
      }
      await get(store).panZoom.setViewport(
        {
          x: (_a3 = nextViewport.x) != null ? _a3 : currentViewport.x,
          y: (_b3 = nextViewport.y) != null ? _b3 : currentViewport.y,
          zoom: (_c2 = nextViewport.zoom) != null ? _c2 : currentViewport.zoom
        },
        options
      );
      return Promise.resolve(true);
    },
    getViewport: () => snapshot(get(store).viewport),
    setCenter: async (x, y, options) => get(store).setCenter(x, y, options),
    fitView: (options) => get(store).fitView(options),
    fitBounds: async (bounds, options) => {
      var _a3;
      if (!get(store).panZoom) {
        return Promise.resolve(false);
      }
      const viewport = getViewportForBounds(bounds, get(store).width, get(store).height, get(store).minZoom, get(store).maxZoom, (_a3 = options == null ? void 0 : options.padding) != null ? _a3 : 0.1);
      await get(store).panZoom.setViewport(viewport, {
        duration: options == null ? void 0 : options.duration,
        ease: options == null ? void 0 : options.ease,
        interpolate: options == null ? void 0 : options.interpolate
      });
      return Promise.resolve(true);
    },
    /**
     * Partial is defined as "the 2 nodes/areas are intersecting partially".
     * If a is contained in b or b is contained in a, they are both
     * considered fully intersecting.
     */
    getIntersectingNodes: (nodeOrRect, partially = true, nodesToIntersect) => {
      const isRect = isRectObject(nodeOrRect);
      const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);
      if (!nodeRect) {
        return [];
      }
      return (nodesToIntersect || get(store).nodes).filter((n) => {
        const internalNode = get(store).nodeLookup.get(n.id);
        if (!internalNode || !isRect && n.id === nodeOrRect.id) {
          return false;
        }
        const currNodeRect = nodeToRect(internalNode);
        const overlappingArea = getOverlappingArea(currNodeRect, nodeRect);
        const partiallyVisible = partially && overlappingArea > 0;
        return partiallyVisible || overlappingArea >= currNodeRect.width * currNodeRect.height || overlappingArea >= nodeRect.width * nodeRect.height;
      });
    },
    isNodeIntersecting: (nodeOrRect, area, partially = true) => {
      const isRect = isRectObject(nodeOrRect);
      const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);
      if (!nodeRect) {
        return false;
      }
      const overlappingArea = getOverlappingArea(nodeRect, area);
      const partiallyVisible = partially && overlappingArea > 0;
      return partiallyVisible || overlappingArea >= area.width * area.height || overlappingArea >= nodeRect.width * nodeRect.height;
    },
    deleteElements: async ({ nodes: nodesToRemove = [], edges: edgesToRemove = [] }) => {
      var _a3, _b3;
      const { nodes: matchingNodes, edges: matchingEdges } = await getElementsToRemove({
        nodesToRemove,
        edgesToRemove,
        nodes: get(store).nodes,
        edges: get(store).edges,
        onBeforeDelete: get(store).onbeforedelete
      });
      if (matchingNodes) {
        get(store).nodes = untrack(() => get(store).nodes).filter((node) => !matchingNodes.some(({ id: id2 }) => id2 === node.id));
      }
      if (matchingEdges) {
        get(store).edges = untrack(() => get(store).edges).filter((edge) => !matchingEdges.some(({ id: id2 }) => id2 === edge.id));
      }
      if (matchingNodes.length > 0 || matchingEdges.length > 0) {
        (_b3 = (_a3 = get(store)).ondelete) == null ? void 0 : _b3.call(_a3, { nodes: matchingNodes, edges: matchingEdges });
      }
      return { deletedNodes: matchingNodes, deletedEdges: matchingEdges };
    },
    screenToFlowPosition: (position, options = { snapToGrid: true }) => {
      if (!get(store).domNode) {
        return position;
      }
      const _snapGrid = options.snapToGrid ? get(store).snapGrid : false;
      const { x, y, zoom: zoom2 } = get(store).viewport;
      const { x: domX, y: domY } = get(store).domNode.getBoundingClientRect();
      const correctedPosition = { x: position.x - domX, y: position.y - domY };
      return pointToRendererPoint(correctedPosition, [x, y, zoom2], _snapGrid !== null, _snapGrid || [1, 1]);
    },
    /**
     *
     * @param position
     * @returns
     */
    flowToScreenPosition: (position) => {
      if (!get(store).domNode) {
        return position;
      }
      const { x, y, zoom: zoom2 } = get(store).viewport;
      const { x: domX, y: domY } = get(store).domNode.getBoundingClientRect();
      const rendererPosition = rendererPointToPoint(position, [x, y, zoom2]);
      return { x: rendererPosition.x + domX, y: rendererPosition.y + domY };
    },
    toObject: () => {
      return structuredClone({
        nodes: [...get(store).nodes],
        edges: [...get(store).edges],
        viewport: { ...get(store).viewport }
      });
    },
    updateNode,
    updateNodeData: (id2, dataUpdate, options) => {
      var _a3;
      const node = (_a3 = get(store).nodeLookup.get(id2)) == null ? void 0 : _a3.internals.userNode;
      if (!node) {
        return;
      }
      const nextData = typeof dataUpdate === "function" ? dataUpdate(node) : dataUpdate;
      updateNode(id2, (node2) => ({
        ...node2,
        data: (options == null ? void 0 : options.replace) ? nextData : { ...node2.data, ...nextData }
      }));
    },
    updateEdge,
    getNodesBounds: (nodes) => {
      return getNodesBounds(nodes, {
        nodeLookup: get(store).nodeLookup,
        nodeOrigin: get(store).nodeOrigin
      });
    },
    getHandleConnections: ({ type, id: id2, nodeId }) => {
      var _a3, _b3;
      return Array.from((_b3 = (_a3 = get(store).connectionLookup.get(`${nodeId}-${type}-${id2 != null ? id2 : null}`)) == null ? void 0 : _a3.values()) != null ? _b3 : []);
    }
  };
}
function getElements(lookup, ids) {
  var _a3;
  const result = [];
  for (const id2 of ids) {
    const item = lookup.get(id2);
    if (item) {
      const element2 = "internals" in item ? (_a3 = item.internals) == null ? void 0 : _a3.userNode : item;
      result.push(element2);
    }
  }
  return result;
}

// node_modules/@xyflow/svelte/dist/lib/components/KeyHandler/KeyHandler.svelte
function KeyHandler($$anchor, $$props) {
  push($$props, true);
  let store = prop($$props, "store", 15), selectionKey = prop($$props, "selectionKey", 3, "Shift"), multiSelectionKey = prop($$props, "multiSelectionKey", 19, () => isMacOs() ? "Meta" : "Control"), deleteKey = prop($$props, "deleteKey", 3, "Backspace"), panActivationKey = prop($$props, "panActivationKey", 3, " "), zoomActivationKey = prop($$props, "zoomActivationKey", 19, () => isMacOs() ? "Meta" : "Control");
  let { deleteElements } = useSvelteFlow();
  function isKeyObject(key3) {
    return key3 !== null && typeof key3 === "object";
  }
  function getModifier(key3) {
    return isKeyObject(key3) ? key3.modifier || [] : [];
  }
  function getKeyString(key3) {
    if (key3 === null || key3 === void 0) {
      return "";
    }
    return isKeyObject(key3) ? key3.key : key3;
  }
  function getShortcutTrigger(key3, callback) {
    const keys = Array.isArray(key3) ? key3 : [key3];
    return keys.map((_key) => {
      const keyString = getKeyString(_key);
      return {
        key: keyString,
        modifier: getModifier(_key),
        enabled: keyString !== null,
        callback
      };
    });
  }
  function resetKeysAndSelection() {
    store(store().selectionRect = null, true);
    store(store().selectionKeyPressed = false, true);
    store(store().multiselectionKeyPressed = false, true);
    store(store().deleteKeyPressed = false, true);
    store(store().panActivationKeyPressed = false, true);
    store(store().zoomActivationKeyPressed = false, true);
  }
  function handleDelete() {
    const selectedNodes = store().nodes.filter((node) => node.selected);
    const selectedEdges = store().edges.filter((edge) => edge.selected);
    deleteElements({ nodes: selectedNodes, edges: selectedEdges });
  }
  event("blur", $window, resetKeysAndSelection);
  event("contextmenu", $window, resetKeysAndSelection);
  action($window, ($$node, $$action_arg) => {
    var _a3;
    return (_a3 = shortcut) == null ? void 0 : _a3($$node, $$action_arg);
  }, () => ({
    trigger: getShortcutTrigger(selectionKey(), () => store(store().selectionKeyPressed = true, true)),
    type: "keydown"
  }));
  action($window, ($$node, $$action_arg) => {
    var _a3;
    return (_a3 = shortcut) == null ? void 0 : _a3($$node, $$action_arg);
  }, () => ({
    trigger: getShortcutTrigger(selectionKey(), () => store(store().selectionKeyPressed = false, true)),
    type: "keyup"
  }));
  action($window, ($$node, $$action_arg) => {
    var _a3;
    return (_a3 = shortcut) == null ? void 0 : _a3($$node, $$action_arg);
  }, () => ({
    trigger: getShortcutTrigger(multiSelectionKey(), () => {
      store(store().multiselectionKeyPressed = true, true);
    }),
    type: "keydown"
  }));
  action($window, ($$node, $$action_arg) => {
    var _a3;
    return (_a3 = shortcut) == null ? void 0 : _a3($$node, $$action_arg);
  }, () => ({
    trigger: getShortcutTrigger(multiSelectionKey(), () => store(store().multiselectionKeyPressed = false, true)),
    type: "keyup"
  }));
  action($window, ($$node, $$action_arg) => {
    var _a3;
    return (_a3 = shortcut) == null ? void 0 : _a3($$node, $$action_arg);
  }, () => ({
    trigger: getShortcutTrigger(deleteKey(), (detail) => {
      const isModifierKey = detail.originalEvent.ctrlKey || detail.originalEvent.metaKey || detail.originalEvent.shiftKey;
      if (!isModifierKey && !isInputDOMNode(detail.originalEvent)) {
        store(store().deleteKeyPressed = true, true);
        handleDelete();
      }
    }),
    type: "keydown"
  }));
  action($window, ($$node, $$action_arg) => {
    var _a3;
    return (_a3 = shortcut) == null ? void 0 : _a3($$node, $$action_arg);
  }, () => ({
    trigger: getShortcutTrigger(deleteKey(), () => store(store().deleteKeyPressed = false, true)),
    type: "keyup"
  }));
  action($window, ($$node, $$action_arg) => {
    var _a3;
    return (_a3 = shortcut) == null ? void 0 : _a3($$node, $$action_arg);
  }, () => ({
    trigger: getShortcutTrigger(panActivationKey(), () => store(store().panActivationKeyPressed = true, true)),
    type: "keydown"
  }));
  action($window, ($$node, $$action_arg) => {
    var _a3;
    return (_a3 = shortcut) == null ? void 0 : _a3($$node, $$action_arg);
  }, () => ({
    trigger: getShortcutTrigger(panActivationKey(), () => store(store().panActivationKeyPressed = false, true)),
    type: "keyup"
  }));
  action($window, ($$node, $$action_arg) => {
    var _a3;
    return (_a3 = shortcut) == null ? void 0 : _a3($$node, $$action_arg);
  }, () => ({
    trigger: getShortcutTrigger(zoomActivationKey(), () => store(store().zoomActivationKeyPressed = true, true)),
    type: "keydown"
  }));
  action($window, ($$node, $$action_arg) => {
    var _a3;
    return (_a3 = shortcut) == null ? void 0 : _a3($$node, $$action_arg);
  }, () => ({
    trigger: getShortcutTrigger(zoomActivationKey(), () => store(store().zoomActivationKeyPressed = false, true)),
    type: "keyup"
  }));
  pop();
}

// node_modules/@xyflow/svelte/dist/lib/components/ConnectionLine/ConnectionLine.svelte
var root_32 = from_svg(`<path fill="none" class="svelte-flow__connection-path"></path>`);
var root_18 = from_svg(`<svg class="svelte-flow__connectionline"><g><!></g></svg>`);
function ConnectionLine($$anchor, $$props) {
  push($$props, true);
  let path = user_derived(() => {
    if (!$$props.store.connection.inProgress) {
      return "";
    }
    const pathParams = {
      sourceX: $$props.store.connection.from.x,
      sourceY: $$props.store.connection.from.y,
      sourcePosition: $$props.store.connection.fromPosition,
      targetX: $$props.store.connection.to.x,
      targetY: $$props.store.connection.to.y,
      targetPosition: $$props.store.connection.toPosition
    };
    switch ($$props.type) {
      case ConnectionLineType.Bezier: {
        const [path2] = getBezierPath(pathParams);
        return path2;
      }
      case ConnectionLineType.Straight: {
        const [path2] = getStraightPath(pathParams);
        return path2;
      }
      case ConnectionLineType.Step:
      case ConnectionLineType.SmoothStep: {
        const [path2] = getSmoothStepPath({
          ...pathParams,
          borderRadius: $$props.type === ConnectionLineType.Step ? 0 : void 0
        });
        return path2;
      }
    }
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var svg = root_18();
      var g = child(svg);
      var node_1 = child(g);
      {
        var consequent = ($$anchor3) => {
          var fragment_1 = comment();
          var node_2 = first_child(fragment_1);
          component(node_2, () => $$props.LineComponent, ($$anchor4, LineComponent_1) => {
            LineComponent_1($$anchor4, {});
          });
          append($$anchor3, fragment_1);
        };
        var alternate = ($$anchor3) => {
          var path_1 = root_32();
          template_effect(() => {
            set_attribute2(path_1, "d", get(path));
            set_style(path_1, $$props.style);
          });
          append($$anchor3, path_1);
        };
        if_block(node_1, ($$render) => {
          if ($$props.LineComponent) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      reset(g);
      reset(svg);
      template_effect(
        ($0) => {
          set_attribute2(svg, "width", $$props.store.width);
          set_attribute2(svg, "height", $$props.store.height);
          set_style(svg, $$props.containerStyle);
          set_class(g, 0, $0);
        },
        [
          () => clsx2([
            "svelte-flow__connection",
            getConnectionStatus($$props.store.connection.isValid)
          ])
        ]
      );
      append($$anchor2, svg);
    };
    if_block(node, ($$render) => {
      if ($$props.store.connection.inProgress) $$render(consequent_1);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/@xyflow/svelte/dist/lib/container/Panel/Panel.svelte
var root16 = from_html(`<div><!></div>`);
function Panel($$anchor, $$props) {
  push($$props, true);
  let position = prop($$props, "position", 3, "top-right"), rest = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "position",
    "style",
    "class",
    "children"
  ]);
  let positionClasses = user_derived(() => `${position()}`.split("-"));
  var div = root16();
  attribute_effect(div, ($0) => ({ class: $0, style: $$props.style, ...rest }), [
    () => [
      "svelte-flow__panel",
      $$props.class,
      ...get(positionClasses)
    ]
  ]);
  var node = child(div);
  snippet(node, () => {
    var _a3;
    return (_a3 = $$props.children) != null ? _a3 : noop;
  });
  reset(div);
  append($$anchor, div);
  pop();
}

// node_modules/@xyflow/svelte/dist/lib/components/Attribution/Attribution.svelte
var root_2 = from_html(`<a href="https://svelteflow.dev" target="_blank" rel="noopener noreferrer" aria-label="Svelte Flow attribution">Svelte Flow</a>`);
function Attribution($$anchor, $$props) {
  push($$props, true);
  let position = prop($$props, "position", 3, "bottom-right");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      Panel($$anchor2, {
        get position() {
          return position();
        },
        class: "svelte-flow__attribution",
        "data-message": "Feel free to remove the attribution or check out how you could support us: https://svelteflow.dev/support-us",
        children: ($$anchor3, $$slotProps) => {
          var a = root_2();
          append($$anchor3, a);
        },
        $$slots: { default: true }
      });
    };
    if_block(node, ($$render) => {
      var _a3;
      if (!((_a3 = $$props.proOptions) == null ? void 0 : _a3.hideAttribution)) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/@xyflow/svelte/dist/lib/container/SvelteFlow/Wrapper.svelte
var root17 = from_html(`<div><!></div>`);
var $$css5 = {
  hash: "svelte-mkap6j",
  code: ".svelte-flow.svelte-mkap6j {width:100%;height:100%;overflow:hidden;position:relative;z-index:0;background-color:var(--background-color, var(--background-color-default));}:root {--background-color-default: #fff;--background-pattern-color-default: #ddd;--minimap-mask-color-default: rgb(240, 240, 240, 0.6);--minimap-mask-stroke-color-default: none;--minimap-mask-stroke-width-default: 1;--controls-button-background-color-default: #fefefe;--controls-button-background-color-hover-default: #f4f4f4;--controls-button-color-default: inherit;--controls-button-color-hover-default: inherit;--controls-button-border-color-default: #eee;}"
};
function Wrapper($$anchor, $$props) {
  push($$props, true);
  append_styles($$anchor, $$css5);
  let domNode = prop($$props, "domNode", 15), clientWidth = prop($$props, "clientWidth", 15), clientHeight = prop($$props, "clientHeight", 15);
  let id2 = user_derived(() => $$props.rest.id), className = user_derived(() => $$props.rest.class), nodeTypes = user_derived(() => $$props.rest.nodeTypes), edgeTypes = user_derived(() => $$props.rest.edgeTypes), _colorMode = user_derived(() => $$props.rest.colorMode), isValidConnection = user_derived(() => $$props.rest.isValidConnection), onmove = user_derived(() => $$props.rest.onmove), onmovestart = user_derived(() => $$props.rest.onmovestart), onmoveend = user_derived(() => $$props.rest.onmoveend), onflowerror = user_derived(() => $$props.rest.onflowerror), ondelete = user_derived(() => $$props.rest.ondelete), onbeforedelete = user_derived(() => $$props.rest.onbeforedelete), onbeforeconnect = user_derived(() => $$props.rest.onbeforeconnect), onconnect = user_derived(() => $$props.rest.onconnect), onconnectstart = user_derived(() => $$props.rest.onconnectstart), onconnectend = user_derived(() => $$props.rest.onconnectend), onbeforereconnect = user_derived(() => $$props.rest.onbeforereconnect), onreconnect = user_derived(() => $$props.rest.onreconnect), onreconnectstart = user_derived(() => $$props.rest.onreconnectstart), onreconnectend = user_derived(() => $$props.rest.onreconnectend), onclickconnectstart = user_derived(() => $$props.rest.onclickconnectstart), onclickconnectend = user_derived(() => $$props.rest.onclickconnectend), oninit = user_derived(() => $$props.rest.oninit), onselectionchange = user_derived(() => $$props.rest.onselectionchange), onselectiondragstart = user_derived(() => $$props.rest.onselectiondragstart), onselectiondrag = user_derived(() => $$props.rest.onselectiondrag), onselectiondragstop = user_derived(() => $$props.rest.onselectiondragstop), onselectionstart = user_derived(() => $$props.rest.onselectionstart), onselectionend = user_derived(() => $$props.rest.onselectionend), clickConnect = user_derived(() => $$props.rest.clickConnect), fitView = user_derived(() => $$props.rest.fitView), fitViewOptions = user_derived(() => $$props.rest.fitViewOptions), nodeOrigin = user_derived(() => $$props.rest.nodeOrigin), nodeDragThreshold = user_derived(() => $$props.rest.nodeDragThreshold), connectionDragThreshold = user_derived(() => $$props.rest.connectionDragThreshold), minZoom = user_derived(() => $$props.rest.minZoom), maxZoom = user_derived(() => $$props.rest.maxZoom), initialViewport = user_derived(() => $$props.rest.initialViewport), connectionRadius = user_derived(() => $$props.rest.connectionRadius), connectionMode = user_derived(() => $$props.rest.connectionMode), selectionMode = user_derived(() => $$props.rest.selectionMode), selectNodesOnDrag = user_derived(() => $$props.rest.selectNodesOnDrag), snapGrid = user_derived(() => $$props.rest.snapGrid), defaultMarkerColor = user_derived(() => $$props.rest.defaultMarkerColor), translateExtent = user_derived(() => $$props.rest.translateExtent), nodeExtent = user_derived(() => $$props.rest.nodeExtent), onlyRenderVisibleElements = user_derived(() => $$props.rest.onlyRenderVisibleElements), autoPanOnConnect = user_derived(() => $$props.rest.autoPanOnConnect), autoPanOnNodeDrag = user_derived(() => $$props.rest.autoPanOnNodeDrag), colorModeSSR = user_derived(() => $$props.rest.colorModeSSR), defaultEdgeOptions = user_derived(() => $$props.rest.defaultEdgeOptions), elevateNodesOnSelect = user_derived(() => $$props.rest.elevateNodesOnSelect), elevateEdgesOnSelect = user_derived(() => $$props.rest.elevateEdgesOnSelect), nodesDraggable = user_derived(() => $$props.rest.nodesDraggable), autoPanOnNodeFocus = user_derived(() => $$props.rest.autoPanOnNodeFocus), nodesConnectable = user_derived(() => $$props.rest.nodesConnectable), elementsSelectable = user_derived(() => $$props.rest.elementsSelectable), nodesFocusable = user_derived(() => $$props.rest.nodesFocusable), edgesFocusable = user_derived(() => $$props.rest.edgesFocusable), disableKeyboardA11y = user_derived(() => $$props.rest.disableKeyboardA11y), noDragClass = user_derived(() => $$props.rest.noDragClass), noPanClass = user_derived(() => $$props.rest.noPanClass), noWheelClass = user_derived(() => $$props.rest.noWheelClass), ariaLabelConfig = user_derived(() => $$props.rest.ariaLabelConfig), autoPanSpeed = user_derived(() => $$props.rest.autoPanSpeed), panOnScrollSpeed = user_derived(() => $$props.rest.panOnScrollSpeed), divAttributes = user_derived(() => exclude_from_object($$props.rest, [
    "id",
    "class",
    "nodeTypes",
    "edgeTypes",
    "colorMode",
    "isValidConnection",
    "onmove",
    "onmovestart",
    "onmoveend",
    "onflowerror",
    "ondelete",
    "onbeforedelete",
    "onbeforeconnect",
    "onconnect",
    "onconnectstart",
    "onconnectend",
    "onbeforereconnect",
    "onreconnect",
    "onreconnectstart",
    "onreconnectend",
    "onclickconnectstart",
    "onclickconnectend",
    "oninit",
    "onselectionchange",
    "onselectiondragstart",
    "onselectiondrag",
    "onselectiondragstop",
    "onselectionstart",
    "onselectionend",
    "clickConnect",
    "fitView",
    "fitViewOptions",
    "nodeOrigin",
    "nodeDragThreshold",
    "connectionDragThreshold",
    "minZoom",
    "maxZoom",
    "initialViewport",
    "connectionRadius",
    "connectionMode",
    "selectionMode",
    "selectNodesOnDrag",
    "snapGrid",
    "defaultMarkerColor",
    "translateExtent",
    "nodeExtent",
    "onlyRenderVisibleElements",
    "autoPanOnConnect",
    "autoPanOnNodeDrag",
    "colorModeSSR",
    "defaultEdgeOptions",
    "elevateNodesOnSelect",
    "elevateEdgesOnSelect",
    "nodesDraggable",
    "autoPanOnNodeFocus",
    "nodesConnectable",
    "elementsSelectable",
    "nodesFocusable",
    "edgesFocusable",
    "disableKeyboardA11y",
    "noDragClass",
    "noPanClass",
    "noWheelClass",
    "ariaLabelConfig",
    "autoPanSpeed",
    "panOnScrollSpeed"
  ]));
  function wrapperOnScroll(e) {
    e.currentTarget.scrollTo({ top: 0, left: 0, behavior: "auto" });
    if ($$props.rest.onscroll) {
      $$props.rest.onscroll(e);
    }
  }
  var div = root17();
  attribute_effect(
    div,
    ($0) => ({
      class: [
        "svelte-flow",
        "svelte-flow__container",
        get(className),
        $$props.colorMode
      ],
      "data-testid": "svelte-flow__wrapper",
      role: "application",
      onscroll: wrapperOnScroll,
      ...get(divAttributes),
      [STYLE]: $0
    }),
    [
      () => ({
        width: toPxString($$props.width),
        height: toPxString($$props.height)
      })
    ],
    void 0,
    "svelte-mkap6j"
  );
  var node = child(div);
  snippet(node, () => {
    var _a3;
    return (_a3 = $$props.children) != null ? _a3 : noop;
  });
  reset(div);
  bind_this(div, ($$value) => domNode($$value), () => domNode());
  bind_element_size(div, "clientHeight", clientHeight);
  bind_element_size(div, "clientWidth", clientWidth);
  append($$anchor, div);
  pop();
}

// node_modules/@xyflow/svelte/dist/lib/container/SvelteFlow/SvelteFlow.svelte
var root_4 = from_html(`<div class="svelte-flow__viewport-back svelte-flow__container"></div> <!> <div class="svelte-flow__edge-labels svelte-flow__container"></div> <!> <!> <!> <div class="svelte-flow__viewport-front svelte-flow__container"></div>`, 1);
var root_33 = from_html(`<!> <!>`, 1);
var root_19 = from_html(`<!> <!> <!> <!> <!>`, 1);
function SvelteFlow($$anchor, $$props) {
  push($$props, true);
  let paneClickDistance = prop($$props, "paneClickDistance", 3, 1), nodeClickDistance = prop($$props, "nodeClickDistance", 3, 1), panOnScrollMode = prop($$props, "panOnScrollMode", 19, () => PanOnScrollMode.Free), preventScrolling = prop($$props, "preventScrolling", 3, true), zoomOnScroll = prop($$props, "zoomOnScroll", 3, true), zoomOnDoubleClick = prop($$props, "zoomOnDoubleClick", 3, true), zoomOnPinch = prop($$props, "zoomOnPinch", 3, true), panOnScroll = prop($$props, "panOnScroll", 3, false), panOnScrollSpeed = prop($$props, "panOnScrollSpeed", 3, 0.5), panOnDrag = prop($$props, "panOnDrag", 3, true), selectionOnDrag = prop($$props, "selectionOnDrag", 3, true), connectionLineType = prop($$props, "connectionLineType", 19, () => ConnectionLineType.Bezier), nodes = prop($$props, "nodes", 31, () => proxy([])), edges = prop($$props, "edges", 31, () => proxy([])), viewport = prop($$props, "viewport", 15, void 0), props = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "width",
    "height",
    "proOptions",
    "selectionKey",
    "deleteKey",
    "panActivationKey",
    "multiSelectionKey",
    "zoomActivationKey",
    "paneClickDistance",
    "nodeClickDistance",
    "onmovestart",
    "onmoveend",
    "onmove",
    "oninit",
    "onnodeclick",
    "onnodecontextmenu",
    "onnodedrag",
    "onnodedragstart",
    "onnodedragstop",
    "onnodepointerenter",
    "onnodepointermove",
    "onnodepointerleave",
    "onselectionclick",
    "onselectioncontextmenu",
    "onselectionstart",
    "onselectionend",
    "onedgeclick",
    "onedgecontextmenu",
    "onedgepointerenter",
    "onedgepointerleave",
    "onpaneclick",
    "onpanecontextmenu",
    "panOnScrollMode",
    "preventScrolling",
    "zoomOnScroll",
    "zoomOnDoubleClick",
    "zoomOnPinch",
    "panOnScroll",
    "panOnScrollSpeed",
    "panOnDrag",
    "selectionOnDrag",
    "connectionLineComponent",
    "connectionLineStyle",
    "connectionLineContainerStyle",
    "connectionLineType",
    "attributionPosition",
    "children",
    "nodes",
    "edges",
    "viewport"
  ]);
  let store = createStore({
    props,
    width: $$props.width,
    height: $$props.height,
    get nodes() {
      return nodes();
    },
    set nodes(newNodes) {
      nodes(newNodes);
    },
    get edges() {
      return edges();
    },
    set edges(newEdges) {
      edges(newEdges);
    },
    get viewport() {
      return viewport();
    },
    set viewport(newViewport) {
      viewport(newViewport);
    }
  });
  const providerContext = getContext(key2);
  if (providerContext && providerContext.setStore) {
    providerContext.setStore(store);
  }
  setContext(key2, {
    provider: false,
    getStore() {
      return store;
    }
  });
  user_effect(() => {
    var _a3;
    const params = { nodes: store.selectedNodes, edges: store.selectedEdges };
    (_a3 = untrack(() => $$props.onselectionchange)) == null ? void 0 : _a3(params);
    for (const handler of store.selectionChangeHandlers.values()) {
      handler(params);
    }
  });
  onDestroy(() => {
    store.reset();
  });
  Wrapper($$anchor, {
    get colorMode() {
      return store.colorMode;
    },
    get width() {
      return $$props.width;
    },
    get height() {
      return $$props.height;
    },
    get rest() {
      return props;
    },
    get domNode() {
      return store.domNode;
    },
    set domNode($$value) {
      store.domNode = $$value;
    },
    get clientWidth() {
      return store.width;
    },
    set clientWidth($$value) {
      store.width = $$value;
    },
    get clientHeight() {
      return store.height;
    },
    set clientHeight($$value) {
      store.height = $$value;
    },
    children: ($$anchor2, $$slotProps) => {
      var fragment_1 = root_19();
      var node = first_child(fragment_1);
      KeyHandler(node, {
        get selectionKey() {
          return $$props.selectionKey;
        },
        get deleteKey() {
          return $$props.deleteKey;
        },
        get panActivationKey() {
          return $$props.panActivationKey;
        },
        get multiSelectionKey() {
          return $$props.multiSelectionKey;
        },
        get zoomActivationKey() {
          return $$props.zoomActivationKey;
        },
        get store() {
          return store;
        },
        set store($$value) {
          store = $$value;
        }
      });
      var node_1 = sibling(node, 2);
      Zoom(node_1, {
        get panOnScrollMode() {
          return panOnScrollMode();
        },
        get preventScrolling() {
          return preventScrolling();
        },
        get zoomOnScroll() {
          return zoomOnScroll();
        },
        get zoomOnDoubleClick() {
          return zoomOnDoubleClick();
        },
        get zoomOnPinch() {
          return zoomOnPinch();
        },
        get panOnScroll() {
          return panOnScroll();
        },
        get panOnScrollSpeed() {
          return panOnScrollSpeed();
        },
        get panOnDrag() {
          return panOnDrag();
        },
        get paneClickDistance() {
          return paneClickDistance();
        },
        get onmovestart() {
          return $$props.onmovestart;
        },
        get onmove() {
          return $$props.onmove;
        },
        get onmoveend() {
          return $$props.onmoveend;
        },
        get oninit() {
          return $$props.oninit;
        },
        get store() {
          return store;
        },
        set store($$value) {
          store = $$value;
        },
        children: ($$anchor3, $$slotProps2) => {
          Pane($$anchor3, {
            get onpaneclick() {
              return $$props.onpaneclick;
            },
            get onpanecontextmenu() {
              return $$props.onpanecontextmenu;
            },
            get onselectionstart() {
              return $$props.onselectionstart;
            },
            get onselectionend() {
              return $$props.onselectionend;
            },
            get panOnDrag() {
              return panOnDrag();
            },
            get selectionOnDrag() {
              return selectionOnDrag();
            },
            get store() {
              return store;
            },
            set store($$value) {
              store = $$value;
            },
            children: ($$anchor4, $$slotProps3) => {
              var fragment_3 = root_33();
              var node_2 = first_child(fragment_3);
              Viewport(node_2, {
                get store() {
                  return store;
                },
                set store($$value) {
                  store = $$value;
                },
                children: ($$anchor5, $$slotProps4) => {
                  var fragment_4 = root_4();
                  var node_3 = sibling(first_child(fragment_4), 2);
                  EdgeRenderer(node_3, {
                    get onedgeclick() {
                      return $$props.onedgeclick;
                    },
                    get onedgecontextmenu() {
                      return $$props.onedgecontextmenu;
                    },
                    get onedgepointerenter() {
                      return $$props.onedgepointerenter;
                    },
                    get onedgepointerleave() {
                      return $$props.onedgepointerleave;
                    },
                    get store() {
                      return store;
                    },
                    set store($$value) {
                      store = $$value;
                    }
                  });
                  var node_4 = sibling(node_3, 4);
                  ConnectionLine(node_4, {
                    get type() {
                      return connectionLineType();
                    },
                    get LineComponent() {
                      return $$props.connectionLineComponent;
                    },
                    get containerStyle() {
                      return $$props.connectionLineContainerStyle;
                    },
                    get style() {
                      return $$props.connectionLineStyle;
                    },
                    get store() {
                      return store;
                    },
                    set store($$value) {
                      store = $$value;
                    }
                  });
                  var node_5 = sibling(node_4, 2);
                  NodeRenderer(node_5, {
                    get nodeClickDistance() {
                      return nodeClickDistance();
                    },
                    get onnodeclick() {
                      return $$props.onnodeclick;
                    },
                    get onnodecontextmenu() {
                      return $$props.onnodecontextmenu;
                    },
                    get onnodepointerenter() {
                      return $$props.onnodepointerenter;
                    },
                    get onnodepointermove() {
                      return $$props.onnodepointermove;
                    },
                    get onnodepointerleave() {
                      return $$props.onnodepointerleave;
                    },
                    get onnodedrag() {
                      return $$props.onnodedrag;
                    },
                    get onnodedragstart() {
                      return $$props.onnodedragstart;
                    },
                    get onnodedragstop() {
                      return $$props.onnodedragstop;
                    },
                    get store() {
                      return store;
                    },
                    set store($$value) {
                      store = $$value;
                    }
                  });
                  var node_6 = sibling(node_5, 2);
                  NodeSelection(node_6, {
                    get onselectionclick() {
                      return $$props.onselectionclick;
                    },
                    get onselectioncontextmenu() {
                      return $$props.onselectioncontextmenu;
                    },
                    get onnodedrag() {
                      return $$props.onnodedrag;
                    },
                    get onnodedragstart() {
                      return $$props.onnodedragstart;
                    },
                    get onnodedragstop() {
                      return $$props.onnodedragstop;
                    },
                    get store() {
                      return store;
                    },
                    set store($$value) {
                      store = $$value;
                    }
                  });
                  next(2);
                  append($$anchor5, fragment_4);
                },
                $$slots: { default: true }
              });
              var node_7 = sibling(node_2, 2);
              {
                let $0 = user_derived(() => !!(store.selectionRect && store.selectionRectMode === "user"));
                let $1 = user_derived(() => {
                  var _a3;
                  return (_a3 = store.selectionRect) == null ? void 0 : _a3.width;
                });
                let $2 = user_derived(() => {
                  var _a3;
                  return (_a3 = store.selectionRect) == null ? void 0 : _a3.height;
                });
                let $3 = user_derived(() => {
                  var _a3;
                  return (_a3 = store.selectionRect) == null ? void 0 : _a3.x;
                });
                let $4 = user_derived(() => {
                  var _a3;
                  return (_a3 = store.selectionRect) == null ? void 0 : _a3.y;
                });
                Selection3(node_7, {
                  get isVisible() {
                    return get($0);
                  },
                  get width() {
                    return get($1);
                  },
                  get height() {
                    return get($2);
                  },
                  get x() {
                    return get($3);
                  },
                  get y() {
                    return get($4);
                  }
                });
              }
              append($$anchor4, fragment_3);
            },
            $$slots: { default: true }
          });
        },
        $$slots: { default: true }
      });
      var node_8 = sibling(node_1, 2);
      Attribution(node_8, {
        get proOptions() {
          return $$props.proOptions;
        },
        get position() {
          return $$props.attributionPosition;
        }
      });
      var node_9 = sibling(node_8, 2);
      A11yDescriptions(node_9, {
        get store() {
          return store;
        }
      });
      var node_10 = sibling(node_9, 2);
      snippet(node_10, () => {
        var _a3;
        return (_a3 = $$props.children) != null ? _a3 : noop;
      });
      append($$anchor2, fragment_1);
    },
    $$slots: { default: true }
  });
  pop();
}

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/ControlButton.svelte
var root18 = from_html(`<button><!></button>`);
function ControlButton($$anchor, $$props) {
  let restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "class",
    "bgColor",
    "bgColorHover",
    "color",
    "colorHover",
    "borderColor",
    "onclick",
    "children"
  ]);
  var button = root18();
  attribute_effect(
    button,
    ($0) => ({
      type: "button",
      onclick: $$props.onclick,
      class: ["svelte-flow__controls-button", $$props.class],
      ...restProps,
      [STYLE]: $0
    }),
    [
      () => ({
        "--xy-controls-button-background-color-props": $$props.bgColor,
        "--xy-controls-button-background-color-hover-props": $$props.bgColorHover,
        "--xy-controls-button-color-props": $$props.color,
        "--xy-controls-button-color-hover-props": $$props.colorHover,
        "--xy-controls-button-border-color-props": $$props.borderColor
      })
    ]
  );
  var node = child(button);
  snippet(node, () => {
    var _a3;
    return (_a3 = $$props.children) != null ? _a3 : noop;
  });
  reset(button);
  append($$anchor, button);
}

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Plus.svelte
var root19 = from_svg(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z"></path></svg>`);
function Plus($$anchor) {
  var svg = root19();
  append($$anchor, svg);
}

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Minus.svelte
var root20 = from_svg(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 5"><path d="M0 0h32v4.2H0z"></path></svg>`);
function Minus($$anchor) {
  var svg = root20();
  append($$anchor, svg);
}

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Fit.svelte
var root21 = from_svg(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 30"><path d="M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z"></path></svg>`);
function Fit($$anchor) {
  var svg = root21();
  append($$anchor, svg);
}

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Lock.svelte
var root22 = from_svg(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 25 32"><path d="M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z"></path></svg>`);
function Lock($$anchor) {
  var svg = root22();
  append($$anchor, svg);
}

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Unlock.svelte
var root23 = from_svg(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 25 32"><path d="M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z"></path></svg>`);
function Unlock($$anchor) {
  var svg = root23();
  append($$anchor, svg);
}

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Controls.svelte
var root_34 = from_html(`<!> <!>`, 1);
var root_110 = from_html(`<!> <!> <!> <!> <!> <!>`, 1);
function Controls($$anchor, $$props) {
  push($$props, true);
  let position = prop($$props, "position", 3, "bottom-left"), orientation = prop($$props, "orientation", 3, "vertical"), showZoom = prop($$props, "showZoom", 3, true), showFitView = prop($$props, "showFitView", 3, true), showLock = prop($$props, "showLock", 3, true), rest = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "position",
    "orientation",
    "showZoom",
    "showFitView",
    "showLock",
    "style",
    "class",
    "buttonBgColor",
    "buttonBgColorHover",
    "buttonColor",
    "buttonColorHover",
    "buttonBorderColor",
    "fitViewOptions",
    "children",
    "before",
    "after"
  ]);
  let store = user_derived(useStore);
  const buttonProps = {
    bgColor: $$props.buttonBgColor,
    bgColorHover: $$props.buttonBgColorHover,
    color: $$props.buttonColor,
    colorHover: $$props.buttonColorHover,
    borderColor: $$props.buttonBorderColor
  };
  let isInteractive = user_derived(() => get(store).nodesDraggable || get(store).nodesConnectable || get(store).elementsSelectable);
  let minZoomReached = user_derived(() => get(store).viewport.zoom <= get(store).minZoom);
  let maxZoomReached = user_derived(() => get(store).viewport.zoom >= get(store).maxZoom);
  let ariaLabelConfig = user_derived(() => get(store).ariaLabelConfig);
  let orientationClass = user_derived(() => orientation() === "horizontal" ? "horizontal" : "vertical");
  const onZoomInHandler = () => {
    get(store).zoomIn();
  };
  const onZoomOutHandler = () => {
    get(store).zoomOut();
  };
  const onFitViewHandler = () => {
    get(store).fitView($$props.fitViewOptions);
  };
  const onToggleInteractivity = () => {
    let interactive2 = !get(isInteractive);
    get(store).nodesDraggable = interactive2;
    get(store).nodesConnectable = interactive2;
    get(store).elementsSelectable = interactive2;
  };
  {
    let $0 = user_derived(() => [
      "svelte-flow__controls",
      get(orientationClass),
      $$props.class
    ]);
    Panel($$anchor, spread_props(
      {
        get class() {
          return get($0);
        },
        get position() {
          return position();
        },
        "data-testid": "svelte-flow__controls",
        get "aria-label"() {
          return get(ariaLabelConfig)["controls.ariaLabel"];
        },
        get style() {
          return $$props.style;
        }
      },
      () => rest,
      {
        children: ($$anchor2, $$slotProps) => {
          var fragment_1 = root_110();
          var node = first_child(fragment_1);
          {
            var consequent = ($$anchor3) => {
              var fragment_2 = comment();
              var node_1 = first_child(fragment_2);
              snippet(node_1, () => $$props.before);
              append($$anchor3, fragment_2);
            };
            if_block(node, ($$render) => {
              if ($$props.before) $$render(consequent);
            });
          }
          var node_2 = sibling(node, 2);
          {
            var consequent_1 = ($$anchor3) => {
              var fragment_3 = root_34();
              var node_3 = first_child(fragment_3);
              ControlButton(node_3, spread_props(
                {
                  onclick: onZoomInHandler,
                  class: "svelte-flow__controls-zoomin",
                  get title() {
                    return get(ariaLabelConfig)["controls.zoomIn.ariaLabel"];
                  },
                  get "aria-label"() {
                    return get(ariaLabelConfig)["controls.zoomIn.ariaLabel"];
                  },
                  get disabled() {
                    return get(maxZoomReached);
                  }
                },
                () => buttonProps,
                {
                  children: ($$anchor4, $$slotProps2) => {
                    Plus($$anchor4, {});
                  },
                  $$slots: { default: true }
                }
              ));
              var node_4 = sibling(node_3, 2);
              ControlButton(node_4, spread_props(
                {
                  onclick: onZoomOutHandler,
                  class: "svelte-flow__controls-zoomout",
                  get title() {
                    return get(ariaLabelConfig)["controls.zoomOut.ariaLabel"];
                  },
                  get "aria-label"() {
                    return get(ariaLabelConfig)["controls.zoomOut.ariaLabel"];
                  },
                  get disabled() {
                    return get(minZoomReached);
                  }
                },
                () => buttonProps,
                {
                  children: ($$anchor4, $$slotProps2) => {
                    Minus($$anchor4, {});
                  },
                  $$slots: { default: true }
                }
              ));
              append($$anchor3, fragment_3);
            };
            if_block(node_2, ($$render) => {
              if (showZoom()) $$render(consequent_1);
            });
          }
          var node_5 = sibling(node_2, 2);
          {
            var consequent_2 = ($$anchor3) => {
              ControlButton($$anchor3, spread_props(
                {
                  class: "svelte-flow__controls-fitview",
                  onclick: onFitViewHandler,
                  get title() {
                    return get(ariaLabelConfig)["controls.fitView.ariaLabel"];
                  },
                  get "aria-label"() {
                    return get(ariaLabelConfig)["controls.fitView.ariaLabel"];
                  }
                },
                () => buttonProps,
                {
                  children: ($$anchor4, $$slotProps2) => {
                    Fit($$anchor4, {});
                  },
                  $$slots: { default: true }
                }
              ));
            };
            if_block(node_5, ($$render) => {
              if (showFitView()) $$render(consequent_2);
            });
          }
          var node_6 = sibling(node_5, 2);
          {
            var consequent_4 = ($$anchor3) => {
              ControlButton($$anchor3, spread_props(
                {
                  class: "svelte-flow__controls-interactive",
                  onclick: onToggleInteractivity,
                  get title() {
                    return get(ariaLabelConfig)["controls.interactive.ariaLabel"];
                  },
                  get "aria-label"() {
                    return get(ariaLabelConfig)["controls.interactive.ariaLabel"];
                  }
                },
                () => buttonProps,
                {
                  children: ($$anchor4, $$slotProps2) => {
                    var fragment_9 = comment();
                    var node_7 = first_child(fragment_9);
                    {
                      var consequent_3 = ($$anchor5) => {
                        Unlock($$anchor5, {});
                      };
                      var alternate = ($$anchor5) => {
                        Lock($$anchor5, {});
                      };
                      if_block(node_7, ($$render) => {
                        if (get(isInteractive)) $$render(consequent_3);
                        else $$render(alternate, false);
                      });
                    }
                    append($$anchor4, fragment_9);
                  },
                  $$slots: { default: true }
                }
              ));
            };
            if_block(node_6, ($$render) => {
              if (showLock()) $$render(consequent_4);
            });
          }
          var node_8 = sibling(node_6, 2);
          {
            var consequent_5 = ($$anchor3) => {
              var fragment_12 = comment();
              var node_9 = first_child(fragment_12);
              snippet(node_9, () => $$props.children);
              append($$anchor3, fragment_12);
            };
            if_block(node_8, ($$render) => {
              if ($$props.children) $$render(consequent_5);
            });
          }
          var node_10 = sibling(node_8, 2);
          {
            var consequent_6 = ($$anchor3) => {
              var fragment_13 = comment();
              var node_11 = first_child(fragment_13);
              snippet(node_11, () => $$props.after);
              append($$anchor3, fragment_13);
            };
            if_block(node_10, ($$render) => {
              if ($$props.after) $$render(consequent_6);
            });
          }
          append($$anchor2, fragment_1);
        },
        $$slots: { default: true }
      }
    ));
  }
  pop();
}

// node_modules/@xyflow/svelte/dist/lib/plugins/Background/types.js
var BackgroundVariant;
(function(BackgroundVariant2) {
  BackgroundVariant2["Lines"] = "lines";
  BackgroundVariant2["Dots"] = "dots";
  BackgroundVariant2["Cross"] = "cross";
})(BackgroundVariant || (BackgroundVariant = {}));

// node_modules/@xyflow/svelte/dist/lib/plugins/Background/DotPattern.svelte
var root24 = from_svg(`<circle></circle>`);
function DotPattern($$anchor, $$props) {
  var circle = root24();
  template_effect(() => {
    set_attribute2(circle, "cx", $$props.radius);
    set_attribute2(circle, "cy", $$props.radius);
    set_attribute2(circle, "r", $$props.radius);
    set_class(circle, 0, clsx2(["svelte-flow__background-pattern", "dots", $$props.class]));
  });
  append($$anchor, circle);
}

// node_modules/@xyflow/svelte/dist/lib/plugins/Background/LinePattern.svelte
var root25 = from_svg(`<path></path>`);
function LinePattern($$anchor, $$props) {
  push($$props, true);
  var path = root25();
  template_effect(() => {
    set_attribute2(path, "stroke-width", $$props.lineWidth);
    set_attribute2(path, "d", `M${$$props.dimensions[0] / 2} 0 V${$$props.dimensions[1]} M0 ${$$props.dimensions[1] / 2} H${$$props.dimensions[0]}`);
    set_class(path, 0, clsx2([
      "svelte-flow__background-pattern",
      $$props.variant,
      $$props.class
    ]));
  });
  append($$anchor, path);
  pop();
}

// node_modules/@xyflow/svelte/dist/lib/plugins/Background/Background.svelte
var defaultSize = {
  [BackgroundVariant.Dots]: 1,
  [BackgroundVariant.Lines]: 1,
  [BackgroundVariant.Cross]: 6
};
var root26 = from_svg(`<svg data-testid="svelte-flow__background"><pattern patternUnits="userSpaceOnUse"><!></pattern><rect x="0" y="0" width="100%" height="100%"></rect></svg>`);
function Background($$anchor, $$props) {
  push($$props, true);
  let variant = prop($$props, "variant", 19, () => BackgroundVariant.Dots), gap = prop($$props, "gap", 3, 20), lineWidth = prop($$props, "lineWidth", 3, 1);
  let store = user_derived(useStore);
  let isDots = user_derived(() => variant() === BackgroundVariant.Dots);
  let isCross = user_derived(() => variant() === BackgroundVariant.Cross);
  let gapXY = user_derived(() => Array.isArray(gap()) ? gap() : [gap(), gap()]);
  let patternId = user_derived(() => {
    var _a3;
    return `background-pattern-${get(store).flowId}-${(_a3 = $$props.id) != null ? _a3 : ""}`;
  });
  let scaledGap = user_derived(() => [
    get(gapXY)[0] * get(store).viewport.zoom || 1,
    get(gapXY)[1] * get(store).viewport.zoom || 1
  ]);
  let scaledSize = user_derived(() => {
    var _a3;
    return ((_a3 = $$props.size) != null ? _a3 : defaultSize[variant()]) * get(store).viewport.zoom;
  });
  let patternDimensions = user_derived(() => get(isCross) ? [get(scaledSize), get(scaledSize)] : get(scaledGap));
  let patternOffset = user_derived(() => get(isDots) ? [get(scaledSize) / 2, get(scaledSize) / 2] : [
    get(patternDimensions)[0] / 2,
    get(patternDimensions)[1] / 2
  ]);
  var svg = root26();
  let styles;
  var pattern = child(svg);
  var node = child(pattern);
  {
    var consequent = ($$anchor2) => {
      {
        let $0 = user_derived(() => get(scaledSize) / 2);
        DotPattern($$anchor2, {
          get radius() {
            return get($0);
          },
          get class() {
            return $$props.patternClass;
          }
        });
      }
    };
    var alternate = ($$anchor2) => {
      LinePattern($$anchor2, {
        get dimensions() {
          return get(patternDimensions);
        },
        get variant() {
          return variant();
        },
        get lineWidth() {
          return lineWidth();
        },
        get class() {
          return $$props.patternClass;
        }
      });
    };
    if_block(node, ($$render) => {
      if (get(isDots)) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  reset(pattern);
  var rect = sibling(pattern);
  reset(svg);
  template_effect(
    ($0) => {
      set_class(svg, 0, clsx2([
        "svelte-flow__background",
        "svelte-flow__container",
        $$props.class
      ]));
      styles = set_style(svg, "", styles, $0);
      set_attribute2(pattern, "id", get(patternId));
      set_attribute2(pattern, "x", get(store).viewport.x % get(scaledGap)[0]);
      set_attribute2(pattern, "y", get(store).viewport.y % get(scaledGap)[1]);
      set_attribute2(pattern, "width", get(scaledGap)[0]);
      set_attribute2(pattern, "height", get(scaledGap)[1]);
      set_attribute2(pattern, "patternTransform", `translate(-${get(patternOffset)[0]},-${get(patternOffset)[1]})`);
      set_attribute2(rect, "fill", `url(#${get(patternId)})`);
    },
    [
      () => ({
        "--xy-background-color-props": $$props.bgColor,
        "--xy-background-pattern-color-props": $$props.patternColor
      })
    ]
  );
  append($$anchor, svg);
  pop();
}

// node_modules/@xyflow/svelte/dist/lib/plugins/Minimap/MinimapNode.svelte
var root_22 = from_svg(`<rect></rect>`);
function MinimapNode($$anchor, $$props) {
  let borderRadius = prop($$props, "borderRadius", 3, 5), strokeWidth = prop($$props, "strokeWidth", 3, 2);
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      const CustomComponent = user_derived(() => $$props.nodeComponent);
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      component(node_1, () => get(CustomComponent), ($$anchor3, CustomComponent_1) => {
        CustomComponent_1($$anchor3, {
          get x() {
            return $$props.x;
          },
          get y() {
            return $$props.y;
          },
          get width() {
            return $$props.width;
          },
          get height() {
            return $$props.height;
          },
          get borderRadius() {
            return borderRadius();
          },
          get class() {
            return $$props.class;
          },
          get color() {
            return $$props.color;
          },
          get shapeRendering() {
            return $$props.shapeRendering;
          },
          get strokeColor() {
            return $$props.strokeColor;
          },
          get strokeWidth() {
            return strokeWidth();
          },
          get selected() {
            return $$props.selected;
          }
        });
      });
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var rect = root_22();
      let classes;
      let styles;
      template_effect(
        ($0, $1) => {
          classes = set_class(rect, 0, clsx2(["svelte-flow__minimap-node", $$props.class]), null, classes, $0);
          set_attribute2(rect, "x", $$props.x);
          set_attribute2(rect, "y", $$props.y);
          set_attribute2(rect, "rx", borderRadius());
          set_attribute2(rect, "ry", borderRadius());
          set_attribute2(rect, "width", $$props.width);
          set_attribute2(rect, "height", $$props.height);
          set_attribute2(rect, "shape-rendering", $$props.shapeRendering);
          styles = set_style(rect, "", styles, $1);
        },
        [
          () => ({ selected: $$props.selected }),
          () => ({
            fill: $$props.color,
            stroke: $$props.strokeColor,
            "stroke-width": strokeWidth()
          })
        ]
      );
      append($$anchor2, rect);
    };
    if_block(node, ($$render) => {
      if ($$props.nodeComponent) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
}

// node_modules/@xyflow/svelte/dist/lib/plugins/Minimap/interactive.js
function interactive(domNode, params) {
  const minimap = XYMinimap({
    domNode,
    panZoom: params.panZoom,
    getTransform: () => {
      const { viewport } = params.store;
      return [viewport.x, viewport.y, viewport.zoom];
    },
    getViewScale: params.getViewScale
  });
  minimap.update({
    translateExtent: params.translateExtent,
    width: params.width,
    height: params.height,
    inversePan: params.inversePan,
    zoomStep: params.zoomStep,
    pannable: params.pannable,
    zoomable: params.zoomable
  });
  function update2(params2) {
    minimap.update({
      translateExtent: params2.translateExtent,
      width: params2.width,
      height: params2.height,
      inversePan: params2.inversePan,
      zoomStep: params2.zoomStep,
      pannable: params2.pannable,
      zoomable: params2.zoomable
    });
  }
  return {
    update: update2,
    destroy() {
      minimap.destroy();
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/plugins/Minimap/Minimap.svelte
var getAttrFunction = (func) => func instanceof Function ? func : () => func;
var root_35 = from_svg(`<title> </title>`);
var root_23 = from_svg(`<svg class="svelte-flow__minimap-svg" role="img"><!><!><path class="svelte-flow__minimap-mask" fill-rule="evenodd" pointer-events="none"></path></svg>`);
var root27 = from_html(`<svelte-css-wrapper style="display: contents"><!></svelte-css-wrapper>`, 1);
function Minimap($$anchor, $$props) {
  push($$props, true);
  let position = prop($$props, "position", 3, "bottom-right"), nodeStrokeColor = prop($$props, "nodeStrokeColor", 3, "transparent"), nodeClass = prop($$props, "nodeClass", 3, ""), nodeBorderRadius = prop($$props, "nodeBorderRadius", 3, 5), nodeStrokeWidth = prop($$props, "nodeStrokeWidth", 3, 2), width = prop($$props, "width", 3, 200), height = prop($$props, "height", 3, 150), pannable = prop($$props, "pannable", 3, true), zoomable = prop($$props, "zoomable", 3, true), rest = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "position",
    "ariaLabel",
    "nodeStrokeColor",
    "nodeColor",
    "nodeClass",
    "nodeBorderRadius",
    "nodeStrokeWidth",
    "nodeComponent",
    "bgColor",
    "maskColor",
    "maskStrokeColor",
    "maskStrokeWidth",
    "width",
    "height",
    "pannable",
    "zoomable",
    "inversePan",
    "zoomStep",
    "class"
  ]);
  let store = user_derived(useStore);
  let ariaLabelConfig = user_derived(() => get(store).ariaLabelConfig);
  const nodeColorFunc = $$props.nodeColor === void 0 ? void 0 : getAttrFunction($$props.nodeColor);
  const nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor());
  const nodeClassFunc = getAttrFunction(nodeClass());
  const shapeRendering = (
    // @ts-expect-error - TS doesn't know about chrome
    typeof window === "undefined" || !!window.chrome ? "crispEdges" : "geometricPrecision"
  );
  let labelledBy = user_derived(() => `svelte-flow__minimap-desc-${get(store).flowId}`);
  let viewBB = user_derived(() => ({
    x: -get(store).viewport.x / get(store).viewport.zoom,
    y: -get(store).viewport.y / get(store).viewport.zoom,
    width: get(store).width / get(store).viewport.zoom,
    height: get(store).height / get(store).viewport.zoom
  }));
  let boundingRect = user_derived(() => get(store).nodeLookup.size > 0 ? getBoundsOfRects(getInternalNodesBounds(get(store).nodeLookup, { filter: (n) => !n.hidden }), get(viewBB)) : get(viewBB));
  let scaledWidth = user_derived(() => get(boundingRect).width / width());
  let scaledHeight = user_derived(() => get(boundingRect).height / height());
  let viewScale = user_derived(() => Math.max(get(scaledWidth), get(scaledHeight)));
  let viewWidth = user_derived(() => get(viewScale) * width());
  let viewHeight = user_derived(() => get(viewScale) * height());
  let offset = user_derived(() => 5 * get(viewScale));
  let x = user_derived(() => get(boundingRect).x - (get(viewWidth) - get(boundingRect).width) / 2 - get(offset));
  let y = user_derived(() => get(boundingRect).y - (get(viewHeight) - get(boundingRect).height) / 2 - get(offset));
  let viewboxWidth = user_derived(() => get(viewWidth) + get(offset) * 2);
  let viewboxHeight = user_derived(() => get(viewHeight) + get(offset) * 2);
  const getViewScale = () => get(viewScale);
  var fragment = root27();
  var node_1 = first_child(fragment);
  {
    let $0 = user_derived(() => ["svelte-flow__minimap", $$props.class]);
    css_props(node_1, () => ({ "--xy-minimap-background-color-props": $$props.bgColor }));
    Panel(node_1.lastChild, spread_props(
      {
        get position() {
          return position();
        },
        get class() {
          return get($0);
        },
        "data-testid": "svelte-flow__minimap"
      },
      () => rest,
      {
        children: ($$anchor2, $$slotProps) => {
          var fragment_1 = comment();
          var node_2 = first_child(fragment_1);
          {
            var consequent_2 = ($$anchor3) => {
              var svg = root_23();
              let styles;
              var node_3 = child(svg);
              {
                var consequent = ($$anchor4) => {
                  var title = root_35();
                  var text2 = child(title, true);
                  reset(title);
                  template_effect(() => {
                    var _a3;
                    set_attribute2(title, "id", get(labelledBy));
                    set_text(text2, (_a3 = $$props.ariaLabel) != null ? _a3 : get(ariaLabelConfig)["minimap.ariaLabel"]);
                  });
                  append($$anchor4, title);
                };
                if_block(node_3, ($$render) => {
                  var _a3;
                  if ((_a3 = $$props.ariaLabel) != null ? _a3 : get(ariaLabelConfig)["minimap.ariaLabel"]) $$render(consequent);
                });
              }
              var node_4 = sibling(node_3);
              each(node_4, 17, () => get(store).nodes, (userNode) => userNode.id, ($$anchor4, userNode) => {
                const node = user_derived(() => get(store).nodeLookup.get(get(userNode).id));
                var fragment_2 = comment();
                var node_5 = first_child(fragment_2);
                {
                  var consequent_1 = ($$anchor5) => {
                    const nodeDimesions = user_derived(() => getNodeDimensions(get(node)));
                    {
                      let $02 = user_derived(() => nodeColorFunc == null ? void 0 : nodeColorFunc(get(node)));
                      let $1 = user_derived(() => nodeStrokeColorFunc(get(node)));
                      let $2 = user_derived(() => nodeClassFunc(get(node)));
                      MinimapNode($$anchor5, spread_props(
                        {
                          get x() {
                            return get(node).internals.positionAbsolute.x;
                          },
                          get y() {
                            return get(node).internals.positionAbsolute.y;
                          }
                        },
                        () => get(nodeDimesions),
                        {
                          get selected() {
                            return get(node).selected;
                          },
                          get nodeComponent() {
                            return $$props.nodeComponent;
                          },
                          get color() {
                            return get($02);
                          },
                          get borderRadius() {
                            return nodeBorderRadius();
                          },
                          get strokeColor() {
                            return get($1);
                          },
                          get strokeWidth() {
                            return nodeStrokeWidth();
                          },
                          get shapeRendering() {
                            return shapeRendering;
                          },
                          get class() {
                            return get($2);
                          }
                        }
                      ));
                    }
                  };
                  if_block(node_5, ($$render) => {
                    if (get(node) && nodeHasDimensions(get(node))) $$render(consequent_1);
                  });
                }
                append($$anchor4, fragment_2);
              });
              var path = sibling(node_4);
              reset(svg);
              action(svg, ($$node, $$action_arg) => {
                var _a3;
                return (_a3 = interactive) == null ? void 0 : _a3($$node, $$action_arg);
              }, () => ({
                store: get(store),
                panZoom: get(store).panZoom,
                getViewScale,
                translateExtent: get(store).translateExtent,
                width: get(store).width,
                height: get(store).height,
                inversePan: $$props.inversePan,
                zoomStep: $$props.zoomStep,
                pannable: pannable(),
                zoomable: zoomable()
              }));
              template_effect(
                ($02) => {
                  var _a3, _b3, _c2, _d, _e, _f, _g, _h;
                  set_attribute2(svg, "width", width());
                  set_attribute2(svg, "height", height());
                  set_attribute2(svg, "viewBox", `${(_a3 = get(x)) != null ? _a3 : ""} ${(_b3 = get(y)) != null ? _b3 : ""} ${(_c2 = get(viewboxWidth)) != null ? _c2 : ""} ${(_d = get(viewboxHeight)) != null ? _d : ""}`);
                  set_attribute2(svg, "aria-labelledby", get(labelledBy));
                  styles = set_style(svg, "", styles, $02);
                  set_attribute2(path, "d", `M${get(x) - get(offset)},${get(y) - get(offset)}h${get(viewboxWidth) + get(offset) * 2}v${get(viewboxHeight) + get(offset) * 2}h${-get(viewboxWidth) - get(offset) * 2}z
      M${(_e = get(viewBB).x) != null ? _e : ""},${(_f = get(viewBB).y) != null ? _f : ""}h${(_g = get(viewBB).width) != null ? _g : ""}v${(_h = get(viewBB).height) != null ? _h : ""}h${-get(viewBB).width}z`);
                },
                [
                  () => ({
                    "--xy-minimap-mask-background-color-props": $$props.maskColor,
                    "--xy-minimap-mask-stroke-color-props": $$props.maskStrokeColor,
                    "--xy-minimap-mask-stroke-width-props": $$props.maskStrokeWidth ? $$props.maskStrokeWidth * get(viewScale) : void 0
                  })
                ]
              );
              append($$anchor3, svg);
            };
            if_block(node_2, ($$render) => {
              if (get(store).panZoom) $$render(consequent_2);
            });
          }
          append($$anchor2, fragment_1);
        },
        $$slots: { default: true }
      }
    ));
    reset(node_1);
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/@xyflow/svelte/dist/lib/plugins/NodeResizer/ResizeControl.svelte
var root28 = from_html(`<div><!></div>`);
function ResizeControl($$anchor, $$props) {
  push($$props, true);
  let variant = prop($$props, "variant", 19, () => ResizeControlVariant.Handle), minWidth = prop($$props, "minWidth", 3, 10), minHeight = prop($$props, "minHeight", 3, 10), maxWidth = prop($$props, "maxWidth", 19, () => Number.MAX_VALUE), maxHeight = prop($$props, "maxHeight", 19, () => Number.MAX_VALUE), keepAspectRatio = prop($$props, "keepAspectRatio", 3, false), autoScale = prop($$props, "autoScale", 3, true), rest = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "nodeId",
    "position",
    "variant",
    "color",
    "minWidth",
    "minHeight",
    "maxWidth",
    "maxHeight",
    "keepAspectRatio",
    "autoScale",
    "shouldResize",
    "onResizeStart",
    "onResize",
    "onResizeEnd",
    "class",
    "children"
  ]);
  const store = useStore();
  let id2 = user_derived(() => typeof $$props.nodeId === "string" ? $$props.nodeId : getContext("svelteflow__node_id"));
  let resizeControlRef;
  let resizer = state(null);
  let isLineVariant = user_derived(() => variant() === ResizeControlVariant.Line);
  let controlPosition = user_derived(() => {
    var _a3;
    let defaultPosition = get(isLineVariant) ? "right" : "bottom-right";
    return (_a3 = $$props.position) != null ? _a3 : defaultPosition;
  });
  let positionClasses = user_derived(() => get(controlPosition).split("-"));
  onMount(() => {
    if (resizeControlRef) {
      set(
        resizer,
        XYResizer({
          domNode: resizeControlRef,
          nodeId: get(id2),
          getStoreItems: () => {
            var _a3;
            return {
              nodeLookup: store.nodeLookup,
              transform: [store.viewport.x, store.viewport.y, store.viewport.zoom],
              snapGrid: (_a3 = store.snapGrid) != null ? _a3 : void 0,
              snapToGrid: !!store.snapGrid,
              nodeOrigin: store.nodeOrigin,
              paneDomNode: store.domNode
            };
          },
          onChange: (change, childChanges) => {
            const changes = /* @__PURE__ */ new Map();
            let position = change.x && change.y ? { x: change.x, y: change.y } : void 0;
            changes.set(get(id2), { ...change, position });
            for (const childChange of childChanges) {
              changes.set(childChange.id, { position: childChange.position });
            }
            store.nodes = store.nodes.map((node) => {
              var _a3, _b3, _c2, _d, _e, _f;
              const change2 = changes.get(node.id);
              if (change2) {
                return {
                  ...node,
                  position: {
                    x: (_b3 = (_a3 = change2.position) == null ? void 0 : _a3.x) != null ? _b3 : node.position.x,
                    y: (_d = (_c2 = change2.position) == null ? void 0 : _c2.y) != null ? _d : node.position.y
                  },
                  width: (_e = change2.width) != null ? _e : node.width,
                  height: (_f = change2.height) != null ? _f : node.height
                };
              }
              return node;
            });
          }
        }),
        true
      );
    }
    return () => {
      var _a3;
      (_a3 = get(resizer)) == null ? void 0 : _a3.destroy();
    };
  });
  user_pre_effect(() => {
    var _a3;
    (_a3 = get(resizer)) == null ? void 0 : _a3.update({
      controlPosition: get(controlPosition),
      boundaries: {
        minWidth: minWidth(),
        minHeight: minHeight(),
        maxWidth: maxWidth(),
        maxHeight: maxHeight()
      },
      keepAspectRatio: !!keepAspectRatio(),
      onResizeStart: $$props.onResizeStart,
      onResize: $$props.onResize,
      onResizeEnd: $$props.onResizeEnd,
      shouldResize: $$props.shouldResize
    });
  });
  var div = root28();
  attribute_effect(div, ($0, $1) => ({ class: $0, ...rest, [STYLE]: $1 }), [
    () => [
      "svelte-flow__resize-control",
      store.noDragClass,
      ...get(positionClasses),
      variant(),
      $$props.class
    ],
    () => ({
      "border-color": get(isLineVariant) ? $$props.color : void 0,
      "background-color": get(isLineVariant) ? void 0 : $$props.color,
      scale: get(isLineVariant) || !autoScale() ? void 0 : Math.max(1 / store.viewport.zoom, 1)
    })
  ]);
  var node_1 = child(div);
  snippet(node_1, () => {
    var _a3;
    return (_a3 = $$props.children) != null ? _a3 : noop;
  });
  reset(div);
  bind_this(div, ($$value) => resizeControlRef = $$value, () => resizeControlRef);
  append($$anchor, div);
  pop();
}

// node_modules/@xyflow/svelte/dist/lib/plugins/NodeResizer/NodeResizer.svelte
var root_111 = from_html(`<!> <!>`, 1);
function NodeResizer($$anchor, $$props) {
  push($$props, true);
  let isVisible = prop($$props, "isVisible", 3, true), autoScale = prop($$props, "autoScale", 3, true), rest = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "isVisible",
    "nodeId",
    "handleClass",
    "handleStyle",
    "lineClass",
    "lineStyle",
    "autoScale"
  ]);
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = root_111();
      var node_1 = first_child(fragment_1);
      each(node_1, 16, () => XY_RESIZER_LINE_POSITIONS, (position) => position, ($$anchor3, position) => {
        ResizeControl($$anchor3, spread_props(
          {
            get class() {
              return $$props.lineClass;
            },
            get style() {
              return $$props.lineStyle;
            },
            get nodeId() {
              return $$props.nodeId;
            },
            get position() {
              return position;
            },
            get autoScale() {
              return autoScale();
            },
            get variant() {
              return ResizeControlVariant.Line;
            }
          },
          () => rest
        ));
      });
      var node_2 = sibling(node_1, 2);
      each(node_2, 16, () => XY_RESIZER_HANDLE_POSITIONS, (position) => position, ($$anchor3, position) => {
        ResizeControl($$anchor3, spread_props(
          {
            get class() {
              return $$props.handleClass;
            },
            get style() {
              return $$props.handleStyle;
            },
            get nodeId() {
              return $$props.nodeId;
            },
            get position() {
              return position;
            },
            get autoScale() {
              return autoScale();
            }
          },
          () => rest
        ));
      });
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (isVisible()) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/lucide-svelte/dist/defaultAttributes.js
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
var defaultAttributes_default = defaultAttributes;

// node_modules/lucide-svelte/dist/Icon.svelte
var root29 = from_svg(`<svg><!><!></svg>`);
function Icon($$anchor, $$props) {
  const $$sanitized_props = legacy_rest_props($$props, ["children", "$$slots", "$$events", "$$legacy"]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "name",
    "color",
    "size",
    "strokeWidth",
    "absoluteStrokeWidth",
    "iconNode"
  ]);
  push($$props, false);
  let name = prop($$props, "name", 8, void 0);
  let color2 = prop($$props, "color", 8, "currentColor");
  let size = prop($$props, "size", 8, 24);
  let strokeWidth = prop($$props, "strokeWidth", 8, 2);
  let absoluteStrokeWidth = prop($$props, "absoluteStrokeWidth", 8, false);
  let iconNode = prop($$props, "iconNode", 24, () => []);
  const mergeClasses = (...classes) => classes.filter((className, index2, array2) => {
    return Boolean(className) && array2.indexOf(className) === index2;
  }).join(" ");
  init();
  var svg = root29();
  attribute_effect(
    svg,
    ($0, $1) => ({
      ...defaultAttributes_default,
      ...$$restProps,
      width: size(),
      height: size(),
      stroke: color2(),
      "stroke-width": $0,
      class: $1
    }),
    [
      () => (deep_read_state(absoluteStrokeWidth()), deep_read_state(strokeWidth()), deep_read_state(size()), untrack(() => absoluteStrokeWidth() ? Number(strokeWidth()) * 24 / Number(size()) : strokeWidth())),
      () => (deep_read_state(name()), deep_read_state($$sanitized_props), untrack(() => mergeClasses("lucide-icon", "lucide", name() ? `lucide-${name()}` : "", $$sanitized_props.class)))
    ]
  );
  var node = child(svg);
  each(node, 1, iconNode, index, ($$anchor2, $$item) => {
    var $$array = user_derived(() => to_array(get($$item), 2));
    let tag2 = () => get($$array)[0];
    let attrs = () => get($$array)[1];
    var fragment = comment();
    var node_1 = first_child(fragment);
    element(node_1, tag2, true, ($$element, $$anchor3) => {
      attribute_effect($$element, () => ({ ...attrs() }));
    });
    append($$anchor2, fragment);
  });
  var node_2 = sibling(node);
  slot(node_2, $$props, "default", {}, null);
  reset(svg);
  append($$anchor, svg);
  pop();
}

// node_modules/lucide-svelte/dist/icons/copy.svelte
function Copy($$anchor, $$props) {
  const $$sanitized_props = legacy_rest_props($$props, ["children", "$$slots", "$$events", "$$legacy"]);
  const iconNode = [
    [
      "rect",
      {
        "width": "14",
        "height": "14",
        "x": "8",
        "y": "8",
        "rx": "2",
        "ry": "2"
      }
    ],
    [
      "path",
      {
        "d": "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"
      }
    ]
  ];
  Icon($$anchor, spread_props({ name: "copy" }, () => $$sanitized_props, {
    get iconNode() {
      return iconNode;
    },
    children: ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node = first_child(fragment_1);
      slot(node, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    },
    $$slots: { default: true }
  }));
}

// node_modules/lucide-svelte/dist/icons/lightbulb.svelte
function Lightbulb($$anchor, $$props) {
  const $$sanitized_props = legacy_rest_props($$props, ["children", "$$slots", "$$events", "$$legacy"]);
  const iconNode = [
    [
      "path",
      {
        "d": "M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5"
      }
    ],
    ["path", { "d": "M9 18h6" }],
    ["path", { "d": "M10 22h4" }]
  ];
  Icon($$anchor, spread_props({ name: "lightbulb" }, () => $$sanitized_props, {
    get iconNode() {
      return iconNode;
    },
    children: ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node = first_child(fragment_1);
      slot(node, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    },
    $$slots: { default: true }
  }));
}

// node_modules/lucide-svelte/dist/icons/loader.svelte
function Loader($$anchor, $$props) {
  const $$sanitized_props = legacy_rest_props($$props, ["children", "$$slots", "$$events", "$$legacy"]);
  const iconNode = [
    ["path", { "d": "M12 2v4" }],
    ["path", { "d": "m16.2 7.8 2.9-2.9" }],
    ["path", { "d": "M18 12h4" }],
    ["path", { "d": "m16.2 16.2 2.9 2.9" }],
    ["path", { "d": "M12 18v4" }],
    ["path", { "d": "m4.9 19.1 2.9-2.9" }],
    ["path", { "d": "M2 12h4" }],
    ["path", { "d": "m4.9 4.9 2.9 2.9" }]
  ];
  Icon($$anchor, spread_props({ name: "loader" }, () => $$sanitized_props, {
    get iconNode() {
      return iconNode;
    },
    children: ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node = first_child(fragment_1);
      slot(node, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    },
    $$slots: { default: true }
  }));
}

// node_modules/lucide-svelte/dist/icons/map.svelte
function Map2($$anchor, $$props) {
  const $$sanitized_props = legacy_rest_props($$props, ["children", "$$slots", "$$events", "$$legacy"]);
  const iconNode = [
    [
      "path",
      {
        "d": "M14.106 5.553a2 2 0 0 0 1.788 0l3.659-1.83A1 1 0 0 1 21 4.619v12.764a1 1 0 0 1-.553.894l-4.553 2.277a2 2 0 0 1-1.788 0l-4.212-2.106a2 2 0 0 0-1.788 0l-3.659 1.83A1 1 0 0 1 3 19.381V6.618a1 1 0 0 1 .553-.894l4.553-2.277a2 2 0 0 1 1.788 0z"
      }
    ],
    ["path", { "d": "M15 5.764v15" }],
    ["path", { "d": "M9 3.236v15" }]
  ];
  Icon($$anchor, spread_props({ name: "map" }, () => $$sanitized_props, {
    get iconNode() {
      return iconNode;
    },
    children: ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node = first_child(fragment_1);
      slot(node, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    },
    $$slots: { default: true }
  }));
}

// node_modules/lucide-svelte/dist/icons/play.svelte
function Play($$anchor, $$props) {
  const $$sanitized_props = legacy_rest_props($$props, ["children", "$$slots", "$$events", "$$legacy"]);
  const iconNode = [
    [
      "path",
      {
        "d": "M5 5a2 2 0 0 1 3.008-1.728l11.997 6.998a2 2 0 0 1 .003 3.458l-12 7A2 2 0 0 1 5 19z"
      }
    ]
  ];
  Icon($$anchor, spread_props({ name: "play" }, () => $$sanitized_props, {
    get iconNode() {
      return iconNode;
    },
    children: ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node = first_child(fragment_1);
      slot(node, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    },
    $$slots: { default: true }
  }));
}

// node_modules/lucide-svelte/dist/icons/refresh-ccw.svelte
function Refresh_ccw($$anchor, $$props) {
  const $$sanitized_props = legacy_rest_props($$props, ["children", "$$slots", "$$events", "$$legacy"]);
  const iconNode = [
    [
      "path",
      { "d": "M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" }
    ],
    ["path", { "d": "M3 3v5h5" }],
    [
      "path",
      { "d": "M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16" }
    ],
    ["path", { "d": "M16 16h5v5" }]
  ];
  Icon($$anchor, spread_props({ name: "refresh-ccw" }, () => $$sanitized_props, {
    get iconNode() {
      return iconNode;
    },
    children: ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node = first_child(fragment_1);
      slot(node, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    },
    $$slots: { default: true }
  }));
}

// node_modules/lucide-svelte/dist/icons/settings.svelte
function Settings($$anchor, $$props) {
  const $$sanitized_props = legacy_rest_props($$props, ["children", "$$slots", "$$events", "$$legacy"]);
  const iconNode = [
    [
      "path",
      {
        "d": "M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915"
      }
    ],
    ["circle", { "cx": "12", "cy": "12", "r": "3" }]
  ];
  Icon($$anchor, spread_props({ name: "settings" }, () => $$sanitized_props, {
    get iconNode() {
      return iconNode;
    },
    children: ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node = first_child(fragment_1);
      slot(node, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    },
    $$slots: { default: true }
  }));
}

// node_modules/lucide-svelte/dist/icons/square-arrow-out-up-right.svelte
function Square_arrow_out_up_right($$anchor, $$props) {
  const $$sanitized_props = legacy_rest_props($$props, ["children", "$$slots", "$$events", "$$legacy"]);
  const iconNode = [
    [
      "path",
      {
        "d": "M21 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h6"
      }
    ],
    ["path", { "d": "m21 3-9 9" }],
    ["path", { "d": "M15 3h6v6" }]
  ];
  Icon($$anchor, spread_props({ name: "square-arrow-out-up-right" }, () => $$sanitized_props, {
    get iconNode() {
      return iconNode;
    },
    children: ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node = first_child(fragment_1);
      slot(node, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    },
    $$slots: { default: true }
  }));
}

// node_modules/lucide-svelte/dist/icons/square-play.svelte
function Square_play($$anchor, $$props) {
  const $$sanitized_props = legacy_rest_props($$props, ["children", "$$slots", "$$events", "$$legacy"]);
  const iconNode = [
    [
      "rect",
      { "x": "3", "y": "3", "width": "18", "height": "18", "rx": "2" }
    ],
    [
      "path",
      {
        "d": "M9 9.003a1 1 0 0 1 1.517-.859l4.997 2.997a1 1 0 0 1 0 1.718l-4.997 2.997A1 1 0 0 1 9 14.996z"
      }
    ]
  ];
  Icon($$anchor, spread_props({ name: "square-play" }, () => $$sanitized_props, {
    get iconNode() {
      return iconNode;
    },
    children: ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node = first_child(fragment_1);
      slot(node, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    },
    $$slots: { default: true }
  }));
}

// node_modules/lucide-svelte/dist/icons/square-x.svelte
function Square_x($$anchor, $$props) {
  const $$sanitized_props = legacy_rest_props($$props, ["children", "$$slots", "$$events", "$$legacy"]);
  const iconNode = [
    [
      "rect",
      {
        "width": "18",
        "height": "18",
        "x": "3",
        "y": "3",
        "rx": "2",
        "ry": "2"
      }
    ],
    ["path", { "d": "m15 9-6 6" }],
    ["path", { "d": "m9 9 6 6" }]
  ];
  Icon($$anchor, spread_props({ name: "square-x" }, () => $$sanitized_props, {
    get iconNode() {
      return iconNode;
    },
    children: ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node = first_child(fragment_1);
      slot(node, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    },
    $$slots: { default: true }
  }));
}

// node_modules/lucide-svelte/dist/icons/text-cursor-input.svelte
function Text_cursor_input($$anchor, $$props) {
  const $$sanitized_props = legacy_rest_props($$props, ["children", "$$slots", "$$events", "$$legacy"]);
  const iconNode = [
    ["path", { "d": "M12 20h-1a2 2 0 0 1-2-2 2 2 0 0 1-2 2H6" }],
    ["path", { "d": "M13 8h7a2 2 0 0 1 2 2v4a2 2 0 0 1-2 2h-7" }],
    ["path", { "d": "M5 16H4a2 2 0 0 1-2-2v-4a2 2 0 0 1 2-2h1" }],
    ["path", { "d": "M6 4h1a2 2 0 0 1 2 2 2 2 0 0 1 2-2h1" }],
    ["path", { "d": "M9 6v12" }]
  ];
  Icon($$anchor, spread_props({ name: "text-cursor-input" }, () => $$sanitized_props, {
    get iconNode() {
      return iconNode;
    },
    children: ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node = first_child(fragment_1);
      slot(node, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    },
    $$slots: { default: true }
  }));
}

// node_modules/lucide-svelte/dist/icons/x.svelte
function X($$anchor, $$props) {
  const $$sanitized_props = legacy_rest_props($$props, ["children", "$$slots", "$$events", "$$legacy"]);
  const iconNode = [
    ["path", { "d": "M18 6 6 18" }],
    ["path", { "d": "m6 6 12 12" }]
  ];
  Icon($$anchor, spread_props({ name: "x" }, () => $$sanitized_props, {
    get iconNode() {
      return iconNode;
    },
    children: ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node = first_child(fragment_1);
      slot(node, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    },
    $$slots: { default: true }
  }));
}

// src/providers/provider.js
var Provider = class {
  async FetchModels() {
    const options = {
      throw: false,
      url: this.GetFetchUrl(),
      headers: this.GetFetchHeaders()
    };
    console.log(`[Canvas LLM] FetchModels \u2192 ${this.name}`, options);
    const resp = await requestUrl(options);
    console.log(`[Canvas LLM] FetchModels \u2190 ${this.name}`, resp);
    const text2 = await resp.text;
    const data = this.ParseResponse(text2);
    this.CheckError(data);
    const result = this.ReadModels(data);
    return result;
  }
  ReadModels(data) {
    const result = data.data.map((model) => this.ReadModel(model));
    return result;
  }
  ReadModel(model) {
    return {
      id: model.id,
      name: model.display_name || model.displayName || model.id,
      desc: model.description || model.display_name || model.displayName || model.id,
      owner: model.owned_by || this.name,
      context: model.context_window || model.context_length || -1,
      prompt: -1,
      completion: -1
    };
  }
  async CallModel(model, nodes) {
    const messages = this.ReadMessages(nodes);
    try {
      const body = this.GetModelBody(model, messages);
      const options = {
        url: this.GetModelUrl(model),
        throw: false,
        method: "POST",
        headers: this.GetModelHeaders(),
        body: JSON.stringify(body)
      };
      console.log(`[Canvas LLM] CallModel \u2192 ${this.name} / ${model.name}`, options);
      const resp = await requestUrl(options);
      console.log(`[Canvas LLM] CallModel \u2190 ${this.name} / ${model.name}`, resp);
      const text2 = await resp.text;
      const data = this.ParseResponse(text2);
      this.CheckError(data);
      const markdowns = this.ReadResponse(data);
      return markdowns;
    } catch (error) {
      console.error(`[Canvas LLM] CallModel \u2190 ${this.name} / ${model.name}`, error);
      throw error;
    }
  }
  ReadMessages(nodes) {
    const messages = [];
    nodes.forEach((node) => {
      node.content.forEach((content) => {
        messages.push(this.ReadMessage(node, content));
      });
    });
    return messages;
  }
  ReadMessage(node, content) {
    return {
      content,
      role: node.role === "model" ? "assistant" : node.role
    };
  }
  GetModelBody(model, messages) {
    return {
      model: model.id,
      messages,
      stream: false
    };
  }
  CheckError(data) {
    var _a3;
    if (typeof (data == null ? void 0 : data.error) == "string")
      throw data.error;
    if (typeof ((_a3 = data == null ? void 0 : data.error) == null ? void 0 : _a3.message) == "string")
      throw data.error.message;
  }
  ParseResponse(text2) {
    try {
      const data = JSON.parse(text2);
      return data;
    } catch (ex) {
      throw text2;
    }
  }
  ReadResponse(data) {
    if (!(data == null ? void 0 : data.choices))
      return [""];
    const result = [];
    data.choices.forEach((choice) => {
      if (choice.message.reasoning)
        result.push(choice.message.reasoning);
      else if (choice.message.reasoning_content)
        result.push(choice.message.reasoning_content);
      if (choice.message.content)
        result.push(choice.message.content);
    });
    return result;
  }
};

// src/providers/alibaba.js
var Alibaba = class extends Provider {
  constructor() {
    super(...arguments);
    __publicField(this, "id", "alibaba");
    __publicField(this, "name", "Alibaba");
    __publicField(this, "keys", "https://modelstudio.console.alibabacloud.com/?tab=playground#/api-key");
    __publicField(this, "models", "https://www.alibabacloud.com/help/en/model-studio/models");
    __publicField(this, "untested", true);
  }
  // https://www.alibabacloud.com/help/en/model-studio/models
  GetFetchUrl() {
    return "https://github.com/farlenkov/obsidian-canvas-llm/raw/refs/heads/master/assets/data/qwen.json";
  }
  GetFetchHeaders() {
    return {};
  }
  ReadModel(model) {
    model.owner = this.name;
    return model;
  }
  // https://www.alibabacloud.com/help/en/model-studio/multi-round-conversation
  GetModelUrl(model) {
    return "https://dashscope-intl.aliyuncs.com/compatible-mode/v1/chat/completions";
  }
  GetModelHeaders() {
    return {
      "Content-Type": "application/json",
      "Authorization": "Bearer " + Settings_svelte_default.Data.alibabaKey
    };
  }
};
var alibaba_default = new Alibaba();

// src/providers/anthropic.js
var Anthropic = class extends Provider {
  constructor() {
    super(...arguments);
    __publicField(this, "id", "anthropic");
    __publicField(this, "name", "Anthropic");
    __publicField(this, "keys", "https://console.anthropic.com/account/keys");
    __publicField(this, "models", "https://docs.anthropic.com/en/docs/about-claude/pricing");
  }
  // https://docs.anthropic.com/en/api/models-list
  GetFetchUrl() {
    return "https://api.anthropic.com/v1/models?limit=1000";
  }
  GetFetchHeaders() {
    return {
      "content-type": "application/json",
      "x-api-key": Settings_svelte_default.Data.anthropicKey,
      "anthropic-version": "2023-06-01"
    };
  }
  // https://docs.anthropic.com/en/api/getting-started
  // https://docs.anthropic.com/en/api/messages
  GetModelUrl(model) {
    return "https://api.anthropic.com/v1/messages";
  }
  GetModelHeaders() {
    return {
      "x-api-key": Settings_svelte_default.Data.anthropicKey,
      "anthropic-version": "2023-06-01",
      "content-type": "application/json",
      "anthropic-dangerous-direct-browser-access": "true"
    };
  }
  GetModelBody(model, messages) {
    return {
      model: model.id,
      messages,
      max_tokens: 2048
    };
  }
  ReadResponse(data) {
    if (!(data == null ? void 0 : data.content))
      return [""];
    return data.content.map((content) => content.text);
  }
};
var anthropic_default = new Anthropic();

// src/providers/deepseek.js
var DeepSeek = class extends Provider {
  constructor() {
    super(...arguments);
    __publicField(this, "id", "deepseek");
    __publicField(this, "name", "DeepSeek");
    __publicField(this, "keys", "https://platform.deepseek.com/api_keys");
    __publicField(this, "models", "https://api-docs.deepseek.com/quick_start/pricing");
  }
  // https://api-docs.deepseek.com/api/list-models
  GetFetchUrl() {
    return "https://api.deepseek.com/models";
  }
  GetFetchHeaders() {
    return {
      "Authorization": `Bearer ${Settings_svelte_default.Data.deepseekKey}`,
      "Accept": "application/json"
    };
  }
  // https://api-docs.deepseek.com/
  GetModelUrl(model) {
    return "https://api.deepseek.com/chat/completions";
  }
  GetModelHeaders() {
    return {
      "Content-Type": "application/json",
      "Authorization": "Bearer " + Settings_svelte_default.Data.deepseekKey
    };
  }
};
var deepseek_default = new DeepSeek();

// src/providers/google.js
var Google = class extends Provider {
  constructor() {
    super(...arguments);
    __publicField(this, "id", "google");
    __publicField(this, "name", "Google");
    __publicField(this, "keys", "https://aistudio.google.com/app/apikey");
    __publicField(this, "models", "https://ai.google.dev/gemini-api/docs/pricing");
  }
  // https://ai.google.dev/api/models#models_list-SHELL
  GetFetchUrl() {
    return `https://generativelanguage.googleapis.com/v1beta/models?key=${Settings_svelte_default.Data.googleKey}`;
  }
  GetFetchHeaders() {
    return {};
  }
  ReadModels(data) {
    const result = [];
    data.models.forEach((model) => {
      if (model.supportedGenerationMethods.indexOf("generateContent") < 0)
        return;
      result.push(
        {
          id: model.name.replace("models/", ""),
          name: model.displayName,
          desc: model.description,
          owner: this.name,
          context: model.inputTokenLimit,
          prompt: -1,
          completion: -1
        }
      );
    });
    return result;
  }
  GetModelUrl(model) {
    return `https://generativelanguage.googleapis.com/v1beta/models/${model.id}:generateContent`;
  }
  GetModelHeaders() {
    return {
      "Content-Type": "application/json",
      "x-goog-api-key": Settings_svelte_default.Data.googleKey
    };
  }
  ReadMessages(nodes) {
    const messages = [];
    nodes.forEach((node) => {
      let message = {
        parts: [],
        role: node.role == "system" ? "user" : node.role
      };
      node.content.forEach((content) => {
        message.parts.push({
          text: node.role == "system" ? `*${content}*` : content
        });
      });
      messages.push(message);
    });
    return messages;
  }
  GetModelBody(model, messages) {
    const body = {
      contents: messages,
      generationConfig: {},
      safetySettings: [{
        category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
        threshold: "BLOCK_NONE"
      }]
    };
    body.generationConfig.thinkingConfig = { includeThoughts: true };
    return body;
  }
  ReadResponse(data) {
    var _a3, _b3, _c2;
    if (!((_c2 = (_b3 = (_a3 = data == null ? void 0 : data.candidates) == null ? void 0 : _a3[0]) == null ? void 0 : _b3.content) == null ? void 0 : _c2.parts))
      return [""];
    return data.candidates[0].content.parts.map((part) => part.text);
  }
};
var google_default = new Google();

// src/providers/groq.js
var Groq = class extends Provider {
  constructor() {
    super(...arguments);
    __publicField(this, "id", "groq");
    __publicField(this, "name", "Groq");
    __publicField(this, "keys", "https://console.groq.com/keys");
    __publicField(this, "models", "");
  }
  // https://console.groq.com/docs/api-reference#models-list
  GetFetchUrl() {
    return "https://api.groq.com/openai/v1/models";
  }
  GetFetchHeaders() {
    return {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${Settings_svelte_default.Data.groqKey}`
    };
  }
  // https://console.groq.com/docs/api-reference#chat-create
  GetModelUrl(model) {
    return "https://api.groq.com/openai/v1/chat/completions";
  }
  GetModelHeaders() {
    return {
      "Content-Type": "application/json",
      "Authorization": "Bearer " + Settings_svelte_default.Data.groqKey
    };
  }
};
var groq_default = new Groq();

// src/providers/openai.js
var OpenAI = class extends Provider {
  constructor() {
    super(...arguments);
    __publicField(this, "id", "openai");
    __publicField(this, "name", "OpenAI");
    __publicField(this, "keys", "https://platform.openai.com/api-keys");
    __publicField(this, "models", "https://platform.openai.com/docs/pricing");
  }
  // https://platform.openai.com/docs/api-reference/models/list
  GetFetchUrl() {
    return "https://api.openai.com/v1/models";
  }
  GetFetchHeaders() {
    return {
      "Content-Type": "application/json",
      "Authorization": "Bearer " + Settings_svelte_default.Data.openaiKey
    };
  }
  // https://platform.openai.com/docs/guides/text-generation#conversations-and-context
  // https://platform.openai.com/docs/quickstart?language-preference=curl
  GetModelUrl(model) {
    return "https://api.openai.com/v1/chat/completions";
  }
  GetModelHeaders() {
    return {
      "Content-Type": "application/json",
      "Authorization": "Bearer " + Settings_svelte_default.Data.openaiKey
    };
  }
};
var openai_default = new OpenAI();

// src/providers/openrouter.js
var OpenRouter = class extends Provider {
  constructor() {
    super(...arguments);
    __publicField(this, "id", "openrouter");
    __publicField(this, "name", "OpenRouter");
    __publicField(this, "keys", "https://openrouter.ai/settings/keys");
    __publicField(this, "models", "https://openrouter.ai/models");
    __publicField(this, "price", true);
  }
  GetFetchUrl() {
    return "https://openrouter.ai/api/v1/models";
  }
  GetFetchHeaders() {
    return {};
  }
  ReadModel(model) {
    return {
      id: model.id,
      name: model.name,
      desc: model.description,
      context: model.context_length,
      owner: model.owned_by || this.name,
      prompt: parseFloat(model.pricing.prompt),
      completion: parseFloat(model.pricing.completion)
    };
  }
  // https://openrouter.ai/docs/quick-start
  GetModelUrl(model) {
    return "https://openrouter.ai/api/v1/chat/completions";
  }
  GetModelHeaders() {
    return {
      "Content-Type": "application/json",
      "Authorization": "Bearer " + Settings_svelte_default.Data.openrouterKey
    };
  }
};
var openrouter_default = new OpenRouter();

// src/providers/sambanova.js
var SambaNova = class extends Provider {
  constructor() {
    super(...arguments);
    __publicField(this, "id", "sambanova");
    __publicField(this, "name", "SambaNova");
    __publicField(this, "keys", "https://cloud.sambanova.ai/apis");
    __publicField(this, "models", "https://cloud.sambanova.ai/plans/pricing");
  }
  // https://docs.sambanova.ai/cloud/api-reference/endpoints/model-list
  GetFetchUrl() {
    return "https://api.sambanova.ai/v1/models";
  }
  GetFetchHeaders() {
    return {};
  }
  ReadModel(model) {
    return {
      id: model.id,
      name: model.id,
      desc: model.id,
      context: model.context_length,
      owner: model.owned_by || this.name,
      prompt: parseFloat(model.pricing.prompt),
      completion: parseFloat(model.pricing.completion)
    };
  }
  // https://docs.sambanova.ai/cloud/api-reference/endpoints/chat
  GetModelUrl(model) {
    return "https://api.sambanova.ai/v1/chat/completions";
  }
  GetModelHeaders() {
    return {
      "Content-Type": "application/json",
      "Authorization": "Bearer " + Settings_svelte_default.Data.sambanovaKey
    };
  }
  ReadResponse(data) {
    if (!(data == null ? void 0 : data.choices))
      return [""];
    const result = [];
    data.choices.forEach((choice) => {
      const content = choice.message.content;
      const thinkMatch = content.match(/<think>([\s\S]*?)<\/think>/);
      const reasoning = thinkMatch ? thinkMatch[1].trim() : "";
      const response = content.replace(/<think>[\s\S]*?<\/think>/, "").trim();
      if (reasoning)
        result.push(reasoning);
      if (response)
        result.push(response);
    });
    return result;
  }
};
var sambanova_default = new SambaNova();

// src/providers/xai.js
var xAI = class extends Provider {
  constructor() {
    super(...arguments);
    __publicField(this, "id", "xai");
    __publicField(this, "name", "xAI");
    __publicField(this, "keys", "https://console.x.ai/team/default/api-keys");
    __publicField(this, "models", "https://docs.x.ai/docs/models");
  }
  // https://docs.x.ai/docs/api-reference#list-models
  GetFetchUrl() {
    return "https://api.x.ai/v1/models";
  }
  GetFetchHeaders() {
    return { "Authorization": `Bearer ${Settings_svelte_default.Data.xaiKey}` };
  }
  // https://docs.x.ai/docs/guides/chat
  GetModelUrl(model) {
    return "https://api.x.ai/v1/chat/completions";
  }
  GetModelHeaders() {
    return {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${Settings_svelte_default.Data.xaiKey}`
    };
  }
};
var xai_default = new xAI();

// src/models/ProviderInfo.svelte.js
var ProviderInfo = class {
  constructor() {
    __publicField(this, "List", [
      alibaba_default,
      anthropic_default,
      deepseek_default,
      google_default,
      groq_default,
      openai_default,
      openrouter_default,
      sambanova_default,
      xai_default
    ]);
    this.ById = {};
    this.List.forEach((provider) => this.ById[provider.id] = provider);
  }
};
var providerInfo = new ProviderInfo();
var ProviderInfo_svelte_default = providerInfo;

// src/obsidian/CanvasModal.js
var import_obsidian = require("obsidian");
var CanvasModal = class extends import_obsidian.Modal {
  constructor(appState2, ViewClass, modalType) {
    super(appState2.app);
    this.appState = appState2;
    this.modalType = modalType;
    this.ViewClass = ViewClass;
  }
  onOpen() {
    this.containerEl.classList.add("canvas-llm");
    this.containerEl.classList.add("canvas-llm-" + this.modalType);
    this.modelView = mount(
      this.ViewClass,
      {
        target: this.contentEl,
        props: { appState: this.appState, modal: this }
      }
    );
  }
  onClose() {
    if (this.modelView) {
      unmount(this.modelView);
      delete this.modelView;
    }
    this.containerEl.classList.remove("canvas-llm");
    this.containerEl.classList.remove("canvas-llm-" + this.modalType);
    this.contentEl.empty();
  }
};

// src/settings/Settings.svelte
var on_change = (_, appState2) => appState2().settings.Save();
var root_112 = from_html(`<div class="setting-item"><div class="setting-item-info"><div class="setting-item-name svelte-mrn94a"> <a target="_blank"><!></a></div> <div class="setting-item-description"></div></div> <div class="setting-item-control"><input type="text" class="inputbox1"/></div></div>`);
var root30 = from_html(`<div class="vertical-tab-content-container"><div class="vertical-tab-content svelte-mrn94a"><div class="vertical-tab-header-group"><div class="vertical-tab-header-group-title">API keys</div> <div class="vertical-tab-header-group-items"></div></div></div></div>`);
var $$css6 = {
  hash: "svelte-mrn94a",
  code: ".vertical-tab-content.svelte-mrn94a\r\n    {padding-top:var(--size-4-4);padding-bottom:var(--size-4-4);}.setting-item-name.svelte-mrn94a \r\n    {display:flex;align-items:center;gap:0.5em;}"
};
function Settings2($$anchor, $$props) {
  push($$props, true);
  append_styles($$anchor, $$css6);
  const appState2 = prop($$props, "appState", 7);
  var div = root30();
  var div_1 = child(div);
  var div_2 = child(div_1);
  var div_3 = sibling(child(div_2), 2);
  each(div_3, 21, () => appState2().providers.List, index, ($$anchor2, provider) => {
    var div_4 = root_112();
    var div_5 = child(div_4);
    var div_6 = child(div_5);
    var text2 = child(div_6);
    var a = sibling(text2);
    var node = child(a);
    Square_arrow_out_up_right(node, { size: 16 });
    reset(a);
    reset(div_6);
    next(2);
    reset(div_5);
    var div_7 = sibling(div_5, 2);
    var input = child(div_7);
    remove_input_defaults(input);
    input.__change = [on_change, appState2];
    reset(div_7);
    reset(div_4);
    template_effect(() => {
      var _a3, _b3, _c2;
      set_text(text2, `${(_a3 = get(provider).name) != null ? _a3 : ""} `);
      set_attribute2(a, "href", get(provider).keys);
      set_attribute2(a, "aria-label", `Get API key from ${(_b3 = get(provider).name) != null ? _b3 : ""}`);
      set_attribute2(input, "placeholder", `API key for ${(_c2 = get(provider).name) != null ? _c2 : ""}`);
    });
    bind_value(input, () => appState2().settings.Data[get(provider).id + "Key"], ($$value) => appState2().settings.Data[get(provider).id + "Key"] = $$value);
    append($$anchor2, div_4);
  });
  reset(div_3);
  reset(div_2);
  reset(div_1);
  reset(div);
  append($$anchor, div);
  pop();
}
delegate(["change"]);

// src/settings/Settings.svelte.js
var DEFAULT_SETTINGS = {
  defaultModel: "gemini-2.0-flash",
  defaultProvider: "google",
  recentModels: []
};
var _Data;
var SettingsState = class {
  constructor() {
    __publicField(this, "fileVersion", 1);
    __privateAdd(this, _Data, state());
  }
  get Data() {
    return get(__privateGet(this, _Data));
  }
  set Data(value) {
    set(__privateGet(this, _Data), value, true);
  }
  async Init(plugin) {
    this.plugin = plugin;
    this.Data = Object.assign({}, DEFAULT_SETTINGS, await plugin.loadData());
    this.Data.version = this.fileVersion;
    this.Save();
  }
  async Save() {
    await this.plugin.saveData(this.Data);
  }
  Show(appState2) {
    new CanvasModal(appState2, Settings2, "settings").open();
  }
  // API KEYS
  HasKey(providerId) {
    return this.Data[providerId + "Key"] ? true : false;
  }
  GetKey(providerId) {
    return this.Data[providerId + "Key"];
  }
  // AI MODELS
  HasModels(providerId) {
    let models = this.Data[providerId + "Models"];
    if (!models) return false;
    else return models.length > 0;
  }
  GetModels(providerId) {
    return this.Data[providerId + "Models"] || [];
  }
  SetModels(providerId, models) {
    return this.Data[providerId + "Models"] = models;
  }
  AddRecentModel(model) {
    try {
      for (var i = 0; i < this.Data.recentModels.length; i++) {
        var recentModel = this.Data.recentModels[i];
        if (recentModel.providerId == model.providerId && recentModel.id == model.id) {
          this.Data.recentModels.splice(i, 1);
          i--;
        }
      }
      this.Data.recentModels.unshift(model);
      while (this.Data.recentModels.length > 14) this.Data.recentModels.splice(13, 1);
      this.Save();
    } catch (ex) {
      console.error(ex);
    }
  }
  GetDefaultModel() {
    if (!this.Data.recentModels || this.Data.recentModels.length == 0) {
      return {
        providerId: this.Data.defaultProvider,
        id: this.Data.defaultModel
      };
    } else {
      return this.Data.recentModels[0];
    }
  }
};
_Data = new WeakMap();
var settings = new SettingsState();
var Settings_svelte_default = settings;

// src/utils/CreateId.js
var prevId = 0;
function createNodeId() {
  let newId2 = (/* @__PURE__ */ new Date()).getTime();
  if (newId2 === prevId)
    newId2++;
  prevId = newId2;
  return newId2.toString();
}
function createEdgeId(sourceId, targetId) {
  return `xy-edge__${sourceId}-${targetId}`;
}

// src/graph/Graph.default.js
function defaultGraph() {
  const node1 = createNodeId();
  const node2 = createNodeId();
  const defaultModel = Settings_svelte_default.GetDefaultModel();
  return {
    "nodes": [
      {
        "id": node1,
        "type": "textInput",
        "position": { "x": 20, "y": 0 },
        "data": { "value": "What is LLM?" },
        "width": 180,
        "height": 100
      },
      {
        "id": node2,
        "type": "generate",
        "position": { "x": 240, "y": 0 },
        "width": 460,
        "height": 340,
        "data": {
          "results": [],
          "model": defaultModel.id,
          "provider": defaultModel.providerId
        }
      }
    ],
    "edges": [
      {
        "id": createEdgeId(node1, node2),
        "source": node1,
        "target": node2
      }
    ]
  };
}
function defaultTextInput() {
  return {
    type: "textInput",
    width: 260,
    height: 120,
    data: { value: "" }
  };
}
function defaultGenerate() {
  const defaultModel = Settings_svelte_default.GetDefaultModel();
  return {
    type: "generate",
    width: 460,
    height: 340,
    data: {
      results: [],
      provider: defaultModel.providerId,
      model: defaultModel.id
    }
  };
}

// src/menu/ContextMenu.svelte
function addTextInput(_, addNode) {
  addNode(defaultTextInput());
}
function addGenerate(__1, addNode) {
  addNode(defaultGenerate());
}
function nodeRemove(__2, appState2) {
  appState2.graph.removeNode(appState2.contextMenu.Node);
  appState2.contextMenu.Hide();
}
function edgeRemove(__3, appState2) {
  appState2.graph.removeEdge(appState2.contextMenu.Edge);
  appState2.contextMenu.Hide();
}
var root_24 = from_html(`<div class="context-menu-item- menu-item tappable is-warning svelte-c5jycj"><!> <div class="menu-item-title">Delete node</div></div>`);
var root_42 = from_html(`<div class="context-menu-item- menu-item tappable is-warning svelte-c5jycj"><!> <div class="menu-item-title">Delete edge</div></div>`);
var root_5 = from_html(`<div class="context-menu-item- menu-item tappable svelte-c5jycj"><!> <div class="menu-item-title">Add text input</div></div> <div class="context-menu-item- menu-item tappable svelte-c5jycj"><!> <div class="menu-item-title">Add generator</div></div>`, 1);
var root_113 = from_html(`<div class="context-menu- menu svelte-c5jycj"><!></div>`);
var $$css7 = {
  hash: "svelte-c5jycj",
  code: ".menu.svelte-c5jycj\r\n  {position:absolute;z-index:10;}.menu-item.tappable.svelte-c5jycj:hover\r\n  {background-color:var(--background-modifier-hover);}.menu-item.svelte-c5jycj:not(.tappable)\r\n  {padding:0.5em;color:var(--text-accent);}"
};
function ContextMenu($$anchor, $$props) {
  push($$props, false);
  append_styles($$anchor, $$css7);
  const appState2 = getContext("appState");
  const { screenToFlowPosition } = useSvelteFlow();
  function addNode(newNode) {
    newNode.id = createNodeId();
    newNode.origin = [0, 0];
    newNode.position = screenToFlowPosition({
      x: appState2.contextMenu.Event.clientX,
      y: appState2.contextMenu.Event.clientY
    });
    appState2.graph.addNode(newNode);
    if (appState2.contextMenu.Connection) {
      if (appState2.contextMenu.Connection.fromHandle.type == "source") {
        appState2.graph.addEdge(appState2.contextMenu.Connection.fromNode.id, newNode.id);
      } else {
        appState2.graph.addEdge(newNode.id, appState2.contextMenu.Connection.fromNode.id);
      }
    }
    appState2.contextMenu.Hide();
  }
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_2 = ($$anchor2) => {
      var div = root_113();
      let styles;
      var node_1 = child(div);
      {
        var consequent = ($$anchor3) => {
          var div_1 = root_24();
          div_1.__click = [nodeRemove, appState2];
          var node_2 = child(div_1);
          Square_x(node_2, { size: 24, class: "menu-item-icon" });
          next(2);
          reset(div_1);
          append($$anchor3, div_1);
        };
        var alternate_1 = ($$anchor3) => {
          var fragment_1 = comment();
          var node_3 = first_child(fragment_1);
          {
            var consequent_1 = ($$anchor4) => {
              var div_2 = root_42();
              div_2.__click = [edgeRemove, appState2];
              var node_4 = child(div_2);
              Square_x(node_4, { size: 24, class: "menu-item-icon" });
              next(2);
              reset(div_2);
              append($$anchor4, div_2);
            };
            var alternate = ($$anchor4) => {
              var fragment_2 = root_5();
              var div_3 = first_child(fragment_2);
              div_3.__click = [addTextInput, addNode];
              var node_5 = child(div_3);
              Text_cursor_input(node_5, { size: 24, class: "menu-item-icon" });
              next(2);
              reset(div_3);
              var div_4 = sibling(div_3, 2);
              div_4.__click = [addGenerate, addNode];
              var node_6 = child(div_4);
              Square_play(node_6, { size: 24, class: "menu-item-icon" });
              next(2);
              reset(div_4);
              append($$anchor4, fragment_2);
            };
            if_block(
              node_3,
              ($$render) => {
                if (appState2.contextMenu.Edge) $$render(consequent_1);
                else $$render(alternate, false);
              },
              true
            );
          }
          append($$anchor3, fragment_1);
        };
        if_block(node_1, ($$render) => {
          if (appState2.contextMenu.Node) $$render(consequent);
          else $$render(alternate_1, false);
        });
      }
      reset(div);
      template_effect(($0) => styles = set_style(div, "", styles, $0), [
        () => ({
          top: appState2.contextMenu.Top,
          left: appState2.contextMenu.Left,
          right: appState2.contextMenu.Right,
          bottom: appState2.contextMenu.Bottom
        })
      ]);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if (appState2.contextMenu.IsVisible) $$render(consequent_2);
    });
  }
  append($$anchor, fragment);
  pop();
}
delegate(["click"]);

// src/nodes/Common/CopyTextButton.svelte
var root31 = from_html(`<button class="copy-text clickable-icon" aria-label="Copy text"><!></button>`);
function CopyTextButton($$anchor, $$props) {
  push($$props, true);
  const appState2 = getContext("appState");
  function onClick(ev) {
    if (!navigator.clipboard) return;
    const branch2 = appState2.graph.getBranch($$props.nodeId);
    if (!ev.shiftKey) {
      const node = branch2[branch2.length - 1];
      const text2 = getText(node, $$props.copyThink);
      navigator.clipboard.writeText(text2);
    } else {
      let text2 = "";
      for (var i = 0; i < branch2.length; i++) {
        const node = branch2[i];
        if (!text2) text2 = getText(node);
        else text2 += "\n\n---\n\n" + getText(node);
      }
      navigator.clipboard.writeText(text2);
    }
  }
  function getText(node, copyThink) {
    switch (node.type) {
      case "textInput":
        return node.data.value;
        break;
      case "generate":
        const result = node.data.results[node.data.part];
        return copyThink ? result.think : result.text;
        break;
    }
  }
  var button = root31();
  button.__click = onClick;
  var node_1 = child(button);
  Copy(node_1, { size: 16 });
  reset(button);
  append($$anchor, button);
  pop();
}
delegate(["click"]);

// src/nodes/TextInput/TextInputNode.svelte
function onChange(_, appState2, $$props, value) {
  appState2.graph.updateNode($$props.id, { value: get(value) }, "TextInput");
}
var root32 = from_html(`<!> <!> <!> <div><div class="canvas-node-container"><node-content><node-header><node-header-left>Input</node-header-left> <node-header-right><!></node-header-right></node-header> <node-body><textarea class="nodrag nozoom node-text svelte-17hoqng"></textarea></node-body></node-content></div></div>`, 3);
var $$css8 = {
  hash: "svelte-17hoqng",
  code: "textarea.svelte-17hoqng\r\n  {text-align:left;}"
};
function TextInputNode($$anchor, $$props) {
  push($$props, true);
  append_styles($$anchor, $$css8);
  const appState2 = getContext("appState");
  let value = state(proxy($$props.data.value));
  var fragment = root32();
  var node = first_child(fragment);
  NodeResizer(node, {
    minWidth: 100,
    minHeight: 30,
    onResizeEnd: () => appState2.graph.onChange("NodeResize")
  });
  var node_1 = sibling(node, 2);
  Handle(node_1, {
    type: "target",
    get position() {
      return Position.Left;
    }
  });
  var node_2 = sibling(node_1, 2);
  Handle(node_2, {
    type: "source",
    get position() {
      return Position.Right;
    }
  });
  var div = sibling(node_2, 2);
  let classes;
  var div_1 = child(div);
  var node_content = child(div_1);
  var node_header = child(node_content);
  var node_header_left = child(node_header);
  var node_header_right = sibling(node_header_left, 2);
  var node_3 = child(node_header_right);
  CopyTextButton(node_3, {
    get nodeId() {
      return $$props.id;
    }
  });
  reset(node_header_right);
  reset(node_header);
  var node_body = sibling(node_header, 2);
  set_class(node_body, 1, "nomenu");
  var textarea = child(node_body);
  remove_textarea_child(textarea);
  textarea.__change = [onChange, appState2, $$props, value];
  reset(node_body);
  reset(node_content);
  reset(div_1);
  reset(div);
  template_effect(($0) => classes = set_class(div, 1, "canvas-node", null, classes, $0), [() => ({ "is-selected": $$props.selected })]);
  bind_value(textarea, () => get(value), ($$value) => set(value, $$value));
  append($$anchor, fragment);
  pop();
}
delegate(["change"]);

// src/nodes/Generate/GenerateNode.svelte
var import_obsidian2 = require("obsidian");

// src/nodes/Common/ParamsButton.svelte
var root33 = from_html(`<button type="button" class="show-params clickable-icon" aria-label="Open node params"><!></button>`);
function ParamsButton($$anchor, $$props) {
  var button = root33();
  button.__click = function(...$$args) {
    var _a3;
    (_a3 = $$props.onclick) == null ? void 0 : _a3.apply(this, $$args);
  };
  var node = child(button);
  Settings(node, { size: 16 });
  reset(button);
  append($$anchor, button);
}
delegate(["click"]);

// src/models/AiClient.svelte.js
var AiClient = class {
  async Call(providerId, modelId, messages) {
    const provider = ProviderInfo_svelte_default.ById[providerId];
    const model = provider.ModelById[modelId];
    if (!provider) throw `[AiClient: Call] Invalid Provider ID: ${providerId}`;
    if (!model) throw `[AiClient: Call] Invalid Model ID: ${providerId} / ${modelId}`;
    let markdowns = await provider.CallModel(model, messages);
    if (!markdowns.some((md) => md != "")) throw "API provider respond with empty message.";
    return { markdowns };
  }
};
var aiClient = new AiClient();
var AiClient_svelte_default = aiClient;

// src/nodes/Generate/GenerateNode.svelte
async function clickGenerate(_, errorMessage, data, showParams, model, appState2, provider, inProgress, $$props, activeTab) {
  set(errorMessage, "");
  if (!data().model) {
    showParams();
    return;
  }
  if (!get(model)) {
    showParams();
    return;
  }
  if (!appState2.settings.HasKey(get(provider).id)) {
    appState2.ShowSettings();
    return;
  }
  set(inProgress, true);
  try {
    const nodes = appState2.graph.getPrompt($$props.id);
    if (nodes.length == 0) throw "Prompt is empty. Please connect some Input node.";
    const { markdowns } = await AiClient_svelte_default.Call(data().provider, data().model, nodes);
    const oldResults = data().results.filter((md) => md ? true : false);
    const result = {
      provider: data().provider,
      model: data().model,
      text: markdowns[0]
    };
    if (markdowns.length > 1) {
      result.think = markdowns[0];
      result.text = markdowns[1];
    }
    const update2 = { part: oldResults.length, results: [...oldResults, result] };
    appState2.graph.updateNode($$props.id, update2, "TextGenerate");
    set(activeTab, update2.part, true);
  } catch (err) {
    set(errorMessage, err, true);
  }
  set(inProgress, false);
}
function clickNextPart(__1, activeTab, data, showThink, appState2) {
  const nextPart = (get(activeTab) + 1) % data().results.length;
  data().part = nextPart;
  set(activeTab, nextPart);
  set(showThink, false);
  appState2.graph.onChange("NextPart");
}
var root_114 = from_html(`<div> </div>`);
var on_click = (__2, showThink) => set(showThink, true);
var root_43 = from_html(`<button class="show-think clickable-icon" aria-label="Show reasoning"><!></button>`);
var on_click_1 = (__3, showThink) => set(showThink, false);
var root_52 = from_html(`<button class="show-think clickable-icon color-text-accent" aria-label="Show message"><!></button>`);
var root_6 = from_html(`<button class="next-part svelte-1gfss40"> </button>`);
var root_7 = from_html(`<button class="call-llm mod-cta svelte-1gfss40" aria-label="Call LLM"><!></button>`);
var root_8 = from_html(`<button class="call-llm mod-cta svelte-1gfss40" aria-label="In progress..." disabled><!></button>`);
var on_click_2 = (__4, errorMessage) => {
  set(errorMessage, "");
};
var root_9 = from_html(`<error class="svelte-1gfss40"> <button type="button" class="btn-dark"><!></button></error>`);
var root34 = from_html(`<!> <!> <!> <div><div class="canvas-node-container"><node-content><node-header><node-header-left><!></node-header-left> <node-header-right><!> <!> <!> <!> <!></node-header-right></node-header> <node-body><div></div> <!></node-body></node-content></div></div>`, 3);
var $$css9 = {
  hash: "svelte-1gfss40",
  code: "button.next-part.svelte-1gfss40\r\n  {padding:var(--size-4-1) var(--size-4-2);}error.svelte-1gfss40\r\n  {position:fixed;top:2.05em;left:1px;right:1px;}node-header-left.svelte-1gfss40\r\n  {overflow:hidden;text-overflow:ellipsis;}node-header-right.svelte-1gfss40 .mod-cta:where(.svelte-1gfss40)\r\n  {padding:var(--size-4-1) var(--size-4-2);}"
};
function GenerateNode($$anchor, $$props) {
  var _a3;
  push($$props, true);
  append_styles($$anchor, $$css9);
  const appState2 = getContext("appState");
  let bodyEl;
  let data = prop($$props, "data", 7);
  let inProgress = state(false);
  let errorMessage = state("");
  let activeTab = state(proxy((_a3 = data().part) != null ? _a3 : 0));
  let hasThink = state(false);
  let showThink = state(false);
  let provider = user_derived(() => appState2.providers.ById[data().provider]);
  let model = user_derived(() => get(provider) ? get(provider).ModelById[data().model] : null);
  onMount(async () => {
    renderHtml();
  });
  user_effect(() => {
    renderHtml();
  });
  function getModelDesc() {
    if (get(model)) return `[ ${get(provider).name} / ${get(model).owner} ] ${get(model).desc}`;
    else return `[ ${data().provider} ] ${data().model}`;
  }
  function showParams() {
    appState2.generateParams.Show($$props.id, data());
  }
  function renderHtml() {
    bodyEl.empty();
    if (data().results.length <= get(activeTab)) return;
    const result = data().results[get(activeTab)];
    const text2 = get(showThink) ? result.think : result.text;
    set(hasThink, result.think ? true : false, true);
    import_obsidian2.MarkdownRenderer.render(appState2.app, text2, bodyEl, appState2.view.file.path, appState2.view);
  }
  var fragment = root34();
  var node = first_child(fragment);
  NodeResizer(node, {
    minWidth: 100,
    minHeight: 30,
    onResizeEnd: () => appState2.graph.onChange("NodeResize")
  });
  var node_1 = sibling(node, 2);
  Handle(node_1, {
    type: "target",
    get position() {
      return Position.Left;
    }
  });
  var node_2 = sibling(node_1, 2);
  Handle(node_2, {
    type: "source",
    get position() {
      return Position.Right;
    }
  });
  var div = sibling(node_2, 2);
  let classes;
  var div_1 = child(div);
  var node_content = child(div_1);
  var node_header = child(node_content);
  var node_header_left = child(node_header);
  set_class(node_header_left, 1, "svelte-1gfss40");
  var node_3 = child(node_header_left);
  {
    var consequent = ($$anchor2) => {
      var div_2 = root_114();
      var text_1 = child(div_2, true);
      reset(div_2);
      template_effect(
        ($0) => {
          set_attribute2(div_2, "aria-label", $0);
          set_text(text_1, data().model);
        },
        [getModelDesc]
      );
      append($$anchor2, div_2);
    };
    var alternate = ($$anchor2) => {
      var text_2 = text("Generate");
      append($$anchor2, text_2);
    };
    if_block(node_3, ($$render) => {
      if (data().model) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  reset(node_header_left);
  var node_header_right = sibling(node_header_left, 2);
  set_class(node_header_right, 1, "svelte-1gfss40");
  var node_4 = child(node_header_right);
  {
    var consequent_2 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_5 = first_child(fragment_1);
      {
        var consequent_1 = ($$anchor3) => {
          var button = root_43();
          button.__click = [on_click, showThink];
          var node_6 = child(button);
          Lightbulb(node_6, { size: 16 });
          reset(button);
          append($$anchor3, button);
        };
        var alternate_1 = ($$anchor3) => {
          var button_1 = root_52();
          button_1.__click = [on_click_1, showThink];
          var node_7 = child(button_1);
          Lightbulb(node_7, { size: 16 });
          reset(button_1);
          append($$anchor3, button_1);
        };
        if_block(node_5, ($$render) => {
          if (!get(showThink)) $$render(consequent_1);
          else $$render(alternate_1, false);
        });
      }
      append($$anchor2, fragment_1);
    };
    if_block(node_4, ($$render) => {
      if (get(hasThink)) $$render(consequent_2);
    });
  }
  var node_8 = sibling(node_4, 2);
  {
    var consequent_3 = ($$anchor2) => {
      var button_2 = root_6();
      button_2.__click = [clickNextPart, activeTab, data, showThink, appState2];
      var text_3 = child(button_2, true);
      reset(button_2);
      template_effect(() => {
        var _a4;
        set_attribute2(button_2, "aria-label", `Switch part (${get(activeTab) + 1}/${(_a4 = data().results.length) != null ? _a4 : ""})`);
        set_text(text_3, get(activeTab) + 1);
      });
      append($$anchor2, button_2);
    };
    if_block(node_8, ($$render) => {
      if (data().results.length > 1) $$render(consequent_3);
    });
  }
  var node_9 = sibling(node_8, 2);
  {
    var consequent_4 = ($$anchor2) => {
      var button_3 = root_7();
      button_3.__click = [
        clickGenerate,
        errorMessage,
        data,
        showParams,
        model,
        appState2,
        provider,
        inProgress,
        $$props,
        activeTab
      ];
      var node_10 = child(button_3);
      Play(node_10, { size: 16 });
      reset(button_3);
      append($$anchor2, button_3);
    };
    var alternate_2 = ($$anchor2) => {
      var button_4 = root_8();
      var node_11 = child(button_4);
      Loader(node_11, { size: 16, class: "rotate" });
      reset(button_4);
      append($$anchor2, button_4);
    };
    if_block(node_9, ($$render) => {
      if (!get(inProgress)) $$render(consequent_4);
      else $$render(alternate_2, false);
    });
  }
  var node_12 = sibling(node_9, 2);
  CopyTextButton(node_12, {
    get nodeId() {
      return $$props.id;
    },
    get copyThink() {
      return get(showThink);
    }
  });
  var node_13 = sibling(node_12, 2);
  ParamsButton(node_13, { onclick: showParams });
  reset(node_header_right);
  reset(node_header);
  var node_body = sibling(node_header, 2);
  set_class(node_body, 1, "nodrag nozoom nomenu node-text markdown-rendered");
  var div_3 = child(node_body);
  bind_this(div_3, ($$value) => bodyEl = $$value, () => bodyEl);
  var node_14 = sibling(div_3, 2);
  {
    var consequent_5 = ($$anchor2) => {
      var error = root_9();
      var text_4 = child(error);
      var button_5 = sibling(text_4);
      button_5.__click = [on_click_2, errorMessage];
      var node_15 = child(button_5);
      X(node_15, { size: 24, strokeWidth: 2 });
      reset(button_5);
      reset(error);
      template_effect(() => {
        var _a4;
        return set_text(text_4, `${(_a4 = get(errorMessage)) != null ? _a4 : ""} `);
      });
      append($$anchor2, error);
    };
    if_block(node_14, ($$render) => {
      if (get(errorMessage)) $$render(consequent_5);
    });
  }
  reset(node_body);
  reset(node_content);
  reset(div_1);
  reset(div);
  template_effect(($0) => classes = set_class(div, 1, "canvas-node", null, classes, $0), [() => ({ "is-selected": $$props.selected })]);
  append($$anchor, fragment);
  pop();
}
delegate(["click"]);

// src/graph/Graph.svelte
var root_25 = from_html(`<!> <!>`, 1);
var root_115 = from_html(`<!> <!> <!> <!>`, 1);
var root35 = from_html(`<div class="graph-container svelte-1yl1hvi"><!></div>`);
var $$css10 = {
  hash: "svelte-1yl1hvi",
  code: ".graph-container.svelte-1yl1hvi\r\n    {height : 100%;}"
};
function Graph($$anchor, $$props) {
  push($$props, true);
  append_styles($$anchor, $$css10);
  const appState2 = getContext("appState");
  const nodeTypes = { textInput: TextInputNode, generate: GenerateNode };
  let showMiniMap = state(false);
  let zoomOnScroll = state(true);
  let preventScrolling = user_derived(() => get(zoomOnScroll));
  async function onConnectEnd(event2, connection) {
    if (connection.isValid) {
      appState2.graph.removePrevEdge(connection);
      return;
    }
    await sleep(100);
    appState2.contextMenu.ShowConnect(event2, connection);
  }
  var div = root35();
  var node_1 = child(div);
  SvelteFlow(node_1, {
    get nodeTypes() {
      return nodeTypes;
    },
    get zoomOnScroll() {
      return get(zoomOnScroll);
    },
    get preventScrolling() {
      return get(preventScrolling);
    },
    fitView: true,
    fitViewOptions: { maxZoom: 1, minZoom: 1 },
    proOptions: { hideAttribution: true },
    snapGrid: [20, 20],
    onconnectstart: () => appState2.contextMenu.Hide(),
    onconnectend: onConnectEnd,
    ondelete: (event2) => appState2.graph.onChange("ondelete"),
    deleteKey: null,
    onpaneclick: () => appState2.contextMenu.Hide(),
    onnodeclick: () => appState2.contextMenu.Hide(),
    onedgeclick: () => appState2.contextMenu.Hide(),
    onnodedragstart: () => appState2.contextMenu.Hide(),
    onnodedragstop: () => appState2.graph.onChange("onnodedragstop"),
    onpanecontextmenu: ({ event: event2 }) => appState2.contextMenu.ShowPane(event2),
    onnodecontextmenu: ({ event: event2, node }) => appState2.contextMenu.ShowNode(event2, node),
    onedgecontextmenu: ({ event: event2, edge }) => appState2.contextMenu.ShowEdge(event2, edge),
    onnodepointermove: ({ event: event2 }) => {
      set(zoomOnScroll, event2.target.closest(".nozoom") == null);
    },
    onnodepointerleave: () => {
      set(zoomOnScroll, true);
    },
    get nodes() {
      return appState2.graph.nodes;
    },
    set nodes($$value) {
      appState2.graph.nodes = $$value;
    },
    get edges() {
      return appState2.graph.edges;
    },
    set edges($$value) {
      appState2.graph.edges = $$value;
    },
    children: ($$anchor2, $$slotProps) => {
      var fragment = root_115();
      var node_2 = first_child(fragment);
      Controls(node_2, {
        position: "bottom-left",
        orientation: "horizontal",
        children: ($$anchor3, $$slotProps2) => {
          var fragment_1 = root_25();
          var node_3 = first_child(fragment_1);
          ControlButton(node_3, {
            onclick: () => set(showMiniMap, !get(showMiniMap)),
            title: "MiniMap",
            class: "canvas-llm-controll-button",
            children: ($$anchor4, $$slotProps3) => {
              Map2($$anchor4, { size: 24 });
            },
            $$slots: { default: true }
          });
          var node_4 = sibling(node_3, 2);
          ControlButton(node_4, {
            onclick: () => appState2.ShowSettings(),
            title: "Settings",
            class: "canvas-llm-controll-button",
            children: ($$anchor4, $$slotProps3) => {
              Settings($$anchor4, { size: 24 });
            },
            $$slots: { default: true }
          });
          append($$anchor3, fragment_1);
        },
        $$slots: { default: true }
      });
      var node_5 = sibling(node_2, 2);
      ContextMenu(node_5, {});
      var node_6 = sibling(node_5, 2);
      {
        var consequent = ($$anchor3) => {
          Minimap($$anchor3, {});
        };
        if_block(node_6, ($$render) => {
          if (get(showMiniMap)) $$render(consequent);
        });
      }
      var node_7 = sibling(node_6, 2);
      Background(node_7, {
        get variant() {
          return BackgroundVariant.Dots;
        },
        patternColor: "rgba(255,255,255,0.5)",
        gap: 20
      });
      append($$anchor2, fragment);
    },
    $$slots: { default: true }
  });
  reset(div);
  bind_element_size(div, "clientWidth", ($$value) => appState2.contextMenu.CanvasWidth = $$value);
  bind_element_size(div, "clientHeight", ($$value) => appState2.contextMenu.CanvasHeight = $$value);
  append($$anchor, div);
  pop();
}

// src/app/App.svelte
function App($$anchor, $$props) {
  push($$props, true);
  setContext("appState", $$props.appState);
  Graph($$anchor, {});
  pop();
}

// src/graph/Graph.svelte.js
var _nodes, _edges;
var GraphState = class {
  constructor(file) {
    __privateAdd(this, _nodes);
    __privateAdd(this, _edges);
    this.fileVersion = 2;
    this.file = file;
    __privateSet(this, _nodes, state([]));
    __privateSet(this, _edges, state([]));
    this.onChange = () => {
    };
  }
  get nodes() {
    return get(__privateGet(this, _nodes));
  }
  set nodes(value) {
    set(__privateGet(this, _nodes), value);
  }
  get edges() {
    return get(__privateGet(this, _edges));
  }
  set edges(value) {
    set(__privateGet(this, _edges), value);
  }
  async loadFromFile(graphJson) {
    if (typeof graphJson === "string") graphJson = JSON.parse(graphJson);
    await this.upgradeGraph(graphJson);
    this.nodes = graphJson.nodes;
    this.edges = graphJson.edges;
  }
  async upgradeGraph(graphJson) {
    if (!graphJson.version) graphJson.version = this.fileVersion;
    graphJson.nodes.forEach((node) => {
      if (node.data.markdown) {
        node.data.markdowns = [node.data.markdown];
        delete node.data.markdown;
      }
      if (node.data.html) delete node.data.html;
      if (node.data.htmls) delete node.data.htmls;
      if (node.data.model && !node.data.provider) {
        ProviderInfo_svelte_default.List.forEach((provider) => {
          if (provider.ModelById[node.data.model]) node.data.provider = provider.id;
        });
      }
      if (node.data.markdowns) {
        node.data.results = [];
        node.data.markdowns.forEach((markdown) => {
          const result = {
            provider: node.data.provider,
            model: node.data.model,
            text: markdown
          };
          if (Array.isArray(markdown)) {
            result.think = markdown[0];
            result.text = markdown[1];
          }
          node.data.results.push(result);
        });
        delete node.data.markdowns;
      }
    });
  }
  addNode(node) {
    this.nodes = [...this.nodes, node];
    this.onChange("addNode");
  }
  addEdge(sourceId, targetId) {
    this.edges = [
      ...this.edges,
      {
        source: sourceId,
        target: targetId,
        id: createEdgeId(sourceId, targetId)
      }
    ];
    this.onChange("addEdge");
  }
  removeNode(node) {
    this.nodes = this.nodes.filter((node2) => node2.id != node.id);
    this.edges = this.edges.filter((edge) => edge.source != node.id && edge.target != node.id);
    this.onChange("removeNode");
  }
  removeEdge(edge) {
    this.edges = this.edges.filter((edge2) => edge2.source != edge.source || edge2.target != edge.target);
    this.onChange("removeEdge");
  }
  removePrevEdge(connection) {
    const newEdge = {};
    newEdge[connection.fromHandle.type] = connection.fromHandle.nodeId;
    newEdge[connection.toHandle.type] = connection.toHandle.nodeId;
    this.edges = this.edges.filter((oldEdge) => {
      if (oldEdge.target == newEdge.target) {
        if (oldEdge.source != newEdge.source) return false;
      }
      return true;
    });
    this.onChange("removePrevEdge");
  }
  updateNode(id2, update2, note) {
    this.nodes = this.nodes.map((node) => {
      if (node.id == id2) return { ...node, data: { ...node.data, ...update2 } };
      return node;
    });
    this.onChange(note);
  }
  toString() {
    const data = {
      version: this.fileVersion,
      nodes: this.nodes,
      edges: this.edges
    };
    return JSON.stringify(data, null, "	");
  }
  getBranch(targetId, loop2 = {}) {
    loop2[targetId] = true;
    const targetNode = this.nodes.find((node) => node.id === targetId);
    if (!targetNode) return [];
    const sourceEdge = this.edges.find((edge) => edge.target === targetId);
    if (!sourceEdge) return [targetNode];
    if (loop2[sourceEdge.source]) return [targetNode];
    return [...this.getBranch(sourceEdge.source, loop2), targetNode];
  }
  getPrompt(targetId) {
    const branch2 = this.getBranch(targetId);
    const result = [];
    for (var i = 0; i < branch2.length - 1; i++) {
      const node = branch2[i];
      let message = null;
      switch (node.type) {
        case "textInput":
          message = { role: "user", content: [node.data.value] };
          break;
        case "generate":
          message = {
            role: "model",
            content: [node.data.results[node.data.part].text]
          };
          break;
      }
      result.push(message);
    }
    return result;
  }
};
_nodes = new WeakMap();
_edges = new WeakMap();

// src/menu/ContextMenu.svelte.js
var _IsVisible, _Node, _Edge, _Top, _Left, _Right, _Bottom, _CanvasWidth, _CanvasHeight, _ContextMenuState_instances, Show_fn;
var ContextMenuState = class {
  constructor() {
    __privateAdd(this, _ContextMenuState_instances);
    __privateAdd(this, _IsVisible, state(false));
    __privateAdd(this, _Node, state(null));
    __privateAdd(this, _Edge, state(null));
    __privateAdd(this, _Top, state(void 0));
    __privateAdd(this, _Left, state(void 0));
    __privateAdd(this, _Right, state(void 0));
    __privateAdd(this, _Bottom, state(void 0));
    __privateAdd(this, _CanvasWidth, state(0));
    __privateAdd(this, _CanvasHeight, state(0));
  }
  get IsVisible() {
    return get(__privateGet(this, _IsVisible));
  }
  set IsVisible(value) {
    set(__privateGet(this, _IsVisible), value, true);
  }
  get Node() {
    return get(__privateGet(this, _Node));
  }
  set Node(value) {
    set(__privateGet(this, _Node), value, true);
  }
  get Edge() {
    return get(__privateGet(this, _Edge));
  }
  set Edge(value) {
    set(__privateGet(this, _Edge), value, true);
  }
  get Top() {
    return get(__privateGet(this, _Top));
  }
  set Top(value) {
    set(__privateGet(this, _Top), value, true);
  }
  get Left() {
    return get(__privateGet(this, _Left));
  }
  set Left(value) {
    set(__privateGet(this, _Left), value, true);
  }
  get Right() {
    return get(__privateGet(this, _Right));
  }
  set Right(value) {
    set(__privateGet(this, _Right), value, true);
  }
  get Bottom() {
    return get(__privateGet(this, _Bottom));
  }
  set Bottom(value) {
    set(__privateGet(this, _Bottom), value, true);
  }
  get CanvasWidth() {
    return get(__privateGet(this, _CanvasWidth));
  }
  set CanvasWidth(value) {
    set(__privateGet(this, _CanvasWidth), value, true);
  }
  get CanvasHeight() {
    return get(__privateGet(this, _CanvasHeight));
  }
  set CanvasHeight(value) {
    set(__privateGet(this, _CanvasHeight), value, true);
  }
  ShowPane(event2) {
    __privateMethod(this, _ContextMenuState_instances, Show_fn).call(this, event2);
  }
  ShowNode(event2, node) {
    __privateMethod(this, _ContextMenuState_instances, Show_fn).call(this, event2, node);
  }
  ShowEdge(event2, edge) {
    __privateMethod(this, _ContextMenuState_instances, Show_fn).call(this, event2, null, edge);
  }
  ShowConnect(event2, connection) {
    __privateMethod(this, _ContextMenuState_instances, Show_fn).call(this, event2, null, null, connection);
  }
  Hide() {
    if (this.IsVisible) {
      this.Event = null;
      this.Node = null;
      this.Edge = null;
      this.IsVisible = false;
    }
  }
};
_IsVisible = new WeakMap();
_Node = new WeakMap();
_Edge = new WeakMap();
_Top = new WeakMap();
_Left = new WeakMap();
_Right = new WeakMap();
_Bottom = new WeakMap();
_CanvasWidth = new WeakMap();
_CanvasHeight = new WeakMap();
_ContextMenuState_instances = new WeakSet();
Show_fn = function(event2, node, edge, connection) {
  const noContextMenu = event2.target.closest(".nomenu");
  if (noContextMenu) {
    this.Hide();
    return;
  }
  this.Event = event2;
  this.Node = node;
  this.Edge = edge;
  this.Connection = connection;
  event2.preventDefault();
  const rootEl = event2.target.closest(".svelte-flow");
  const rootRect = rootEl.getBoundingClientRect();
  const clientX = event2.clientX - rootRect.left;
  const clientY = event2.clientY - rootRect.top;
  this.Top = clientY < this.CanvasHeight - 200 ? clientY + "px" : void 0, this.Left = clientX < this.CanvasWidth - 200 ? clientX + "px" : void 0, this.Right = clientX >= this.CanvasWidth - 200 ? this.CanvasWidth - clientX + "px" : void 0, this.Bottom = clientY >= this.CanvasHeight - 200 ? this.CanvasHeight - clientY + "px" : void 0;
  this.IsVisible = true;
};

// src/nodes/Generate/GenerateParams.svelte
async function fetchModels(_, errorMessage, appState2, selectedProviderId) {
  set(errorMessage, null);
  set(errorMessage, await appState2().models.FetchModels(get(selectedProviderId)), true);
}
var on_click2 = (__1, clickProvider, provider) => {
  clickProvider(get(provider).id);
};
var root_26 = from_html(`<div> </div>`);
var on_click_12 = (__2, clickProvider, provider) => {
  clickProvider(get(provider).id);
};
var root_44 = from_html(`<div> </div>`);
var on_click_22 = (__3, clickProvider, RECENT_TAB) => {
  clickProvider(RECENT_TAB);
};
var on_click_3 = (__4, selectedProvider) => {
  window.open(get(selectedProvider).models);
};
var root_53 = from_html(`<untested class="svelte-fcc3aa">Access to this provider is implemented according to its documentation, but has not been tested by the developer of Canvas LLM. 
                                If you use it, please <a href="https://github.com/farlenkov/obsidian-canvas-llm/issues">share</a> your results with me.</untested>`);
var on_click_4 = (__5, appState2) => {
  appState2().ShowSettings();
};
var root_62 = from_html(`<div class="no-api-key svelte-fcc3aa">You did not provide the API key for <b> </b>. <br/> <br/> You can get API key here: <br/> <a target="_blank" title="Get API Key"> </a> <br/> <br/> And paste your API key in settings: <br/> <div class="open-settings-container svelte-fcc3aa"><button class="svelte-fcc3aa">Open settings</button></div></div>`);
var on_click_5 = (__6, errorMessage) => {
  set(errorMessage, null);
};
var root_11 = from_html(`<error class="svelte-fcc3aa"> <button type="button" class="btn-dark"><!></button></error>`);
var root_82 = from_html(`<div class="list-of-models svelte-fcc3aa">List of models for <b> </b> not downloaded yet. <br/> <div class="button-container svelte-fcc3aa"><button class="svelte-fcc3aa"><!></button></div> <!></div>`);
var on_click_6 = (__7, errorMessage) => {
  set(errorMessage, null);
};
var root_132 = from_html(`<error> <button type="button" class="btn-dark"><!></button></error>`);
var on_click_7 = (__8, clickModel, model) => {
  clickModel(get(model));
};
var root_172 = from_html(` <label-free>free</label-free>`, 3);
var root_182 = from_html(`<label-provider> </label-provider>`, 2);
var root_152 = from_html(`<div><!> <!></div>`);
var root_122 = from_html(`<!> <!>`, 1);
var root36 = from_html(`<div class="vertical-tabs-container svelte-fcc3aa"><div class="vertical-tab-header svelte-fcc3aa"><div class="vertical-tab-header-group svelte-fcc3aa"><div class="vertical-tab-header-group-title">API providers</div> <div class="vertical-tab-header-group-items svelte-fcc3aa"></div> <div class="vertical-tab-header-group-title">Untested</div> <div class="vertical-tab-header-group-items svelte-fcc3aa"></div> <div class="vertical-tab-header-group-title">Your</div> <div class="vertical-tab-header-group-items svelte-fcc3aa"><div>Resent <div class="vertical-tab-nav-item-chevron"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-chevron-right"><path d="m9 18 6-6-6-6"></path></svg></div></div></div></div></div> <div class="relative vertical-tab-content-container svelte-fcc3aa"><div class="models-filter-wrap1 svelte-fcc3aa"><div class="models-filter-wrap2 svelte-fcc3aa"><models-filter><models-buttons><button><!></button> <button class="clickable-icon svelte-fcc3aa"><!></button></models-buttons> <input type="text" placeholder="Filter models by name"/> <label aria-label="Show only free models"><input type="checkbox"/> Free</label></models-filter></div></div> <div class="vertical-tab-content svelte-fcc3aa"><div class="vertical-tab-header-group svelte-fcc3aa"><div class="vertical-tab-header-group-title"> </div> <div class="vertical-tab-header-group-items svelte-fcc3aa"><!> <!></div></div></div></div></div>`, 2);
var $$css11 = {
  hash: "svelte-fcc3aa",
  code: '.vertical-tabs-container.svelte-fcc3aa\r\n    {\r\n        /* padding-top: 1.5em; */height:100%;}.vertical-tab-content.svelte-fcc3aa\r\n    {padding:var(--size-4-3);}.vertical-tab-header.svelte-fcc3aa,\r\n    .vertical-tab-header-group.svelte-fcc3aa,\r\n    .vertical-tab-content.svelte-fcc3aa\r\n    {padding-top:0;padding-bottom:0;}.vertical-tab-header-group-items.svelte-fcc3aa \r\n    {margin-bottom:1.5em;}.vertical-tab-content-container.svelte-fcc3aa\r\n    {margin-top:0;}.vertical-tab-header-group.svelte-fcc3aa\r\n    {padding-top:0;}.no-api-key.svelte-fcc3aa\r\n    {padding:var(--size-4-1) var(--size-4-2);}.open-settings-container.svelte-fcc3aa\r\n    {display:inline-block;button:where(.svelte-fcc3aa) \r\n        {margin-top:0.6em;}}.list-of-models.svelte-fcc3aa\r\n    {padding:var(--size-4-1) var(--size-4-2);error:where(.svelte-fcc3aa)\r\n        {margin-top:1em;}.button-container:where(.svelte-fcc3aa)\r\n        {display:inline-block;button:where(.svelte-fcc3aa) \r\n            {margin-top:1em;}}}.models-filter-wrap1.svelte-fcc3aa\r\n    {position:absolute;top:0;left:0;right:0;height:3em;}.models-filter-wrap2.svelte-fcc3aa\r\n    {position:relative;width:100%;height:100%;}label-free.svelte-fcc3aa\r\n    {display:inline-block;font-size:0.9em;background-color:green;color:white;padding:0 0.25em;}label-provider.svelte-fcc3aa\r\n    {display:inline-block;opacity:0.5;}models-filter.svelte-fcc3aa\r\n    {display:flex;justify-content:center;align-items:center;gap:1.5em;padding:0.2em 05em;width:100%;height:100%;position:relative;input[type="text"].models-filter-name:where(.svelte-fcc3aa)\r\n        {width:16.5em;height:1.75em;text-align:center;}.models-filter-free:where(.svelte-fcc3aa)\r\n        {display:flex;align-items:center;}}models-buttons.svelte-fcc3aa\r\n    {display:flex;justify-content:center;align-items:center;gap:0;button:where(.svelte-fcc3aa)\r\n        {padding:0.5em;}}untested.svelte-fcc3aa\r\n    {display:block;border-left:3px solid var(--color-blue);background-color:var(--background-secondary);margin-bottom:0.5em;font-size:0.8em;padding:8px;border-radius:4px;}'
};
function GenerateParams($$anchor, $$props) {
  push($$props, true);
  append_styles($$anchor, $$css11);
  const RECENT_TAB = "recent";
  const FAVORITES_TAB = "favorites";
  const appState2 = prop($$props, "appState", 7);
  let selectedProviderId = state(proxy(appState2().generateParams.ProviderTab || appState2().generateParams.ProviderID));
  let selectedProvider = user_derived(() => appState2().providers.ById[get(selectedProviderId)]);
  let selectedProviderName = user_derived(() => get(selectedProvider) == null ? get(selectedProviderId) : get(selectedProvider).name);
  let selectedProviderPrice = user_derived(() => get(selectedProvider) == null ? false : get(selectedProvider).price);
  let hasKey = user_derived(() => appState2().settings.HasKey(get(selectedProviderId)));
  let hasModels = user_derived(() => appState2().settings.HasModels(get(selectedProviderId)));
  let isSpecial = user_derived(() => get(selectedProviderId) == RECENT_TAB || get(selectedProviderId) == FAVORITES_TAB);
  let isUpdating = user_derived(() => appState2().models.Updating[get(selectedProviderId)]);
  let errorMessage = state(void 0);
  function clickProvider(providerId) {
    set(selectedProviderId, providerId, true);
    set(errorMessage, null);
  }
  function clickModel(model) {
    appState2().graph.updateNode(appState2().generateParams.NodeID, { provider: model.providerId, model: model.id }, "ModelChange");
    appState2().generateParams.ProviderTab = get(selectedProviderId);
    appState2().settings.AddRecentModel(model);
    $$props.modal.close();
  }
  function checkFilter(model) {
    if (get(selectedProviderPrice) && appState2().generateParams.FilterFree) {
      if (model.prompt + model.completion != 0) return false;
    }
    let nameFilter = appState2().generateParams.FilterName.trim();
    if (nameFilter && model.id.toLowerCase().indexOf(nameFilter.toLowerCase()) < 0) return false;
    return true;
  }
  function getModelDesc(model) {
    const provider = appState2().providers.ById[model.providerId];
    return `[ ${provider.name} / ${model.owner} ] ${model.desc}`;
  }
  function getProviderName(model) {
    const provider = appState2().providers.ById[model.providerId];
    return `(${provider.name})`;
  }
  var div = root36();
  var div_1 = child(div);
  var div_2 = child(div_1);
  var div_3 = sibling(child(div_2), 2);
  each(div_3, 21, () => appState2().providers.List, index, ($$anchor2, provider) => {
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor3) => {
        var div_4 = root_26();
        div_4.__click = [on_click2, clickProvider, provider];
        let classes;
        var text2 = child(div_4, true);
        reset(div_4);
        template_effect(
          ($0) => {
            classes = set_class(div_4, 1, "vertical-tab-nav-item", null, classes, $0);
            set_text(text2, get(provider).name);
          },
          [
            () => ({ "is-active": get(provider).id == get(selectedProviderId) })
          ]
        );
        append($$anchor3, div_4);
      };
      if_block(node, ($$render) => {
        if (!get(provider).untested) $$render(consequent);
      });
    }
    append($$anchor2, fragment);
  });
  reset(div_3);
  var div_5 = sibling(div_3, 4);
  each(div_5, 21, () => appState2().providers.List, index, ($$anchor2, provider) => {
    var fragment_1 = comment();
    var node_1 = first_child(fragment_1);
    {
      var consequent_1 = ($$anchor3) => {
        var div_6 = root_44();
        div_6.__click = [on_click_12, clickProvider, provider];
        let classes_1;
        var text_1 = child(div_6, true);
        reset(div_6);
        template_effect(
          ($0) => {
            classes_1 = set_class(div_6, 1, "vertical-tab-nav-item", null, classes_1, $0);
            set_text(text_1, get(provider).name);
          },
          [
            () => ({ "is-active": get(provider).id == get(selectedProviderId) })
          ]
        );
        append($$anchor3, div_6);
      };
      if_block(node_1, ($$render) => {
        if (get(provider).untested) $$render(consequent_1);
      });
    }
    append($$anchor2, fragment_1);
  });
  reset(div_5);
  var div_7 = sibling(div_5, 4);
  var div_8 = child(div_7);
  div_8.__click = [on_click_22, clickProvider, RECENT_TAB];
  let classes_2;
  reset(div_7);
  reset(div_2);
  reset(div_1);
  var div_9 = sibling(div_1, 2);
  var div_10 = child(div_9);
  var div_11 = child(div_10);
  var models_filter = child(div_11);
  set_class(models_filter, 1, "svelte-fcc3aa");
  var models_buttons = child(models_filter);
  set_class(models_buttons, 1, "svelte-fcc3aa");
  var button = child(models_buttons);
  let classes_3;
  button.__click = [fetchModels, errorMessage, appState2, selectedProviderId];
  var node_2 = child(button);
  Refresh_ccw(node_2, { size: 16 });
  reset(button);
  var button_1 = sibling(button, 2);
  button_1.__click = [on_click_3, selectedProvider];
  var node_3 = child(button_1);
  Square_arrow_out_up_right(node_3, { size: 16 });
  reset(button_1);
  reset(models_buttons);
  var input = sibling(models_buttons, 2);
  remove_input_defaults(input);
  let classes_4;
  var label2 = sibling(input, 2);
  let classes_5;
  var input_1 = child(label2);
  remove_input_defaults(input_1);
  next();
  reset(label2);
  reset(models_filter);
  reset(div_11);
  reset(div_10);
  var div_12 = sibling(div_10, 2);
  var div_13 = child(div_12);
  var div_14 = child(div_13);
  var text_2 = child(div_14);
  reset(div_14);
  var div_15 = sibling(div_14, 2);
  var node_4 = child(div_15);
  {
    var consequent_2 = ($$anchor2) => {
      var untested = root_53();
      append($$anchor2, untested);
    };
    if_block(node_4, ($$render) => {
      if (!get(isSpecial) && get(selectedProvider).untested) $$render(consequent_2);
    });
  }
  var node_5 = sibling(node_4, 2);
  {
    var consequent_3 = ($$anchor2) => {
      var div_16 = root_62();
      var b = sibling(child(div_16));
      var text_3 = child(b, true);
      reset(b);
      var a = sibling(b, 8);
      var text_4 = child(a, true);
      reset(a);
      var div_17 = sibling(a, 8);
      var button_2 = child(div_17);
      button_2.__click = [on_click_4, appState2];
      reset(div_17);
      reset(div_16);
      template_effect(() => {
        set_text(text_3, get(selectedProvider).name);
        set_attribute2(a, "href", get(selectedProvider).keys);
        set_text(text_4, get(selectedProvider).keys);
      });
      append($$anchor2, div_16);
    };
    var alternate_3 = ($$anchor2) => {
      var fragment_2 = comment();
      var node_6 = first_child(fragment_2);
      {
        var consequent_6 = ($$anchor3) => {
          var div_18 = root_82();
          var b_1 = sibling(child(div_18));
          var text_5 = child(b_1, true);
          reset(b_1);
          var div_19 = sibling(b_1, 4);
          var button_3 = child(div_19);
          button_3.__click = [fetchModels, errorMessage, appState2, selectedProviderId];
          var node_7 = child(button_3);
          {
            var consequent_4 = ($$anchor4) => {
              var text_6 = text("Getting models...");
              append($$anchor4, text_6);
            };
            var alternate = ($$anchor4) => {
              var text_7 = text("Get model list");
              append($$anchor4, text_7);
            };
            if_block(node_7, ($$render) => {
              if (get(isUpdating)) $$render(consequent_4);
              else $$render(alternate, false);
            });
          }
          reset(button_3);
          reset(div_19);
          var node_8 = sibling(div_19, 2);
          {
            var consequent_5 = ($$anchor4) => {
              var error = root_11();
              var text_8 = child(error);
              var button_4 = sibling(text_8);
              button_4.__click = [on_click_5, errorMessage];
              var node_9 = child(button_4);
              X(node_9, { size: 24, strokeWidth: 2 });
              reset(button_4);
              reset(error);
              template_effect(() => {
                var _a3;
                return set_text(text_8, `${(_a3 = get(errorMessage)) != null ? _a3 : ""} `);
              });
              append($$anchor4, error);
            };
            if_block(node_8, ($$render) => {
              if (get(errorMessage)) $$render(consequent_5);
            });
          }
          reset(div_18);
          template_effect(() => {
            set_text(text_5, get(selectedProvider).name);
            button_3.disabled = get(isUpdating);
          });
          append($$anchor3, div_18);
        };
        var alternate_2 = ($$anchor3) => {
          var fragment_3 = root_122();
          var node_10 = first_child(fragment_3);
          {
            var consequent_7 = ($$anchor4) => {
              var error_1 = root_132();
              var text_9 = child(error_1);
              var button_5 = sibling(text_9);
              button_5.__click = [on_click_6, errorMessage];
              var node_11 = child(button_5);
              X(node_11, { size: 24, strokeWidth: 2 });
              reset(button_5);
              reset(error_1);
              template_effect(() => {
                var _a3;
                return set_text(text_9, `${(_a3 = get(errorMessage)) != null ? _a3 : ""} `);
              });
              append($$anchor4, error_1);
            };
            if_block(node_10, ($$render) => {
              if (get(errorMessage)) $$render(consequent_7);
            });
          }
          var node_12 = sibling(node_10, 2);
          each(node_12, 17, () => appState2().settings.GetModels(get(selectedProviderId)), index, ($$anchor4, model) => {
            var fragment_4 = comment();
            var node_13 = first_child(fragment_4);
            {
              var consequent_10 = ($$anchor5) => {
                var div_20 = root_152();
                div_20.__click = [on_click_7, clickModel, model];
                let classes_6;
                var node_14 = child(div_20);
                {
                  var consequent_8 = ($$anchor6) => {
                    var text_10 = text();
                    template_effect(() => set_text(text_10, get(model).id));
                    append($$anchor6, text_10);
                  };
                  var alternate_1 = ($$anchor6) => {
                    var fragment_6 = root_172();
                    var text_11 = first_child(fragment_6);
                    var label_free = sibling(text_11);
                    set_class(label_free, 1, "svelte-fcc3aa");
                    template_effect(($0) => set_text(text_11, `${$0 != null ? $0 : ""} `), [() => get(model).id.replace(":free", "")]);
                    append($$anchor6, fragment_6);
                  };
                  if_block(node_14, ($$render) => {
                    if (get(model).prompt + get(model).completion != 0) $$render(consequent_8);
                    else $$render(alternate_1, false);
                  });
                }
                var node_15 = sibling(node_14, 2);
                {
                  var consequent_9 = ($$anchor6) => {
                    var label_provider = root_182();
                    set_class(label_provider, 1, "svelte-fcc3aa");
                    var text_12 = child(label_provider, true);
                    reset(label_provider);
                    template_effect(($0) => set_text(text_12, $0), [() => getProviderName(get(model))]);
                    append($$anchor6, label_provider);
                  };
                  if_block(node_15, ($$render) => {
                    if (get(isSpecial)) $$render(consequent_9);
                  });
                }
                reset(div_20);
                template_effect(
                  ($0, $1) => {
                    classes_6 = set_class(div_20, 1, "vertical-tab-nav-item", null, classes_6, $0);
                    set_attribute2(div_20, "aria-label", $1);
                  },
                  [
                    () => ({
                      "is-active": appState2().generateParams.ModelID == get(model).id
                    }),
                    () => getModelDesc(get(model))
                  ]
                );
                append($$anchor5, div_20);
              };
              if_block(node_13, ($$render) => {
                if (checkFilter(get(model))) $$render(consequent_10);
              });
            }
            append($$anchor4, fragment_4);
          });
          append($$anchor3, fragment_3);
        };
        if_block(node_6, ($$render) => {
          if (!get(isSpecial) && !get(hasModels)) $$render(consequent_6);
          else $$render(alternate_2, false);
        });
      }
      append($$anchor2, fragment_2);
    };
    if_block(node_5, ($$render) => {
      if (!get(isSpecial) && !get(hasKey)) $$render(consequent_3);
      else $$render(alternate_3, false);
    });
  }
  reset(div_15);
  reset(div_13);
  reset(div_12);
  reset(div_9);
  reset(div);
  template_effect(
    ($0, $1, $2, $3) => {
      var _a3, _b3, _c2;
      classes_2 = set_class(div_8, 1, "vertical-tab-nav-item", null, classes_2, $0);
      classes_3 = set_class(button, 1, "clickable-icon svelte-fcc3aa", null, classes_3, $1);
      button.disabled = get(isUpdating) || !get(hasKey);
      set_attribute2(button, "aria-label", `Refresh models from ${(_a3 = get(selectedProviderName)) != null ? _a3 : ""}`);
      set_attribute2(button_1, "aria-label", `Review models from ${(_b3 = get(selectedProviderName)) != null ? _b3 : ""}`);
      button_1.disabled = get(isSpecial);
      classes_4 = set_class(input, 1, "models-filter-name inputbox2 svelte-fcc3aa", null, classes_4, $2);
      input.disabled = !get(hasKey) || !get(hasModels);
      classes_5 = set_class(label2, 1, "models-filter-free svelte-fcc3aa", null, classes_5, $3);
      input_1.disabled = !get(selectedProviderPrice) || !get(hasKey) || !get(hasModels);
      set_text(text_2, `Models from ${(_c2 = get(selectedProviderName)) != null ? _c2 : ""}`);
    },
    [
      () => ({ "is-active": RECENT_TAB == get(selectedProviderId) }),
      () => ({ disabled: get(isUpdating) || !get(hasKey) }),
      () => ({
        disabled: !get(isSpecial) && (!get(hasKey) || !get(hasModels))
      }),
      () => ({
        disabled: !get(selectedProviderPrice) || !get(hasKey) || !get(hasModels)
      })
    ]
  );
  bind_value(input, () => appState2().generateParams.FilterName, ($$value) => appState2().generateParams.FilterName = $$value);
  bind_checked(input_1, () => appState2().generateParams.FilterFree, ($$value) => appState2().generateParams.FilterFree = $$value);
  append($$anchor, div);
  pop();
}
delegate(["click"]);

// src/nodes/Generate/GenerateParams.svelte.js
var _NodeID, _ModelID, _ProviderID, _ProviderTab, _FilterName, _FilterFree;
var GenerateParams2 = class {
  constructor(appState2) {
    __privateAdd(this, _NodeID, state(0));
    __privateAdd(this, _ModelID, state(""));
    __privateAdd(this, _ProviderID, state(""));
    __privateAdd(this, _ProviderTab, state(""));
    __privateAdd(this, _FilterName, state(""));
    __privateAdd(this, _FilterFree, state(false));
    this.appState = appState2;
  }
  get NodeID() {
    return get(__privateGet(this, _NodeID));
  }
  set NodeID(value) {
    set(__privateGet(this, _NodeID), value, true);
  }
  get ModelID() {
    return get(__privateGet(this, _ModelID));
  }
  set ModelID(value) {
    set(__privateGet(this, _ModelID), value, true);
  }
  get ProviderID() {
    return get(__privateGet(this, _ProviderID));
  }
  set ProviderID(value) {
    set(__privateGet(this, _ProviderID), value, true);
  }
  get ProviderTab() {
    return get(__privateGet(this, _ProviderTab));
  }
  set ProviderTab(value) {
    set(__privateGet(this, _ProviderTab), value, true);
  }
  get FilterName() {
    return get(__privateGet(this, _FilterName));
  }
  set FilterName(value) {
    set(__privateGet(this, _FilterName), value, true);
  }
  get FilterFree() {
    return get(__privateGet(this, _FilterFree));
  }
  set FilterFree(value) {
    set(__privateGet(this, _FilterFree), value, true);
  }
  Show(nodeId, data) {
    if (!data.provider || !data.model) {
      this.ModelID = appState.settings.Data.defaultModel;
      this.ProviderID = appState.settings.Data.defaultProvider;
    } else {
      this.ModelID = data.model;
      this.ProviderID = data.provider;
    }
    this.NodeID = nodeId;
    new CanvasModal(this.appState, GenerateParams, "generate-params").open();
  }
};
_NodeID = new WeakMap();
_ModelID = new WeakMap();
_ProviderID = new WeakMap();
_ProviderTab = new WeakMap();
_FilterName = new WeakMap();
_FilterFree = new WeakMap();

// src/models/ModelInfo.svelte.js
var _Updating;
var ModelInfo = class {
  constructor() {
    __privateAdd(this, _Updating, state(proxy({})));
    this.readLocal();
  }
  get Updating() {
    return get(__privateGet(this, _Updating));
  }
  set Updating(value) {
    set(__privateGet(this, _Updating), value, true);
  }
  async readLocal() {
    while (!Settings_svelte_default.Data) await sleep(1);
    ProviderInfo_svelte_default.List.forEach((provider) => {
      let models = Settings_svelte_default.GetModels(provider.id);
      provider.ModelById = {};
      models.forEach((model) => {
        model.providerId = provider.id;
        provider.ModelById[model.id] = model;
      });
    });
  }
  async FetchModels(providerId) {
    if (this.Updating[providerId]) return;
    this.Updating[providerId] = true;
    let error = null;
    try {
      const provider = ProviderInfo_svelte_default.ById[providerId];
      const models = await provider.FetchModels();
      models.sort((a, b) => {
        if (a.id < b.id) return -1;
        else if (a.id > b.id) return 1;
        else return 0;
      });
      Settings_svelte_default.SetModels(providerId, models);
      Settings_svelte_default.Save();
      this.readLocal();
    } catch (ex) {
      error = ex;
    }
    this.Updating[providerId] = false;
    return error;
  }
};
_Updating = new WeakMap();
var modelInfo = new ModelInfo();
var ModelInfo_svelte_default = modelInfo;

// src/app/App.svelte.js
var AppState = class {
  constructor() {
    this.settings = Settings_svelte_default;
    this.providers = ProviderInfo_svelte_default;
    this.models = ModelInfo_svelte_default;
    this.graph = new GraphState();
    this.contextMenu = new ContextMenuState(), this.generateParams = new GenerateParams2(this);
  }
  ShowSettings() {
    this.settings.Show(this);
  }
};

// src/obsidian/CanvasView.js
var CanvasView = class extends import_obsidian3.TextFileView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.appState = new AppState();
    this.appState.view = this;
    this.appState.plugin = plugin;
    this.appState.app = plugin.app;
    this.appState.leaf = plugin.leaf;
    this.appState.graph.onChange = (eventName) => {
      this.requestSave();
    };
  }
  getViewType() {
    return "canvas-llm-view";
  }
  async setViewData(fileContents, clear) {
    const graphJson = JSON.parse(fileContents);
    await this.appState.graph.loadFromFile(graphJson);
    if (this.graphView) {
      unmount(this.graphView);
      delete this.graphView;
    }
    const viewRoot = this.contentEl;
    viewRoot.classList.add("canvas-llm");
    viewRoot.empty();
    this.graphView = mount(
      App,
      {
        target: viewRoot,
        props: { appState: this.appState }
      }
    );
  }
  getViewData() {
    const data = this.appState.graph.toString();
    return data;
  }
  clear() {
    if (this.graphView) {
      unmount(this.graphView);
      delete this.graphView;
    }
    const viewRoot = this.contentEl;
    viewRoot.classList.remove("canvas-llm");
    viewRoot.empty();
  }
};

// src/obsidian/CanvasPlugin.js
var CanvasPlugin = class extends import_obsidian4.Plugin {
  async onload() {
    Settings_svelte_default.Init(this);
    this.RegisterCanvasView();
    this.RegisterMenuItem();
    this.addRibbonIcon(
      "workflow",
      "Create new Canvas LLM",
      () => {
        this.CreateNewCanvas("/");
      }
    );
  }
  async onunload() {
  }
  async RegisterCanvasView() {
    this.registerExtensions(
      ["canvas-llm"],
      "canvas-llm-view"
    );
    this.registerView(
      "canvas-llm-view",
      (leaf) => new CanvasView(leaf, this)
    );
  }
  async RegisterMenuItem() {
    const fileMenuEvent = this.app.workspace.on(
      "file-menu",
      (menu, menuFile) => {
        if (menuFile.extension === void 0) {
          menu.addItem((item) => {
            item.setTitle("New Canvas LLM").setIcon("workflow").onClick(async () => {
              this.CreateNewCanvas(menuFile.path);
            });
          });
        }
      }
    );
    this.registerEvent(fileMenuEvent);
  }
  async IsFileExists(filePath) {
    const normalizedFilePath = (0, import_obsidian4.normalizePath)(filePath);
    const file = this.app.vault.getFileByPath(normalizedFilePath);
    return file != null;
  }
  async CreateNewCanvas(folderPath) {
    let counter = 0;
    let baseName = "Canvas LLM";
    let filePath = `${folderPath}/${baseName}.canvas-llm`;
    while (await this.IsFileExists(filePath)) {
      counter++;
      filePath = `${folderPath}/${baseName} ${counter}.canvas-llm`;
    }
    const graph = defaultGraph();
    const graphJson = JSON.stringify(graph, null, "	");
    const file = await this.app.vault.create(filePath, graphJson);
    const leaf = this.app.workspace.getLeaf();
    await leaf.openFile(file);
  }
};

// src/app/main.js
var main_default = CanvasPlugin;
/*! Bundled license information:

lucide-svelte/dist/defaultAttributes.js:
lucide-svelte/dist/icons/index.js:
lucide-svelte/dist/icons/map.js:
lucide-svelte/dist/icons/text-cursor-input.js:
lucide-svelte/dist/icons/x.js:
lucide-svelte/dist/icons/square-play.js:
lucide-svelte/dist/icons/square-x.js:
lucide-svelte/dist/aliases/suffixed.js:
  (**
   * @license lucide-svelte v0.545.0 - ISC
   *
   * ISC License
   * 
   * Copyright (c) for portions of Lucide are held by Cole Bemis 2013-2023 as part of Feather (MIT). All other copyright (c) for Lucide are held by Lucide Contributors 2025.
   * 
   * Permission to use, copy, modify, and/or distribute this software for any
   * purpose with or without fee is hereby granted, provided that the above
   * copyright notice and this permission notice appear in all copies.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
   * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
   * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
   * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   * 
   * ---
   * 
   * The MIT License (MIT) (for portions derived from Feather)
   * 
   * Copyright (c) 2013-2023 Cole Bemis
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   * 
   *)

lucide-svelte/dist/icons/copy.svelte:
lucide-svelte/dist/icons/lightbulb.svelte:
lucide-svelte/dist/icons/loader.svelte:
lucide-svelte/dist/icons/map.svelte:
lucide-svelte/dist/icons/play.svelte:
lucide-svelte/dist/icons/refresh-ccw.svelte:
lucide-svelte/dist/icons/settings.svelte:
lucide-svelte/dist/icons/square-arrow-out-up-right.svelte:
lucide-svelte/dist/icons/square-play.svelte:
lucide-svelte/dist/icons/square-x.svelte:
lucide-svelte/dist/icons/text-cursor-input.svelte:
lucide-svelte/dist/icons/x.svelte:
  (**
   * @license lucide-svelte v0.545.0 - ISC
   *
   * ISC License
   *
   * Copyright (c) for portions of Lucide are held by Cole Bemis 2013-2023 as part of Feather (MIT). All other copyright (c) for Lucide are held by Lucide Contributors 2025.
   *
   * Permission to use, copy, modify, and/or distribute this software for any
   * purpose with or without fee is hereby granted, provided that the above
   * copyright notice and this permission notice appear in all copies.
   *
   * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
   * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
   * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
   * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
   * ---
   *
   * The MIT License (MIT) (for portions derived from Feather)
   *
   * Copyright (c) 2013-2023 Cole Bemis
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   *
   *)
*/

/* nosourcemap */