# Unity 性能优化方法

## 通用优化

1. **通过ID访问属性**  
   Unity内部使用属性ID而非字符串访问Animator、Material和Shader属性。使用`Animator.StringToHash()`和`Shader.PropertyToID()`预生成ID并存储为静态只读变量，避免运行时字符串哈希计算开销。

2. **使用非分配物理API**  
   替换`RaycastAll`、`SphereCastAll`等分配内存的方法为`RaycastNonAlloc`、`SphereCastNonAlloc`，2D应用使用对应Physics2D非分配API，减少内存垃圾。

3. **避免Unity对象空值比较**  
   在Mono/IL2CPP运行时，`UnityEngine.Object`子类的空值比较比纯C#对象开销更大。在tight loops或每帧代码中避免此类比较。

4. **优化向量/四元数运算顺序**  
   整数运算 > 浮点运算 > 向量/矩阵/四元数运算。调整运算顺序减少昂贵运算次数，例如`a * b * x`比`a * x * b`更高效。

5. **使用内置ColorUtility**  
   Unity 5+提供`ColorUtility`高效转换HTML颜色字符串与Unity原生`Color`/`Color32`结构，替代旧的Unify Community脚本，减少内存分配。

6. **生产代码禁用Find类API**  
   `GameObject.Find`和`Object.FindObjectOfType`会遍历所有对象，随项目规模增长性能下降。仅在单例模式中谨慎使用，并确保不会重复调用。

7. **[Conditional]属性管理调试代码**  
   `UnityEngine.Debug`日志不会在非开发构建中自动剥离。用自定义方法包裹日志并添加`[Conditional("ENABLE_LOGS")]`属性，未定义宏时自动移除调试代码。