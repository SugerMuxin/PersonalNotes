---
author: RuoSaChen
tags:
  - teach
  - csharp
---


>1. 所有类型都派生自 System.Object (以下代买没区别)

```
public class SomeType {

}

public class SomeType : System.Object{


}
```

>2. new 一个对象的时候到底干了些啥？如果new一个空对象需要多少内存？new一个对象后里面的实例成员在内存中是连续的吗？
>   (1) 计算类型及其所有基类型(一直到 `System.Object`，虽然它没有定义自己的实例字段)中定义的所有实例字段需要的字节数。堆上每个对象都需要一些额外的成员，包括“类型对象指针”(type object pointer)和“同步块索引”(sync block index)。CLR 利用这些成员管理对象。额外成员的字节数要计入对象大小。
>   (2) 从托管堆中分配类型要求的字节数，从而分配对象的内存，分配的所有字节都设为零(0).
>   (3) 初始化对象的“类型对象指针”和“同步块索引”成员。
>   (4) 调用类型的实例构造器，传递在 `new` 调用中指定的实参(上例就是字符串"**ConstructorParam1**")。大多数编译器都在构造器中自动生成代码来调用基类构造器。每个类型的构造器都负责初始化该类型定义的实例字段。最终调用 `System.Object` 的构造器，该构造器什么都不做，简单地返回。
>
>   `new` 执行了所有这些操作之后，返回指向新建对象一个引用(或指针)
>   
>   一个空对象至少在堆上需要的内存消耗：“类型对象指针” 、“同步块索引” （之所以说结构体更轻，也就是因为结构体不需要在堆上开内存）

>3. 以下两种写法哪一种比较好？
>
```
	 internal class Employee {
        ···
    }

    internal class Manager : Employee {
        ···
    }

第一种
	if (o is Employee){
	    Employee e = (Employee) o;
	    // 在 if 语句剩余的部分中使用 e
	}
第二种
	Employee e = o as Employee;
	if (e != null) {
	    // 在 if 语句中使用 e
	}
```
答案是第二种，第一种写法中CLR 实际检查两次对象类型。第二种方法中使用 as 返回对同一个对象的非空引用。as 有可能会返回 null.


>4. 当一个简单的结构，似乎可以设计为class 也可以设计为 struct的时候该怎么选择？因为值类型往往能提供更好的性能 。具体来说，除非满足以下全部条件，否则不应该将类型声明为值类型：
>  （1）- 类型具有基元类型的行为。也就是说，是十分简单的类型，没有成员会修改类型的任何实例字段。如果类型没有提供会更改其字段的成员，就说该类型是**不可变**(immutable)类型。事实上，对于许多值类型，我们都建议将全部字段标记为 **readonly**(详情参见第 7 章 “常量和字段”)。
>  （2）- 类型不需要从其他任何类型继承。
>  （3）- 类型也不派生出其他任何类型。