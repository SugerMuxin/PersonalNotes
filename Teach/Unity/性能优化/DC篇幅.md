
渲染和画油画有一点类似，先会打一层底色，然后根据场景的近远从一层一层的话，不过画下一层的时候需要等待上一层的颜料彻底干了才能再在上面糊。

Drawcall就和这个层差不多，如果层数多的话明显就需要更多的运算，更长的时间。就会增加CPU，GPU等各方元器件的运行压力，产生更多的热量。

一般会控制游戏的帧率为30或者60（当帧率超过24时，人眼就就基本感觉不到了），那么一帧的时间就是0.016s或者0.033s,也就是16ms或者33ms，在这一帧之内需要完成内存数据到CPU的运算到GPU的渲染等等的一些列操作。（tip：所以update中不能做复杂的操作），以60fps为例，假如利用了15ms才能完成所有的操作，那么元器件就只剩下1ms的时间在休眠状态，也就会持续的产生热量，这样会造成手机发烫，假如16ms都不够完成的话，那就会出现明显的卡顿现象，影响用户体验。

Drawcall是CPU对底层图形绘制接口的调用命令GPU执行渲染操作，渲染流程采用流水线实现，CPU和GPU并行工作，它们之间通过命令缓冲区连接，CPU向其中发送渲染命令，GPU接收并执行对应的渲染命令。

降低Drawcall的主要方法是减少场景或者UI上使用的材质种类，并通过合批，合并图集的方式来减少数量。需要注意的是，并非Drawcall越低越好。因为决定渲染模块性能的除了Drawcall之外，还有用于传输渲染数据的总线带宽。当我们使用Drawcall Batching将同种材质的网格模型拼接在一起的时候，可能会造成一次DC中需要传输的数据（Texture,Mesh等）过大，以至于带宽堵塞，在资源无法及时传输到显存的时候，GPU只能暂时歇业，反而会降低帧率。