1.在有多个相机的情况下首先判断Camera的Depth.   Depth低的先被渲染

2.透明，不透明的物体分隔
	RenderQueue 2500是透明与不透明的分水岭。
	同一个相机下
	Renderqueue小于2500的物体 始终在 Renderqueue大于2500之前绘制。


3.Sorting Layer
	如果Camera相同，那接下来就看Sorting Layers，越低越早绘制。

<span style="color:red;">那么这里问个问题，假如场景中有三个cube（下图），分别在不同的layer？，那么应该会分为几个批次来渲染呢？</span>
![[Pasted image 20240425172732.png]]

<span style="color:green;">答案是三个正方体会在一次DC中渲染，并不是想象中的分为三个layer先后来渲染。因为三个物体使用了相同的材质，Dynamic Batching对其进行了合批。</span>


4.Order in Layer
	相对于Sorting Layer的子排序，用这个值做比较时只有都在同一层时才有效。
	soringOrder也是Render的一个属性，这个order是设置一个数字，数字越大，越在上面显示。
	![[Pasted image 20240424192408.png]]

SortingGroup ： 这个组件就可以对不同的层级和相同的layer进行渲染顺序的调节（<span style="color:yellow;">SortingGroup将这个对象的所有子对象作为一个整体来考虑，子对象不再单独参与全局排序的规则，组内仍可以通过Order in Layer 或者材质的 RenderQueue来调整内部的顺序</span>）

5.RenderQueue
	Shader中对Tags设置的“Queue”。
	如果上述几项都相同，那就要看renderQueue了，renderQueure是Material的一个属性，其实就是Shader中的renderQueue，这个也是一个int属性，数值越小，越靠前渲染。
![[Pasted image 20240424192534.png]]

6.深度排序，按照包围盒的深度进行排序
这就和现时世界一样，远的物体会被近的物体遮挡，通过 Zbuffer + ZTest 技术来决定最终的渲染片元

深度补间<span style="color:red;"> ZBias</span>, 当两个包围盒的中心店深度值相同或者很近的物体在一起时，排序可能是错的，所以对于这个点的Z值可以进行微调。

