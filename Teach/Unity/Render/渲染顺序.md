1.在有多个相机的情况下首先判断Camera的Depth.   Depth低的先被渲染

2.透明，不透明的物体分隔
	RenderQueue 2500是透明与不透明的分水岭。
	同一个相机下
	Renderqueue小于2500的物体 始终在 Renderqueue大于2500之前绘制。


3.Sorting Layer
	如果Camera相同，那接下来就看Sorting Layers，越低越早绘制。

<span style="color:red;">那么这里问个问题，假如场景中有三个cube（下图），分别在不同的layer？，那么应该会分为几个批次来渲染呢？</span>
![[Pasted image 20240425172732.png]]

<span style="color:green;">答案是三个正方体会在一次DC中渲染，并不是想象中的分为三个layer先后来渲染。因为三个物体使用了相同的材质，Dynamic Batching对其进行了合批。</span>


4.Order in Layer
	相对于Sorting Layer的子排序，用这个值做比较时只有都在同一层时才有效。
	soringOrder也是Render的一个属性，这个order是设置一个数字，数字越大，越在上面显示。
	![[Pasted image 20240424192408.png]]

5.RenderQueue
	Shader中对Tags设置的“Queue”。
	如果上述几项都相同，那就要看renderQueue了，renderQueure是Material的一个属性，其实就是Shader中的renderQueue，这个也是一个int属性，数值越小，越靠前渲染。
![[Pasted image 20240424192534.png]]

6.深度排序，按照包围盒的深度进行排序
这就和现时世界一样，远的物体会被近的物体遮挡，通过 Zbuffer + ZTest 技术来决定最终的渲染片元

深度补间 ZBias, 当两个包围盒的中心店深度值相同或者很近的物体在一起时，排序可能是错的，所以对于这个点的Z值可以进行微调。

## **常规方案**

## 明确分层：

例如UI上的半透明（特效、面片）始终在3D场景之上，则一般分多个相机来绘制。

大多适用于有明确分层的游戏。例如横版游戏，明确近景远景

大片填充率的物件，例如地形，天空等，一般为提高深度命中，都会选择在延后批次绘制。

Draw character before the terrain.

## UGUI方案

- 同一个canvas，使用Hierarchy的顺序
- 不同的canvas之间使用sort order来排序

  

## NGUI

不同的pannel按照depth数值排序，同一个pannel中的结点按照深度排序。

  

## 其他排序手段

OIT

也没有太适合的移动解决方案。。。

Unity2018后：

可编程渲染管线——LWRP轻量级渲染管线。可以自定义管线控制排序。。。

三角形排序：

主流引擎都不支持，可使用的场景较少，限制较多。曾在Unity引擎中增加了三角形重心快速排序，效率也不高。。。

## 问题

## 那么问题来了，能控制渲染顺序的手段还真多，一般**移动**游戏比较正统的或者好用的控制渲染顺序的**规范**是什么样的？