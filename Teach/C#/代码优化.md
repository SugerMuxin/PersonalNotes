---
author: RuoSaChen
tags:
  - csharp
---

>1.virtual与override的使用 

从C#的程序编译的角度来看：
	一般函数：在编译时就静态编译到了执行文件中，其相对地址在程序运行期间是不会发生变化的。
	 虚函数：在编译期间是不会被动态编译的，它的相对地址是不确定的，它会根据运行时期对象实例来动态判断要调用的函数，其中那个申明时定义的类叫申明类，那个执行时实例化的类叫实例类。
	所以从效率上来讲，虚方法的使用效率肯定是比较低一些的。


>2 . Dispose


在开发过程中，我们经常听到关于释放资源，内训泄漏等等的字眼。那么到底什么是资源，又需要怎么取释放呢？简单的讲，C#中用到的每一种类型都是一种资源，或者可以说只要占用了内存，那它就是资源，就应该需要在合适的时候对内存进行释放，否则就会造成浪费。在C#中资源可以分为托管资源和非托管资源

托管资源：由CLR管理分配和释放的资源，也就是我们直接new出来的对象；它的释放也不需要我们去操心，GC会在合适的时候释放。

非托管资源：不受CLR控制的资源，也就是不属于.NET本身的功能，往往是通过调用跨平台程序集或者操作系统提供的一些接口，比如文件操作，数据库连接，套接字，网络连接等。因为CLR根本不知道你读一个文件需要什么时候结束，网络连接又什么时候不需要，所以它无法替你GC.


>3 .类型转换

使用默认类型转换
在编码中我们会频繁的使用 string,int,float 等之间的相互的转换，尤其是在配置表到对象的实例化的过程中，
那么我们如何进行高效的类型转换就成了一个需要注意的问题。通常得用的帮助类提供的方法，如下：
```
string strValue ="100";
int intValue = 0;
int.TryParse(strValue,out intValue);

string str = intValue.ToString();

double doubleValue = intValue.ToDouble();

```


>4. 数组,ArrayList,List的区别

在设计之初是只有数组的，但是数组有两个很大的弱点，一个是初始化的时候必须要给定长度，如果太长很可能会浪费内存，给的少了又往往会遇到空间不足的情况。

所以迭代出了一个ArrayList版本，解决了这两个问题。但是ArrayList里面存储的是object，又有两个问题。第一个是在装箱和拆箱的过程中会产生性能的问题，第二个是在拆箱的过程中可能会出现类型转换的异常，说明ArrayList是类型不安全的。

所以又迭代出了List的泛型版本。